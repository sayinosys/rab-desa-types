
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Coordinate
 * 
 */
export type Coordinate = {
  longitude: number
  latitude: number
}

/**
 * Model Address
 * 
 */
export type Address = {
  provinsi: string
  kabupaten: string
  kecamatan: string
  kelurahan: string
  kodepos: string
  jalan: string
  coordinate: Coordinate | null
}

/**
 * Model TPhone
 * 
 */
export type TPhone = {
  code: string
  number: number
}

/**
 * Model TPropertyPrice
 * 
 */
export type TPropertyPrice = {
  type: ItemModel
  itemId: string
  workIds: string[]
  coefficient: number
  rounding: number
  price: number
  pph: boolean
  ppn: boolean
}

/**
 * Model TPropertyIntro
 * 
 */
export type TPropertyIntro = {
  itemId: string
  qty: number
}

/**
 * Model TProperty
 * 
 */
export type TProperty = {
  images: string | null
  intros: TPropertyIntro[]
  prices: TPropertyPrice[]
  pph: boolean
  ppn: boolean
  pphVal: number
  ppnVal: number
}

/**
 * Model TAround
 * 
 */
export type TAround = {
  long: string | null
  width: string | null
  height: string | null
}

/**
 * Model TFieldList
 * 
 */
export type TFieldList = {
  id: string
  name: string
  type: EFieldType
}

/**
 * Model TDeDList
 * 
 */
export type TDeDList = {
  id: string
  filename: string
  name: string
  url: string
  size: number
  width: number
  height: number
  top: number
  left: number
  type: string
}

/**
 * Model TValues
 * 
 */
export type TValues = {
  around: number
  broad: number
  volume: number
}

/**
 * Model SpaceValue
 * 
 */
export type SpaceValue = {
  fixed: boolean
  value: number
  min: number
  max: number
}

/**
 * Model StageValue
 * 
 */
export type StageValue = {
  ref: string | null
  refal: number | null
  value: number
}

/**
 * Model Histori
 * 
 */
export type Histori = {
  id: string
  type: HistoriType
  model: HistoriModel
  step: number | null
  message: string | null
  refId: string
  createdAt: Date
  userId: string | null
  companyId: string | null
  optionId: string | null
  unitId: string | null
  itemId: string | null
  workId: string | null
  workItemsId: string | null
  templateId: string | null
  imageId: string | null
  fileId: string | null
}

/**
 * Model Device
 * 
 */
export type Device = {
  id: string
  uuid: string
  model: string
  manufacturer: string
  userId: string
}

/**
 * Model Company
 * 
 */
export type Company = {
  id: string
  gid: string | null
  name: string
  address: Address
  phone: TPhone | null
  limit: number
}

/**
 * Model User
 * 
 */
export type User = {
  id: string
  name: string
  email: string
  username: string
  password: string
  passhash: string
  role: UserRole
  active: boolean
  companyId: string | null
}

/**
 * Model File
 * 
 */
export type File = {
  id: string
  name: string
  url: string
  size: number
  width: number
  height: number
  type: string
  groupId: string
}

/**
 * Model Image
 * 
 */
export type Image = {
  id: string
  name: string
}

/**
 * Model Option
 * 
 */
export type Option = {
  id: string
  type: OptionType
  code: string | null
  name: string
}

/**
 * Model Unit
 * 
 */
export type Unit = {
  id: string
  name: string
}

/**
 * Model Item
 * 
 */
export type Item = {
  id: string
  model: ItemModel
  categoryId: string
  typeId: string | null
  unitId: string
  code: string | null
  name: string | null
  price: number
  trim: boolean
  active: boolean
  introIds: string[]
}

/**
 * Model Work
 * 
 */
export type Work = {
  id: string
  model: WorkModel
  code: string
  name: string
  active: boolean
  typeId: string
  unitId: string
}

/**
 * Model WorkItems
 * 
 */
export type WorkItems = {
  id: string
  model: WorkModel
  workId: string
  itemId: string
  coefficient: number
  unitId: string | null
}

/**
 * Model Template
 * 
 */
export type Template = {
  id: string
  name: string
  activeId: string | null
}

/**
 * Model TemplateWorkItem
 * 
 */
export type TemplateWorkItem = {
  id: string
  type: ItemModel
  itemId: string
  coefficient: number
  unitId: string
  parentId: string
}

/**
 * Model TemplateWork
 * 
 */
export type TemplateWork = {
  id: string
  dataId: string
  workId: string
}

/**
 * Model TemplateData
 * 
 */
export type TemplateData = {
  id: string
  step: number
  publish: boolean
  templateId: string
  around: TAround | null
  properties: TProperty
}

/**
 * Model TemplateField
 * 
 */
export type TemplateField = {
  id: string
  dataId: string
  name: string
  imageId: string | null
  imageUrl: string | null
  lists: TFieldList[]
}

/**
 * Model TemplateDED
 * 
 */
export type TemplateDED = {
  id: string
  dataId: string
  name: string
  lists: TDeDList[]
}

/**
 * Model Space
 * 
 */
export type Space = {
  id: string
  refId: string
  name: string
  long: SpaceValue
  width: SpaceValue
  height: SpaceValue
  amount: SpaceValue
  values: TValues
}

/**
 * Model Stage
 * 
 */
export type Stage = {
  id: string
  workId: string
  type: StageType
  operation: StageOpr
  parentId: string | null
  refs: string | null
  refParent: boolean | null
  name: string | null
  long: StageValue
  width: StageValue
  height: StageValue
  amount: StageValue
  values: TValues
}


/**
 * Enums
 */

export const EFieldType: {
  long: 'long',
  height: 'height',
  width: 'width',
  amount: 'amount'
};

export type EFieldType = (typeof EFieldType)[keyof typeof EFieldType]


export const HistoriModel: {
  User: 'User',
  Company: 'Company',
  Option: 'Option',
  Unit: 'Unit',
  Item: 'Item',
  Work: 'Work',
  WorkItems: 'WorkItems',
  Template: 'Template',
  Image: 'Image',
  File: 'File'
};

export type HistoriModel = (typeof HistoriModel)[keyof typeof HistoriModel]


export const HistoriType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type HistoriType = (typeof HistoriType)[keyof typeof HistoriType]


export const ItemModel: {
  UPAH: 'UPAH',
  ALAT: 'ALAT',
  BAHAN: 'BAHAN',
  MULAI: 'MULAI'
};

export type ItemModel = (typeof ItemModel)[keyof typeof ItemModel]


export const OptionType: {
  CATEGORY: 'CATEGORY',
  TYPE: 'TYPE',
  WORK: 'WORK',
  GROUP: 'GROUP'
};

export type OptionType = (typeof OptionType)[keyof typeof OptionType]


export const StageOpr: {
  PLUS: 'PLUS',
  MINUS: 'MINUS',
  TIMES: 'TIMES',
  FOR: 'FOR'
};

export type StageOpr = (typeof StageOpr)[keyof typeof StageOpr]


export const StageType: {
  LONG: 'LONG',
  HEIGHT: 'HEIGHT',
  WIDTH: 'WIDTH',
  AMOUNT: 'AMOUNT',
  AROUND: 'AROUND',
  BROAD: 'BROAD',
  VOLUME: 'VOLUME'
};

export type StageType = (typeof StageType)[keyof typeof StageType]


export const UserRole: {
  SU: 'SU',
  ADM: 'ADM',
  USR: 'USR'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const WorkModel: {
  UMUM: 'UMUM',
  CIPTA_KARYA: 'CIPTA_KARYA',
  BINA_MARGA: 'BINA_MARGA',
  SDA: 'SDA',
  CUSTOM: 'CUSTOM'
};

export type WorkModel = (typeof WorkModel)[keyof typeof WorkModel]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Historis
 * const historis = await prisma.histori.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Historis
   * const historis = await prisma.histori.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number }): Promise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

      /**
   * `prisma.histori`: Exposes CRUD operations for the **Histori** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Historis
    * const historis = await prisma.histori.findMany()
    * ```
    */
  get histori(): Prisma.HistoriDelegate<GlobalReject>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<GlobalReject>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<GlobalReject>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<GlobalReject>;

  /**
   * `prisma.option`: Exposes CRUD operations for the **Option** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Options
    * const options = await prisma.option.findMany()
    * ```
    */
  get option(): Prisma.OptionDelegate<GlobalReject>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<GlobalReject>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<GlobalReject>;

  /**
   * `prisma.work`: Exposes CRUD operations for the **Work** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Works
    * const works = await prisma.work.findMany()
    * ```
    */
  get work(): Prisma.WorkDelegate<GlobalReject>;

  /**
   * `prisma.workItems`: Exposes CRUD operations for the **WorkItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkItems
    * const workItems = await prisma.workItems.findMany()
    * ```
    */
  get workItems(): Prisma.WorkItemsDelegate<GlobalReject>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<GlobalReject>;

  /**
   * `prisma.templateWorkItem`: Exposes CRUD operations for the **TemplateWorkItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateWorkItems
    * const templateWorkItems = await prisma.templateWorkItem.findMany()
    * ```
    */
  get templateWorkItem(): Prisma.TemplateWorkItemDelegate<GlobalReject>;

  /**
   * `prisma.templateWork`: Exposes CRUD operations for the **TemplateWork** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateWorks
    * const templateWorks = await prisma.templateWork.findMany()
    * ```
    */
  get templateWork(): Prisma.TemplateWorkDelegate<GlobalReject>;

  /**
   * `prisma.templateData`: Exposes CRUD operations for the **TemplateData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateData
    * const templateData = await prisma.templateData.findMany()
    * ```
    */
  get templateData(): Prisma.TemplateDataDelegate<GlobalReject>;

  /**
   * `prisma.templateField`: Exposes CRUD operations for the **TemplateField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateFields
    * const templateFields = await prisma.templateField.findMany()
    * ```
    */
  get templateField(): Prisma.TemplateFieldDelegate<GlobalReject>;

  /**
   * `prisma.templateDED`: Exposes CRUD operations for the **TemplateDED** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateDEDS
    * const templateDEDS = await prisma.templateDED.findMany()
    * ```
    */
  get templateDED(): Prisma.TemplateDEDDelegate<GlobalReject>;

  /**
   * `prisma.space`: Exposes CRUD operations for the **Space** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Spaces
    * const spaces = await prisma.space.findMany()
    * ```
    */
  get space(): Prisma.SpaceDelegate<GlobalReject>;

  /**
   * `prisma.stage`: Exposes CRUD operations for the **Stage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stages
    * const stages = await prisma.stage.findMany()
    * ```
    */
  get stage(): Prisma.StageDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.15.0
   * Query Engine version: 8fbc245156db7124f997f4cecdd8d1219e360944
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Histori: 'Histori',
    Device: 'Device',
    Company: 'Company',
    User: 'User',
    File: 'File',
    Image: 'Image',
    Option: 'Option',
    Unit: 'Unit',
    Item: 'Item',
    Work: 'Work',
    WorkItems: 'WorkItems',
    Template: 'Template',
    TemplateWorkItem: 'TemplateWorkItem',
    TemplateWork: 'TemplateWork',
    TemplateData: 'TemplateData',
    TemplateField: 'TemplateField',
    TemplateDED: 'TemplateDED',
    Space: 'Space',
    Stage: 'Stage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */


  export type CompanyCountOutputType = {
    users: number
    historis: number
  }

  export type CompanyCountOutputTypeSelect = {
    users?: boolean
    historis?: boolean
  }

  export type CompanyCountOutputTypeGetPayload<S extends boolean | null | undefined | CompanyCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CompanyCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CompanyCountOutputTypeArgs)
    ? CompanyCountOutputType 
    : S extends { select: any } & (CompanyCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CompanyCountOutputType ? CompanyCountOutputType[P] : never
  } 
      : CompanyCountOutputType




  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    trackers: number
    historis: number
    devices: number
  }

  export type UserCountOutputTypeSelect = {
    trackers?: boolean
    historis?: boolean
    devices?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type FileCountOutputType
   */


  export type FileCountOutputType = {
    historis: number
    fields: number
  }

  export type FileCountOutputTypeSelect = {
    historis?: boolean
    fields?: boolean
  }

  export type FileCountOutputTypeGetPayload<S extends boolean | null | undefined | FileCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FileCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FileCountOutputTypeArgs)
    ? FileCountOutputType 
    : S extends { select: any } & (FileCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FileCountOutputType ? FileCountOutputType[P] : never
  } 
      : FileCountOutputType




  // Custom InputTypes

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect | null
  }



  /**
   * Count Type ImageCountOutputType
   */


  export type ImageCountOutputType = {
    files: number
    historis: number
  }

  export type ImageCountOutputTypeSelect = {
    files?: boolean
    historis?: boolean
  }

  export type ImageCountOutputTypeGetPayload<S extends boolean | null | undefined | ImageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ImageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ImageCountOutputTypeArgs)
    ? ImageCountOutputType 
    : S extends { select: any } & (ImageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ImageCountOutputType ? ImageCountOutputType[P] : never
  } 
      : ImageCountOutputType




  // Custom InputTypes

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect | null
  }



  /**
   * Count Type OptionCountOutputType
   */


  export type OptionCountOutputType = {
    itemCategorys: number
    itemTypes: number
    workTypes: number
    historis: number
  }

  export type OptionCountOutputTypeSelect = {
    itemCategorys?: boolean
    itemTypes?: boolean
    workTypes?: boolean
    historis?: boolean
  }

  export type OptionCountOutputTypeGetPayload<S extends boolean | null | undefined | OptionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OptionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OptionCountOutputTypeArgs)
    ? OptionCountOutputType 
    : S extends { select: any } & (OptionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OptionCountOutputType ? OptionCountOutputType[P] : never
  } 
      : OptionCountOutputType




  // Custom InputTypes

  /**
   * OptionCountOutputType without action
   */
  export type OptionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OptionCountOutputType
     */
    select?: OptionCountOutputTypeSelect | null
  }



  /**
   * Count Type UnitCountOutputType
   */


  export type UnitCountOutputType = {
    items: number
    works: number
    workItems: number
    historis: number
    tWorkItems: number
  }

  export type UnitCountOutputTypeSelect = {
    items?: boolean
    works?: boolean
    workItems?: boolean
    historis?: boolean
    tWorkItems?: boolean
  }

  export type UnitCountOutputTypeGetPayload<S extends boolean | null | undefined | UnitCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UnitCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UnitCountOutputTypeArgs)
    ? UnitCountOutputType 
    : S extends { select: any } & (UnitCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UnitCountOutputType ? UnitCountOutputType[P] : never
  } 
      : UnitCountOutputType




  // Custom InputTypes

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect | null
  }



  /**
   * Count Type ItemCountOutputType
   */


  export type ItemCountOutputType = {
    works: number
    historis: number
    tWorks: number
  }

  export type ItemCountOutputTypeSelect = {
    works?: boolean
    historis?: boolean
    tWorks?: boolean
  }

  export type ItemCountOutputTypeGetPayload<S extends boolean | null | undefined | ItemCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ItemCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ItemCountOutputTypeArgs)
    ? ItemCountOutputType 
    : S extends { select: any } & (ItemCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ItemCountOutputType ? ItemCountOutputType[P] : never
  } 
      : ItemCountOutputType




  // Custom InputTypes

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkCountOutputType
   */


  export type WorkCountOutputType = {
    items: number
    historis: number
    templates: number
  }

  export type WorkCountOutputTypeSelect = {
    items?: boolean
    historis?: boolean
    templates?: boolean
  }

  export type WorkCountOutputTypeGetPayload<S extends boolean | null | undefined | WorkCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorkCountOutputTypeArgs)
    ? WorkCountOutputType 
    : S extends { select: any } & (WorkCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorkCountOutputType ? WorkCountOutputType[P] : never
  } 
      : WorkCountOutputType




  // Custom InputTypes

  /**
   * WorkCountOutputType without action
   */
  export type WorkCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkCountOutputType
     */
    select?: WorkCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkItemsCountOutputType
   */


  export type WorkItemsCountOutputType = {
    historis: number
  }

  export type WorkItemsCountOutputTypeSelect = {
    historis?: boolean
  }

  export type WorkItemsCountOutputTypeGetPayload<S extends boolean | null | undefined | WorkItemsCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkItemsCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorkItemsCountOutputTypeArgs)
    ? WorkItemsCountOutputType 
    : S extends { select: any } & (WorkItemsCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorkItemsCountOutputType ? WorkItemsCountOutputType[P] : never
  } 
      : WorkItemsCountOutputType




  // Custom InputTypes

  /**
   * WorkItemsCountOutputType without action
   */
  export type WorkItemsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkItemsCountOutputType
     */
    select?: WorkItemsCountOutputTypeSelect | null
  }



  /**
   * Count Type TemplateCountOutputType
   */


  export type TemplateCountOutputType = {
    records: number
    historis: number
  }

  export type TemplateCountOutputTypeSelect = {
    records?: boolean
    historis?: boolean
  }

  export type TemplateCountOutputTypeGetPayload<S extends boolean | null | undefined | TemplateCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TemplateCountOutputTypeArgs)
    ? TemplateCountOutputType 
    : S extends { select: any } & (TemplateCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TemplateCountOutputType ? TemplateCountOutputType[P] : never
  } 
      : TemplateCountOutputType




  // Custom InputTypes

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TemplateCountOutputType
     */
    select?: TemplateCountOutputTypeSelect | null
  }



  /**
   * Count Type TemplateWorkCountOutputType
   */


  export type TemplateWorkCountOutputType = {
    items: number
    stages: number
  }

  export type TemplateWorkCountOutputTypeSelect = {
    items?: boolean
    stages?: boolean
  }

  export type TemplateWorkCountOutputTypeGetPayload<S extends boolean | null | undefined | TemplateWorkCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateWorkCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TemplateWorkCountOutputTypeArgs)
    ? TemplateWorkCountOutputType 
    : S extends { select: any } & (TemplateWorkCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TemplateWorkCountOutputType ? TemplateWorkCountOutputType[P] : never
  } 
      : TemplateWorkCountOutputType




  // Custom InputTypes

  /**
   * TemplateWorkCountOutputType without action
   */
  export type TemplateWorkCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkCountOutputType
     */
    select?: TemplateWorkCountOutputTypeSelect | null
  }



  /**
   * Count Type TemplateDataCountOutputType
   */


  export type TemplateDataCountOutputType = {
    spaces: number
    works: number
    deds: number
    fields: number
  }

  export type TemplateDataCountOutputTypeSelect = {
    spaces?: boolean
    works?: boolean
    deds?: boolean
    fields?: boolean
  }

  export type TemplateDataCountOutputTypeGetPayload<S extends boolean | null | undefined | TemplateDataCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateDataCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TemplateDataCountOutputTypeArgs)
    ? TemplateDataCountOutputType 
    : S extends { select: any } & (TemplateDataCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TemplateDataCountOutputType ? TemplateDataCountOutputType[P] : never
  } 
      : TemplateDataCountOutputType




  // Custom InputTypes

  /**
   * TemplateDataCountOutputType without action
   */
  export type TemplateDataCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TemplateDataCountOutputType
     */
    select?: TemplateDataCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Coordinate
   */





  export type CoordinateSelect = {
    longitude?: boolean
    latitude?: boolean
  }


  export type CoordinateGetPayload<S extends boolean | null | undefined | CoordinateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Coordinate :
    S extends undefined ? never :
    S extends { include: any } & (CoordinateArgs)
    ? Coordinate 
    : S extends { select: any } & (CoordinateArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Coordinate ? Coordinate[P] : never
  } 
      : Coordinate



  export interface CoordinateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Coordinate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CoordinateClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Coordinate without action
   */
  export type CoordinateArgs = {
    /**
     * Select specific fields to fetch from the Coordinate
     */
    select?: CoordinateSelect | null
  }



  /**
   * Model Address
   */





  export type AddressSelect = {
    provinsi?: boolean
    kabupaten?: boolean
    kecamatan?: boolean
    kelurahan?: boolean
    kodepos?: boolean
    jalan?: boolean
    coordinate?: boolean | CoordinateArgs
  }


  export type AddressInclude = {}

  export type AddressGetPayload<S extends boolean | null | undefined | AddressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Address :
    S extends undefined ? never :
    S extends { include: any } & (AddressArgs)
    ? Address 
    : S extends { select: any } & (AddressArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'coordinate' ? CoordinateGetPayload<S['select'][P]> | null :  P extends keyof Address ? Address[P] : never
  } 
      : Address



  export interface AddressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    coordinate<T extends CoordinateArgs= {}>(args?: Subset<T, CoordinateArgs>): Prisma__CoordinateClient<CoordinateGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AddressInclude | null
  }



  /**
   * Model TPhone
   */





  export type TPhoneSelect = {
    code?: boolean
    number?: boolean
  }


  export type TPhoneGetPayload<S extends boolean | null | undefined | TPhoneArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TPhone :
    S extends undefined ? never :
    S extends { include: any } & (TPhoneArgs)
    ? TPhone 
    : S extends { select: any } & (TPhoneArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TPhone ? TPhone[P] : never
  } 
      : TPhone



  export interface TPhoneDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TPhone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TPhoneClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TPhone without action
   */
  export type TPhoneArgs = {
    /**
     * Select specific fields to fetch from the TPhone
     */
    select?: TPhoneSelect | null
  }



  /**
   * Model TPropertyPrice
   */





  export type TPropertyPriceSelect = {
    type?: boolean
    itemId?: boolean
    workIds?: boolean
    coefficient?: boolean
    rounding?: boolean
    price?: boolean
    pph?: boolean
    ppn?: boolean
  }


  export type TPropertyPriceGetPayload<S extends boolean | null | undefined | TPropertyPriceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TPropertyPrice :
    S extends undefined ? never :
    S extends { include: any } & (TPropertyPriceArgs)
    ? TPropertyPrice 
    : S extends { select: any } & (TPropertyPriceArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TPropertyPrice ? TPropertyPrice[P] : never
  } 
      : TPropertyPrice



  export interface TPropertyPriceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TPropertyPrice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TPropertyPriceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TPropertyPrice without action
   */
  export type TPropertyPriceArgs = {
    /**
     * Select specific fields to fetch from the TPropertyPrice
     */
    select?: TPropertyPriceSelect | null
  }



  /**
   * Model TPropertyIntro
   */





  export type TPropertyIntroSelect = {
    itemId?: boolean
    qty?: boolean
  }


  export type TPropertyIntroGetPayload<S extends boolean | null | undefined | TPropertyIntroArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TPropertyIntro :
    S extends undefined ? never :
    S extends { include: any } & (TPropertyIntroArgs)
    ? TPropertyIntro 
    : S extends { select: any } & (TPropertyIntroArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TPropertyIntro ? TPropertyIntro[P] : never
  } 
      : TPropertyIntro



  export interface TPropertyIntroDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TPropertyIntro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TPropertyIntroClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TPropertyIntro without action
   */
  export type TPropertyIntroArgs = {
    /**
     * Select specific fields to fetch from the TPropertyIntro
     */
    select?: TPropertyIntroSelect | null
  }



  /**
   * Model TProperty
   */





  export type TPropertySelect = {
    images?: boolean
    intros?: boolean | TPropertyIntroArgs
    prices?: boolean | TPropertyPriceArgs
    pph?: boolean
    ppn?: boolean
    pphVal?: boolean
    ppnVal?: boolean
  }


  export type TPropertyInclude = {}

  export type TPropertyGetPayload<S extends boolean | null | undefined | TPropertyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TProperty :
    S extends undefined ? never :
    S extends { include: any } & (TPropertyArgs)
    ? TProperty 
    : S extends { select: any } & (TPropertyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'intros' ? Array < TPropertyIntroGetPayload<S['select'][P]>>  :
        P extends 'prices' ? Array < TPropertyPriceGetPayload<S['select'][P]>>  :  P extends keyof TProperty ? TProperty[P] : never
  } 
      : TProperty



  export interface TPropertyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TProperty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TPropertyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    intros<T extends TPropertyIntroArgs= {}>(args?: Subset<T, TPropertyIntroArgs>): Prisma.PrismaPromise<Array<TPropertyIntroGetPayload<T>>| Null>;

    prices<T extends TPropertyPriceArgs= {}>(args?: Subset<T, TPropertyPriceArgs>): Prisma.PrismaPromise<Array<TPropertyPriceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TProperty without action
   */
  export type TPropertyArgs = {
    /**
     * Select specific fields to fetch from the TProperty
     */
    select?: TPropertySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TPropertyInclude | null
  }



  /**
   * Model TAround
   */





  export type TAroundSelect = {
    long?: boolean
    width?: boolean
    height?: boolean
  }


  export type TAroundGetPayload<S extends boolean | null | undefined | TAroundArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TAround :
    S extends undefined ? never :
    S extends { include: any } & (TAroundArgs)
    ? TAround 
    : S extends { select: any } & (TAroundArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TAround ? TAround[P] : never
  } 
      : TAround



  export interface TAroundDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TAround.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TAroundClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TAround without action
   */
  export type TAroundArgs = {
    /**
     * Select specific fields to fetch from the TAround
     */
    select?: TAroundSelect | null
  }



  /**
   * Model TFieldList
   */





  export type TFieldListSelect = {
    id?: boolean
    name?: boolean
    type?: boolean
  }


  export type TFieldListGetPayload<S extends boolean | null | undefined | TFieldListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TFieldList :
    S extends undefined ? never :
    S extends { include: any } & (TFieldListArgs)
    ? TFieldList 
    : S extends { select: any } & (TFieldListArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TFieldList ? TFieldList[P] : never
  } 
      : TFieldList



  export interface TFieldListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TFieldList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TFieldListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TFieldList without action
   */
  export type TFieldListArgs = {
    /**
     * Select specific fields to fetch from the TFieldList
     */
    select?: TFieldListSelect | null
  }



  /**
   * Model TDeDList
   */





  export type TDeDListSelect = {
    id?: boolean
    filename?: boolean
    name?: boolean
    url?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    top?: boolean
    left?: boolean
    type?: boolean
  }


  export type TDeDListGetPayload<S extends boolean | null | undefined | TDeDListArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TDeDList :
    S extends undefined ? never :
    S extends { include: any } & (TDeDListArgs)
    ? TDeDList 
    : S extends { select: any } & (TDeDListArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TDeDList ? TDeDList[P] : never
  } 
      : TDeDList



  export interface TDeDListDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TDeDList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TDeDListClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TDeDList without action
   */
  export type TDeDListArgs = {
    /**
     * Select specific fields to fetch from the TDeDList
     */
    select?: TDeDListSelect | null
  }



  /**
   * Model TValues
   */





  export type TValuesSelect = {
    around?: boolean
    broad?: boolean
    volume?: boolean
  }


  export type TValuesGetPayload<S extends boolean | null | undefined | TValuesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TValues :
    S extends undefined ? never :
    S extends { include: any } & (TValuesArgs)
    ? TValues 
    : S extends { select: any } & (TValuesArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TValues ? TValues[P] : never
  } 
      : TValues



  export interface TValuesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for TValues.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TValuesClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TValues without action
   */
  export type TValuesArgs = {
    /**
     * Select specific fields to fetch from the TValues
     */
    select?: TValuesSelect | null
  }



  /**
   * Model SpaceValue
   */





  export type SpaceValueSelect = {
    fixed?: boolean
    value?: boolean
    min?: boolean
    max?: boolean
  }


  export type SpaceValueGetPayload<S extends boolean | null | undefined | SpaceValueArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SpaceValue :
    S extends undefined ? never :
    S extends { include: any } & (SpaceValueArgs)
    ? SpaceValue 
    : S extends { select: any } & (SpaceValueArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SpaceValue ? SpaceValue[P] : never
  } 
      : SpaceValue



  export interface SpaceValueDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for SpaceValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpaceValueClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SpaceValue without action
   */
  export type SpaceValueArgs = {
    /**
     * Select specific fields to fetch from the SpaceValue
     */
    select?: SpaceValueSelect | null
  }



  /**
   * Model StageValue
   */





  export type StageValueSelect = {
    ref?: boolean
    refal?: boolean
    value?: boolean
  }


  export type StageValueGetPayload<S extends boolean | null | undefined | StageValueArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StageValue :
    S extends undefined ? never :
    S extends { include: any } & (StageValueArgs)
    ? StageValue 
    : S extends { select: any } & (StageValueArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StageValue ? StageValue[P] : never
  } 
      : StageValue



  export interface StageValueDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {







  }

  /**
   * The delegate class that acts as a "Promise-like" for StageValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StageValueClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * StageValue without action
   */
  export type StageValueArgs = {
    /**
     * Select specific fields to fetch from the StageValue
     */
    select?: StageValueSelect | null
  }



  /**
   * Model Histori
   */


  export type AggregateHistori = {
    _count: HistoriCountAggregateOutputType | null
    _avg: HistoriAvgAggregateOutputType | null
    _sum: HistoriSumAggregateOutputType | null
    _min: HistoriMinAggregateOutputType | null
    _max: HistoriMaxAggregateOutputType | null
  }

  export type HistoriAvgAggregateOutputType = {
    step: number | null
  }

  export type HistoriSumAggregateOutputType = {
    step: number | null
  }

  export type HistoriMinAggregateOutputType = {
    id: string | null
    type: HistoriType | null
    model: HistoriModel | null
    step: number | null
    message: string | null
    refId: string | null
    createdAt: Date | null
    userId: string | null
    companyId: string | null
    optionId: string | null
    unitId: string | null
    itemId: string | null
    workId: string | null
    workItemsId: string | null
    templateId: string | null
    imageId: string | null
    fileId: string | null
  }

  export type HistoriMaxAggregateOutputType = {
    id: string | null
    type: HistoriType | null
    model: HistoriModel | null
    step: number | null
    message: string | null
    refId: string | null
    createdAt: Date | null
    userId: string | null
    companyId: string | null
    optionId: string | null
    unitId: string | null
    itemId: string | null
    workId: string | null
    workItemsId: string | null
    templateId: string | null
    imageId: string | null
    fileId: string | null
  }

  export type HistoriCountAggregateOutputType = {
    id: number
    type: number
    model: number
    step: number
    message: number
    refId: number
    createdAt: number
    userId: number
    companyId: number
    optionId: number
    unitId: number
    itemId: number
    workId: number
    workItemsId: number
    templateId: number
    imageId: number
    fileId: number
    _all: number
  }


  export type HistoriAvgAggregateInputType = {
    step?: true
  }

  export type HistoriSumAggregateInputType = {
    step?: true
  }

  export type HistoriMinAggregateInputType = {
    id?: true
    type?: true
    model?: true
    step?: true
    message?: true
    refId?: true
    createdAt?: true
    userId?: true
    companyId?: true
    optionId?: true
    unitId?: true
    itemId?: true
    workId?: true
    workItemsId?: true
    templateId?: true
    imageId?: true
    fileId?: true
  }

  export type HistoriMaxAggregateInputType = {
    id?: true
    type?: true
    model?: true
    step?: true
    message?: true
    refId?: true
    createdAt?: true
    userId?: true
    companyId?: true
    optionId?: true
    unitId?: true
    itemId?: true
    workId?: true
    workItemsId?: true
    templateId?: true
    imageId?: true
    fileId?: true
  }

  export type HistoriCountAggregateInputType = {
    id?: true
    type?: true
    model?: true
    step?: true
    message?: true
    refId?: true
    createdAt?: true
    userId?: true
    companyId?: true
    optionId?: true
    unitId?: true
    itemId?: true
    workId?: true
    workItemsId?: true
    templateId?: true
    imageId?: true
    fileId?: true
    _all?: true
  }

  export type HistoriAggregateArgs = {
    /**
     * Filter which Histori to aggregate.
     */
    where?: HistoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historis to fetch.
     */
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Historis
    **/
    _count?: true | HistoriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoriAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoriSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoriMaxAggregateInputType
  }

  export type GetHistoriAggregateType<T extends HistoriAggregateArgs> = {
        [P in keyof T & keyof AggregateHistori]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistori[P]>
      : GetScalarType<T[P], AggregateHistori[P]>
  }




  export type HistoriGroupByArgs = {
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithAggregationInput>
    by: HistoriScalarFieldEnum[]
    having?: HistoriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoriCountAggregateInputType | true
    _avg?: HistoriAvgAggregateInputType
    _sum?: HistoriSumAggregateInputType
    _min?: HistoriMinAggregateInputType
    _max?: HistoriMaxAggregateInputType
  }


  export type HistoriGroupByOutputType = {
    id: string
    type: HistoriType
    model: HistoriModel
    step: number | null
    message: string | null
    refId: string
    createdAt: Date
    userId: string | null
    companyId: string | null
    optionId: string | null
    unitId: string | null
    itemId: string | null
    workId: string | null
    workItemsId: string | null
    templateId: string | null
    imageId: string | null
    fileId: string | null
    _count: HistoriCountAggregateOutputType | null
    _avg: HistoriAvgAggregateOutputType | null
    _sum: HistoriSumAggregateOutputType | null
    _min: HistoriMinAggregateOutputType | null
    _max: HistoriMaxAggregateOutputType | null
  }

  type GetHistoriGroupByPayload<T extends HistoriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<HistoriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoriGroupByOutputType[P]>
            : GetScalarType<T[P], HistoriGroupByOutputType[P]>
        }
      >
    >


  export type HistoriSelect = {
    id?: boolean
    type?: boolean
    model?: boolean
    step?: boolean
    message?: boolean
    refId?: boolean
    createdAt?: boolean
    userId?: boolean
    companyId?: boolean
    optionId?: boolean
    unitId?: boolean
    itemId?: boolean
    workId?: boolean
    workItemsId?: boolean
    templateId?: boolean
    imageId?: boolean
    fileId?: boolean
    ref?: boolean | UserArgs
    user?: boolean | UserArgs
    company?: boolean | CompanyArgs
    option?: boolean | OptionArgs
    unit?: boolean | UnitArgs
    item?: boolean | ItemArgs
    work?: boolean | WorkArgs
    workItems?: boolean | WorkItemsArgs
    template?: boolean | TemplateArgs
    image?: boolean | ImageArgs
    file?: boolean | FileArgs
  }


  export type HistoriInclude = {
    ref?: boolean | UserArgs
    user?: boolean | UserArgs
    company?: boolean | CompanyArgs
    option?: boolean | OptionArgs
    unit?: boolean | UnitArgs
    item?: boolean | ItemArgs
    work?: boolean | WorkArgs
    workItems?: boolean | WorkItemsArgs
    template?: boolean | TemplateArgs
    image?: boolean | ImageArgs
    file?: boolean | FileArgs
  }

  export type HistoriGetPayload<S extends boolean | null | undefined | HistoriArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Histori :
    S extends undefined ? never :
    S extends { include: any } & (HistoriArgs | HistoriFindManyArgs)
    ? Histori  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? UserGetPayload<S['include'][P]> :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'company' ? CompanyGetPayload<S['include'][P]> | null :
        P extends 'option' ? OptionGetPayload<S['include'][P]> | null :
        P extends 'unit' ? UnitGetPayload<S['include'][P]> | null :
        P extends 'item' ? ItemGetPayload<S['include'][P]> | null :
        P extends 'work' ? WorkGetPayload<S['include'][P]> | null :
        P extends 'workItems' ? WorkItemsGetPayload<S['include'][P]> | null :
        P extends 'template' ? TemplateGetPayload<S['include'][P]> | null :
        P extends 'image' ? ImageGetPayload<S['include'][P]> | null :
        P extends 'file' ? FileGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (HistoriArgs | HistoriFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'ref' ? UserGetPayload<S['select'][P]> :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'company' ? CompanyGetPayload<S['select'][P]> | null :
        P extends 'option' ? OptionGetPayload<S['select'][P]> | null :
        P extends 'unit' ? UnitGetPayload<S['select'][P]> | null :
        P extends 'item' ? ItemGetPayload<S['select'][P]> | null :
        P extends 'work' ? WorkGetPayload<S['select'][P]> | null :
        P extends 'workItems' ? WorkItemsGetPayload<S['select'][P]> | null :
        P extends 'template' ? TemplateGetPayload<S['select'][P]> | null :
        P extends 'image' ? ImageGetPayload<S['select'][P]> | null :
        P extends 'file' ? FileGetPayload<S['select'][P]> | null :  P extends keyof Histori ? Histori[P] : never
  } 
      : Histori


  type HistoriCountArgs = 
    Omit<HistoriFindManyArgs, 'select' | 'include'> & {
      select?: HistoriCountAggregateInputType | true
    }

  export interface HistoriDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Histori that matches the filter.
     * @param {HistoriFindUniqueArgs} args - Arguments to find a Histori
     * @example
     * // Get one Histori
     * const histori = await prisma.histori.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistoriFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, HistoriFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Histori'> extends True ? Prisma__HistoriClient<HistoriGetPayload<T>> : Prisma__HistoriClient<HistoriGetPayload<T> | null, null>

    /**
     * Find one Histori that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistoriFindUniqueOrThrowArgs} args - Arguments to find a Histori
     * @example
     * // Get one Histori
     * const histori = await prisma.histori.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistoriFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, HistoriFindUniqueOrThrowArgs>
    ): Prisma__HistoriClient<HistoriGetPayload<T>>

    /**
     * Find the first Histori that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriFindFirstArgs} args - Arguments to find a Histori
     * @example
     * // Get one Histori
     * const histori = await prisma.histori.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistoriFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, HistoriFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Histori'> extends True ? Prisma__HistoriClient<HistoriGetPayload<T>> : Prisma__HistoriClient<HistoriGetPayload<T> | null, null>

    /**
     * Find the first Histori that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriFindFirstOrThrowArgs} args - Arguments to find a Histori
     * @example
     * // Get one Histori
     * const histori = await prisma.histori.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistoriFindFirstOrThrowArgs>(
      args?: SelectSubset<T, HistoriFindFirstOrThrowArgs>
    ): Prisma__HistoriClient<HistoriGetPayload<T>>

    /**
     * Find zero or more Historis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Historis
     * const historis = await prisma.histori.findMany()
     * 
     * // Get first 10 Historis
     * const historis = await prisma.histori.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historiWithIdOnly = await prisma.histori.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HistoriFindManyArgs>(
      args?: SelectSubset<T, HistoriFindManyArgs>
    ): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>>

    /**
     * Create a Histori.
     * @param {HistoriCreateArgs} args - Arguments to create a Histori.
     * @example
     * // Create one Histori
     * const Histori = await prisma.histori.create({
     *   data: {
     *     // ... data to create a Histori
     *   }
     * })
     * 
    **/
    create<T extends HistoriCreateArgs>(
      args: SelectSubset<T, HistoriCreateArgs>
    ): Prisma__HistoriClient<HistoriGetPayload<T>>

    /**
     * Create many Historis.
     *     @param {HistoriCreateManyArgs} args - Arguments to create many Historis.
     *     @example
     *     // Create many Historis
     *     const histori = await prisma.histori.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistoriCreateManyArgs>(
      args?: SelectSubset<T, HistoriCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Histori.
     * @param {HistoriDeleteArgs} args - Arguments to delete one Histori.
     * @example
     * // Delete one Histori
     * const Histori = await prisma.histori.delete({
     *   where: {
     *     // ... filter to delete one Histori
     *   }
     * })
     * 
    **/
    delete<T extends HistoriDeleteArgs>(
      args: SelectSubset<T, HistoriDeleteArgs>
    ): Prisma__HistoriClient<HistoriGetPayload<T>>

    /**
     * Update one Histori.
     * @param {HistoriUpdateArgs} args - Arguments to update one Histori.
     * @example
     * // Update one Histori
     * const histori = await prisma.histori.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistoriUpdateArgs>(
      args: SelectSubset<T, HistoriUpdateArgs>
    ): Prisma__HistoriClient<HistoriGetPayload<T>>

    /**
     * Delete zero or more Historis.
     * @param {HistoriDeleteManyArgs} args - Arguments to filter Historis to delete.
     * @example
     * // Delete a few Historis
     * const { count } = await prisma.histori.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistoriDeleteManyArgs>(
      args?: SelectSubset<T, HistoriDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Historis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Historis
     * const histori = await prisma.histori.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistoriUpdateManyArgs>(
      args: SelectSubset<T, HistoriUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Histori.
     * @param {HistoriUpsertArgs} args - Arguments to update or create a Histori.
     * @example
     * // Update or create a Histori
     * const histori = await prisma.histori.upsert({
     *   create: {
     *     // ... data to create a Histori
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Histori we want to update
     *   }
     * })
    **/
    upsert<T extends HistoriUpsertArgs>(
      args: SelectSubset<T, HistoriUpsertArgs>
    ): Prisma__HistoriClient<HistoriGetPayload<T>>

    /**
     * Find zero or more Historis that matches the filter.
     * @param {HistoriFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const histori = await prisma.histori.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: HistoriFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Histori.
     * @param {HistoriAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const histori = await prisma.histori.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: HistoriAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Historis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriCountArgs} args - Arguments to filter Historis to count.
     * @example
     * // Count the number of Historis
     * const count = await prisma.histori.count({
     *   where: {
     *     // ... the filter for the Historis we want to count
     *   }
     * })
    **/
    count<T extends HistoriCountArgs>(
      args?: Subset<T, HistoriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Histori.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoriAggregateArgs>(args: Subset<T, HistoriAggregateArgs>): Prisma.PrismaPromise<GetHistoriAggregateType<T>>

    /**
     * Group by Histori.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoriGroupByArgs['orderBy'] }
        : { orderBy?: HistoriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Histori.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__HistoriClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    ref<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    option<T extends OptionArgs= {}>(args?: Subset<T, OptionArgs>): Prisma__OptionClient<OptionGetPayload<T> | Null>;

    unit<T extends UnitArgs= {}>(args?: Subset<T, UnitArgs>): Prisma__UnitClient<UnitGetPayload<T> | Null>;

    item<T extends ItemArgs= {}>(args?: Subset<T, ItemArgs>): Prisma__ItemClient<ItemGetPayload<T> | Null>;

    work<T extends WorkArgs= {}>(args?: Subset<T, WorkArgs>): Prisma__WorkClient<WorkGetPayload<T> | Null>;

    workItems<T extends WorkItemsArgs= {}>(args?: Subset<T, WorkItemsArgs>): Prisma__WorkItemsClient<WorkItemsGetPayload<T> | Null>;

    template<T extends TemplateArgs= {}>(args?: Subset<T, TemplateArgs>): Prisma__TemplateClient<TemplateGetPayload<T> | Null>;

    image<T extends ImageArgs= {}>(args?: Subset<T, ImageArgs>): Prisma__ImageClient<ImageGetPayload<T> | Null>;

    file<T extends FileArgs= {}>(args?: Subset<T, FileArgs>): Prisma__FileClient<FileGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Histori base type for findUnique actions
   */
  export type HistoriFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * Filter, which Histori to fetch.
     */
    where: HistoriWhereUniqueInput
  }

  /**
   * Histori findUnique
   */
  export interface HistoriFindUniqueArgs extends HistoriFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Histori findUniqueOrThrow
   */
  export type HistoriFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * Filter, which Histori to fetch.
     */
    where: HistoriWhereUniqueInput
  }


  /**
   * Histori base type for findFirst actions
   */
  export type HistoriFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * Filter, which Histori to fetch.
     */
    where?: HistoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historis to fetch.
     */
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historis.
     */
    cursor?: HistoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historis.
     */
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }

  /**
   * Histori findFirst
   */
  export interface HistoriFindFirstArgs extends HistoriFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Histori findFirstOrThrow
   */
  export type HistoriFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * Filter, which Histori to fetch.
     */
    where?: HistoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historis to fetch.
     */
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Historis.
     */
    cursor?: HistoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Historis.
     */
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Histori findMany
   */
  export type HistoriFindManyArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * Filter, which Historis to fetch.
     */
    where?: HistoriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Historis to fetch.
     */
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Historis.
     */
    cursor?: HistoriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Historis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Historis.
     */
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Histori create
   */
  export type HistoriCreateArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * The data needed to create a Histori.
     */
    data: XOR<HistoriCreateInput, HistoriUncheckedCreateInput>
  }


  /**
   * Histori createMany
   */
  export type HistoriCreateManyArgs = {
    /**
     * The data used to create many Historis.
     */
    data: Enumerable<HistoriCreateManyInput>
  }


  /**
   * Histori update
   */
  export type HistoriUpdateArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * The data needed to update a Histori.
     */
    data: XOR<HistoriUpdateInput, HistoriUncheckedUpdateInput>
    /**
     * Choose, which Histori to update.
     */
    where: HistoriWhereUniqueInput
  }


  /**
   * Histori updateMany
   */
  export type HistoriUpdateManyArgs = {
    /**
     * The data used to update Historis.
     */
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyInput>
    /**
     * Filter which Historis to update
     */
    where?: HistoriWhereInput
  }


  /**
   * Histori upsert
   */
  export type HistoriUpsertArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * The filter to search for the Histori to update in case it exists.
     */
    where: HistoriWhereUniqueInput
    /**
     * In case the Histori found by the `where` argument doesn't exist, create a new Histori with this data.
     */
    create: XOR<HistoriCreateInput, HistoriUncheckedCreateInput>
    /**
     * In case the Histori was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoriUpdateInput, HistoriUncheckedUpdateInput>
  }


  /**
   * Histori delete
   */
  export type HistoriDeleteArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    /**
     * Filter which Histori to delete.
     */
    where: HistoriWhereUniqueInput
  }


  /**
   * Histori deleteMany
   */
  export type HistoriDeleteManyArgs = {
    /**
     * Filter which Historis to delete
     */
    where?: HistoriWhereInput
  }


  /**
   * Histori findRaw
   */
  export type HistoriFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Histori aggregateRaw
   */
  export type HistoriAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Histori without action
   */
  export type HistoriArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
  }



  /**
   * Model Device
   */


  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    model: string | null
    manufacturer: string | null
    userId: string | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    model: string | null
    manufacturer: string | null
    userId: string | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    uuid: number
    model: number
    manufacturer: number
    userId: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    uuid?: true
    model?: true
    manufacturer?: true
    userId?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    uuid?: true
    model?: true
    manufacturer?: true
    userId?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    uuid?: true
    model?: true
    manufacturer?: true
    userId?: true
    _all?: true
  }

  export type DeviceAggregateArgs = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs = {
    where?: DeviceWhereInput
    orderBy?: Enumerable<DeviceOrderByWithAggregationInput>
    by: DeviceScalarFieldEnum[]
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }


  export type DeviceGroupByOutputType = {
    id: string
    uuid: string
    model: string
    manufacturer: string
    userId: string
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect = {
    id?: boolean
    uuid?: boolean
    model?: boolean
    manufacturer?: boolean
    userId?: boolean
    user?: boolean | UserArgs
  }


  export type DeviceInclude = {
    user?: boolean | UserArgs
  }

  export type DeviceGetPayload<S extends boolean | null | undefined | DeviceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Device :
    S extends undefined ? never :
    S extends { include: any } & (DeviceArgs | DeviceFindManyArgs)
    ? Device  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? UserGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DeviceArgs | DeviceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? UserGetPayload<S['select'][P]> :  P extends keyof Device ? Device[P] : never
  } 
      : Device


  type DeviceCountArgs = 
    Omit<DeviceFindManyArgs, 'select' | 'include'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeviceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeviceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Device'> extends True ? Prisma__DeviceClient<DeviceGetPayload<T>> : Prisma__DeviceClient<DeviceGetPayload<T> | null, null>

    /**
     * Find one Device that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeviceFindUniqueOrThrowArgs>
    ): Prisma__DeviceClient<DeviceGetPayload<T>>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeviceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeviceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Device'> extends True ? Prisma__DeviceClient<DeviceGetPayload<T>> : Prisma__DeviceClient<DeviceGetPayload<T> | null, null>

    /**
     * Find the first Device that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeviceFindFirstOrThrowArgs>
    ): Prisma__DeviceClient<DeviceGetPayload<T>>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeviceFindManyArgs>(
      args?: SelectSubset<T, DeviceFindManyArgs>
    ): Prisma.PrismaPromise<Array<DeviceGetPayload<T>>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
    **/
    create<T extends DeviceCreateArgs>(
      args: SelectSubset<T, DeviceCreateArgs>
    ): Prisma__DeviceClient<DeviceGetPayload<T>>

    /**
     * Create many Devices.
     *     @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     *     @example
     *     // Create many Devices
     *     const device = await prisma.device.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeviceCreateManyArgs>(
      args?: SelectSubset<T, DeviceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
    **/
    delete<T extends DeviceDeleteArgs>(
      args: SelectSubset<T, DeviceDeleteArgs>
    ): Prisma__DeviceClient<DeviceGetPayload<T>>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeviceUpdateArgs>(
      args: SelectSubset<T, DeviceUpdateArgs>
    ): Prisma__DeviceClient<DeviceGetPayload<T>>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeviceDeleteManyArgs>(
      args?: SelectSubset<T, DeviceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeviceUpdateManyArgs>(
      args: SelectSubset<T, DeviceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
    **/
    upsert<T extends DeviceUpsertArgs>(
      args: SelectSubset<T, DeviceUpsertArgs>
    ): Prisma__DeviceClient<DeviceGetPayload<T>>

    /**
     * Find zero or more Devices that matches the filter.
     * @param {DeviceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const device = await prisma.device.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DeviceFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Device.
     * @param {DeviceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const device = await prisma.device.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DeviceAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeviceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Device base type for findUnique actions
   */
  export type DeviceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUnique
   */
  export interface DeviceFindUniqueArgs extends DeviceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }


  /**
   * Device base type for findFirst actions
   */
  export type DeviceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }

  /**
   * Device findFirst
   */
  export interface DeviceFindFirstArgs extends DeviceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }


  /**
   * Device findMany
   */
  export type DeviceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }


  /**
   * Device create
   */
  export type DeviceCreateArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }


  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs = {
    /**
     * The data used to create many Devices.
     */
    data: Enumerable<DeviceCreateManyInput>
  }


  /**
   * Device update
   */
  export type DeviceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }


  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
  }


  /**
   * Device upsert
   */
  export type DeviceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }


  /**
   * Device delete
   */
  export type DeviceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }


  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
  }


  /**
   * Device findRaw
   */
  export type DeviceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Device aggregateRaw
   */
  export type DeviceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Device without action
   */
  export type DeviceArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
  }



  /**
   * Model Company
   */


  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    limit: number | null
  }

  export type CompanySumAggregateOutputType = {
    limit: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    gid: string | null
    name: string | null
    limit: number | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    gid: string | null
    name: string | null
    limit: number | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    gid: number
    name: number
    limit: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    limit?: true
  }

  export type CompanySumAggregateInputType = {
    limit?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    gid?: true
    name?: true
    limit?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    gid?: true
    name?: true
    limit?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    gid?: true
    name?: true
    limit?: true
    _all?: true
  }

  export type CompanyAggregateArgs = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs = {
    where?: CompanyWhereInput
    orderBy?: Enumerable<CompanyOrderByWithAggregationInput>
    by: CompanyScalarFieldEnum[]
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }


  export type CompanyGroupByOutputType = {
    id: string
    gid: string | null
    name: string
    limit: number
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect = {
    id?: boolean
    gid?: boolean
    name?: boolean
    address?: boolean | AddressArgs
    phone?: boolean | TPhoneArgs
    limit?: boolean
    users?: boolean | Company$usersArgs
    historis?: boolean | Company$historisArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }


  export type CompanyInclude = {
    users?: boolean | Company$usersArgs
    historis?: boolean | Company$historisArgs
    _count?: boolean | CompanyCountOutputTypeArgs
  }

  export type CompanyGetPayload<S extends boolean | null | undefined | CompanyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Company :
    S extends undefined ? never :
    S extends { include: any } & (CompanyArgs | CompanyFindManyArgs)
    ? Company  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'users' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CompanyArgs | CompanyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'address' ? AddressGetPayload<S['select'][P]> :
        P extends 'phone' ? TPhoneGetPayload<S['select'][P]> | null :
        P extends 'users' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends '_count' ? CompanyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Company ? Company[P] : never
  } 
      : Company


  type CompanyCountArgs = 
    Omit<CompanyFindManyArgs, 'select' | 'include'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CompanyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CompanyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Company'> extends True ? Prisma__CompanyClient<CompanyGetPayload<T>> : Prisma__CompanyClient<CompanyGetPayload<T> | null, null>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindUniqueOrThrowArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CompanyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CompanyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Company'> extends True ? Prisma__CompanyClient<CompanyGetPayload<T>> : Prisma__CompanyClient<CompanyGetPayload<T> | null, null>

    /**
     * Find the first Company that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CompanyFindFirstOrThrowArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CompanyFindManyArgs>(
      args?: SelectSubset<T, CompanyFindManyArgs>
    ): Prisma.PrismaPromise<Array<CompanyGetPayload<T>>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends CompanyCreateArgs>(
      args: SelectSubset<T, CompanyCreateArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Create many Companies.
     *     @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CompanyCreateManyArgs>(
      args?: SelectSubset<T, CompanyCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends CompanyDeleteArgs>(
      args: SelectSubset<T, CompanyDeleteArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CompanyUpdateArgs>(
      args: SelectSubset<T, CompanyUpdateArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CompanyDeleteManyArgs>(
      args?: SelectSubset<T, CompanyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CompanyUpdateManyArgs>(
      args: SelectSubset<T, CompanyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends CompanyUpsertArgs>(
      args: SelectSubset<T, CompanyUpsertArgs>
    ): Prisma__CompanyClient<CompanyGetPayload<T>>

    /**
     * Find zero or more Companies that matches the filter.
     * @param {CompanyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const company = await prisma.company.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CompanyFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Company.
     * @param {CompanyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const company = await prisma.company.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CompanyAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CompanyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    address<T extends AddressArgs= {}>(args?: Subset<T, AddressArgs>): Prisma__AddressClient<AddressGetPayload<T> | Null>;

    phone<T extends TPhoneArgs= {}>(args?: Subset<T, TPhoneArgs>): Prisma__TPhoneClient<TPhoneGetPayload<T> | Null>;

    users<T extends Company$usersArgs= {}>(args?: Subset<T, Company$usersArgs>): Prisma.PrismaPromise<Array<UserGetPayload<T>>| Null>;

    historis<T extends Company$historisArgs= {}>(args?: Subset<T, Company$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Company base type for findUnique actions
   */
  export type CompanyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUnique
   */
  export interface CompanyFindUniqueArgs extends CompanyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company base type for findFirst actions
   */
  export type CompanyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }

  /**
   * Company findFirst
   */
  export interface CompanyFindFirstArgs extends CompanyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company findMany
   */
  export type CompanyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: Enumerable<CompanyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: Enumerable<CompanyScalarFieldEnum>
  }


  /**
   * Company create
   */
  export type CompanyCreateArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }


  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs = {
    /**
     * The data used to create many Companies.
     */
    data: Enumerable<CompanyCreateManyInput>
  }


  /**
   * Company update
   */
  export type CompanyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
  }


  /**
   * Company upsert
   */
  export type CompanyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }


  /**
   * Company delete
   */
  export type CompanyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }


  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
  }


  /**
   * Company findRaw
   */
  export type CompanyFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Company aggregateRaw
   */
  export type CompanyAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Company.users
   */
  export type Company$usersArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * Company.historis
   */
  export type Company$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Company without action
   */
  export type CompanyArgs = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CompanyInclude | null
  }



  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    username: string | null
    password: string | null
    passhash: string | null
    role: UserRole | null
    active: boolean | null
    companyId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    username: string | null
    password: string | null
    passhash: string | null
    role: UserRole | null
    active: boolean | null
    companyId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    username: number
    password: number
    passhash: number
    role: number
    active: number
    companyId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    passhash?: true
    role?: true
    active?: true
    companyId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    passhash?: true
    role?: true
    active?: true
    companyId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    username?: true
    password?: true
    passhash?: true
    role?: true
    active?: true
    companyId?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    companyId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    name?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    passhash?: boolean
    role?: boolean
    active?: boolean
    companyId?: boolean
    company?: boolean | CompanyArgs
    trackers?: boolean | User$trackersArgs
    historis?: boolean | User$historisArgs
    devices?: boolean | User$devicesArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    company?: boolean | CompanyArgs
    trackers?: boolean | User$trackersArgs
    historis?: boolean | User$historisArgs
    devices?: boolean | User$devicesArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'company' ? CompanyGetPayload<S['include'][P]> | null :
        P extends 'trackers' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends 'devices' ? Array < DeviceGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'company' ? CompanyGetPayload<S['select'][P]> | null :
        P extends 'trackers' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends 'devices' ? Array < DeviceGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    company<T extends CompanyArgs= {}>(args?: Subset<T, CompanyArgs>): Prisma__CompanyClient<CompanyGetPayload<T> | Null>;

    trackers<T extends User$trackersArgs= {}>(args?: Subset<T, User$trackersArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    historis<T extends User$historisArgs= {}>(args?: Subset<T, User$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    devices<T extends User$devicesArgs= {}>(args?: Subset<T, User$devicesArgs>): Prisma.PrismaPromise<Array<DeviceGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User.trackers
   */
  export type User$trackersArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * User.historis
   */
  export type User$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * User.devices
   */
  export type User$devicesArgs = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeviceInclude | null
    where?: DeviceWhereInput
    orderBy?: Enumerable<DeviceOrderByWithRelationInput>
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DeviceScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model File
   */


  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    size: number | null
    width: number | null
    height: number | null
    type: string | null
    groupId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    size: number | null
    width: number | null
    height: number | null
    type: string | null
    groupId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    name: number
    url: number
    size: number
    width: number
    height: number
    type: number
    groupId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    size?: true
    width?: true
    height?: true
    type?: true
    groupId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    size?: true
    width?: true
    height?: true
    type?: true
    groupId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    size?: true
    width?: true
    height?: true
    type?: true
    groupId?: true
    _all?: true
  }

  export type FileAggregateArgs = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs = {
    where?: FileWhereInput
    orderBy?: Enumerable<FileOrderByWithAggregationInput>
    by: FileScalarFieldEnum[]
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }


  export type FileGroupByOutputType = {
    id: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    groupId: string
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect = {
    id?: boolean
    name?: boolean
    url?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    type?: boolean
    groupId?: boolean
    group?: boolean | ImageArgs
    historis?: boolean | File$historisArgs
    fields?: boolean | File$fieldsArgs
    _count?: boolean | FileCountOutputTypeArgs
  }


  export type FileInclude = {
    group?: boolean | ImageArgs
    historis?: boolean | File$historisArgs
    fields?: boolean | File$fieldsArgs
    _count?: boolean | FileCountOutputTypeArgs
  }

  export type FileGetPayload<S extends boolean | null | undefined | FileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? File :
    S extends undefined ? never :
    S extends { include: any } & (FileArgs | FileFindManyArgs)
    ? File  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'group' ? ImageGetPayload<S['include'][P]> :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends 'fields' ? Array < TemplateFieldGetPayload<S['include'][P]>>  :
        P extends '_count' ? FileCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FileArgs | FileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'group' ? ImageGetPayload<S['select'][P]> :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends 'fields' ? Array < TemplateFieldGetPayload<S['select'][P]>>  :
        P extends '_count' ? FileCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof File ? File[P] : never
  } 
      : File


  type FileCountArgs = 
    Omit<FileFindManyArgs, 'select' | 'include'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'File'> extends True ? Prisma__FileClient<FileGetPayload<T>> : Prisma__FileClient<FileGetPayload<T> | null, null>

    /**
     * Find one File that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FileFindUniqueOrThrowArgs>
    ): Prisma__FileClient<FileGetPayload<T>>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'File'> extends True ? Prisma__FileClient<FileGetPayload<T>> : Prisma__FileClient<FileGetPayload<T> | null, null>

    /**
     * Find the first File that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FileFindFirstOrThrowArgs>
    ): Prisma__FileClient<FileGetPayload<T>>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FileFindManyArgs>(
      args?: SelectSubset<T, FileFindManyArgs>
    ): Prisma.PrismaPromise<Array<FileGetPayload<T>>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
    **/
    create<T extends FileCreateArgs>(
      args: SelectSubset<T, FileCreateArgs>
    ): Prisma__FileClient<FileGetPayload<T>>

    /**
     * Create many Files.
     *     @param {FileCreateManyArgs} args - Arguments to create many Files.
     *     @example
     *     // Create many Files
     *     const file = await prisma.file.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FileCreateManyArgs>(
      args?: SelectSubset<T, FileCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
    **/
    delete<T extends FileDeleteArgs>(
      args: SelectSubset<T, FileDeleteArgs>
    ): Prisma__FileClient<FileGetPayload<T>>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FileUpdateArgs>(
      args: SelectSubset<T, FileUpdateArgs>
    ): Prisma__FileClient<FileGetPayload<T>>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FileDeleteManyArgs>(
      args?: SelectSubset<T, FileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FileUpdateManyArgs>(
      args: SelectSubset<T, FileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
    **/
    upsert<T extends FileUpsertArgs>(
      args: SelectSubset<T, FileUpsertArgs>
    ): Prisma__FileClient<FileGetPayload<T>>

    /**
     * Find zero or more Files that matches the filter.
     * @param {FileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const file = await prisma.file.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FileFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a File.
     * @param {FileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const file = await prisma.file.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FileAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    group<T extends ImageArgs= {}>(args?: Subset<T, ImageArgs>): Prisma__ImageClient<ImageGetPayload<T> | Null>;

    historis<T extends File$historisArgs= {}>(args?: Subset<T, File$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    fields<T extends File$fieldsArgs= {}>(args?: Subset<T, File$fieldsArgs>): Prisma.PrismaPromise<Array<TemplateFieldGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * File base type for findUnique actions
   */
  export type FileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUnique
   */
  export interface FileFindUniqueArgs extends FileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File base type for findFirst actions
   */
  export type FileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: Enumerable<FileScalarFieldEnum>
  }

  /**
   * File findFirst
   */
  export interface FileFindFirstArgs extends FileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * File findMany
   */
  export type FileFindManyArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * File create
   */
  export type FileCreateArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }


  /**
   * File createMany
   */
  export type FileCreateManyArgs = {
    /**
     * The data used to create many Files.
     */
    data: Enumerable<FileCreateManyInput>
  }


  /**
   * File update
   */
  export type FileUpdateArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File updateMany
   */
  export type FileUpdateManyArgs = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
  }


  /**
   * File upsert
   */
  export type FileUpsertArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }


  /**
   * File delete
   */
  export type FileDeleteArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }


  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
  }


  /**
   * File findRaw
   */
  export type FileFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * File aggregateRaw
   */
  export type FileAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * File.historis
   */
  export type File$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * File.fields
   */
  export type File$fieldsArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    where?: TemplateFieldWhereInput
    orderBy?: Enumerable<TemplateFieldOrderByWithRelationInput>
    cursor?: TemplateFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateFieldScalarFieldEnum>
  }


  /**
   * File without action
   */
  export type FileArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
  }



  /**
   * Model Image
   */


  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ImageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ImageAggregateArgs = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs = {
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByWithAggregationInput>
    by: ImageScalarFieldEnum[]
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }


  export type ImageGroupByOutputType = {
    id: string
    name: string
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect = {
    id?: boolean
    name?: boolean
    files?: boolean | Image$filesArgs
    historis?: boolean | Image$historisArgs
    _count?: boolean | ImageCountOutputTypeArgs
  }


  export type ImageInclude = {
    files?: boolean | Image$filesArgs
    historis?: boolean | Image$historisArgs
    _count?: boolean | ImageCountOutputTypeArgs
  }

  export type ImageGetPayload<S extends boolean | null | undefined | ImageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Image :
    S extends undefined ? never :
    S extends { include: any } & (ImageArgs | ImageFindManyArgs)
    ? Image  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'files' ? Array < FileGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends '_count' ? ImageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ImageArgs | ImageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'files' ? Array < FileGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends '_count' ? ImageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Image ? Image[P] : never
  } 
      : Image


  type ImageCountArgs = 
    Omit<ImageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Image'> extends True ? Prisma__ImageClient<ImageGetPayload<T>> : Prisma__ImageClient<ImageGetPayload<T> | null, null>

    /**
     * Find one Image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ImageFindUniqueOrThrowArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Image'> extends True ? Prisma__ImageClient<ImageGetPayload<T>> : Prisma__ImageClient<ImageGetPayload<T> | null, null>

    /**
     * Find the first Image that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ImageFindFirstOrThrowArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs>(
      args?: SelectSubset<T, ImageFindManyArgs>
    ): Prisma.PrismaPromise<Array<ImageGetPayload<T>>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs>(
      args: SelectSubset<T, ImageCreateArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Create many Images.
     *     @param {ImageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageCreateManyArgs>(
      args?: SelectSubset<T, ImageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs>(
      args: SelectSubset<T, ImageDeleteArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs>(
      args: SelectSubset<T, ImageUpdateArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs>(
      args?: SelectSubset<T, ImageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs>(
      args: SelectSubset<T, ImageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs>(
      args: SelectSubset<T, ImageUpsertArgs>
    ): Prisma__ImageClient<ImageGetPayload<T>>

    /**
     * Find zero or more Images that matches the filter.
     * @param {ImageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const image = await prisma.image.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ImageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Image.
     * @param {ImageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const image = await prisma.image.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ImageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    files<T extends Image$filesArgs= {}>(args?: Subset<T, Image$filesArgs>): Prisma.PrismaPromise<Array<FileGetPayload<T>>| Null>;

    historis<T extends Image$historisArgs= {}>(args?: Subset<T, Image$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Image base type for findUnique actions
   */
  export type ImageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUnique
   */
  export interface ImageFindUniqueArgs extends ImageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image base type for findFirst actions
   */
  export type ImageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }

  /**
   * Image findFirst
   */
  export interface ImageFindFirstArgs extends ImageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image create
   */
  export type ImageCreateArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }


  /**
   * Image createMany
   */
  export type ImageCreateManyArgs = {
    /**
     * The data used to create many Images.
     */
    data: Enumerable<ImageCreateManyInput>
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }


  /**
   * Image findRaw
   */
  export type ImageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Image aggregateRaw
   */
  export type ImageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Image.files
   */
  export type Image$filesArgs = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FileInclude | null
    where?: FileWhereInput
    orderBy?: Enumerable<FileOrderByWithRelationInput>
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * Image.historis
   */
  export type Image$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Image without action
   */
  export type ImageArgs = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude | null
  }



  /**
   * Model Option
   */


  export type AggregateOption = {
    _count: OptionCountAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  export type OptionMinAggregateOutputType = {
    id: string | null
    type: OptionType | null
    code: string | null
    name: string | null
  }

  export type OptionMaxAggregateOutputType = {
    id: string | null
    type: OptionType | null
    code: string | null
    name: string | null
  }

  export type OptionCountAggregateOutputType = {
    id: number
    type: number
    code: number
    name: number
    _all: number
  }


  export type OptionMinAggregateInputType = {
    id?: true
    type?: true
    code?: true
    name?: true
  }

  export type OptionMaxAggregateInputType = {
    id?: true
    type?: true
    code?: true
    name?: true
  }

  export type OptionCountAggregateInputType = {
    id?: true
    type?: true
    code?: true
    name?: true
    _all?: true
  }

  export type OptionAggregateArgs = {
    /**
     * Filter which Option to aggregate.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Options
    **/
    _count?: true | OptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OptionMaxAggregateInputType
  }

  export type GetOptionAggregateType<T extends OptionAggregateArgs> = {
        [P in keyof T & keyof AggregateOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOption[P]>
      : GetScalarType<T[P], AggregateOption[P]>
  }




  export type OptionGroupByArgs = {
    where?: OptionWhereInput
    orderBy?: Enumerable<OptionOrderByWithAggregationInput>
    by: OptionScalarFieldEnum[]
    having?: OptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OptionCountAggregateInputType | true
    _min?: OptionMinAggregateInputType
    _max?: OptionMaxAggregateInputType
  }


  export type OptionGroupByOutputType = {
    id: string
    type: OptionType
    code: string | null
    name: string
    _count: OptionCountAggregateOutputType | null
    _min: OptionMinAggregateOutputType | null
    _max: OptionMaxAggregateOutputType | null
  }

  type GetOptionGroupByPayload<T extends OptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OptionGroupByOutputType[P]>
            : GetScalarType<T[P], OptionGroupByOutputType[P]>
        }
      >
    >


  export type OptionSelect = {
    id?: boolean
    type?: boolean
    code?: boolean
    name?: boolean
    itemCategorys?: boolean | Option$itemCategorysArgs
    itemTypes?: boolean | Option$itemTypesArgs
    workTypes?: boolean | Option$workTypesArgs
    historis?: boolean | Option$historisArgs
    _count?: boolean | OptionCountOutputTypeArgs
  }


  export type OptionInclude = {
    itemCategorys?: boolean | Option$itemCategorysArgs
    itemTypes?: boolean | Option$itemTypesArgs
    workTypes?: boolean | Option$workTypesArgs
    historis?: boolean | Option$historisArgs
    _count?: boolean | OptionCountOutputTypeArgs
  }

  export type OptionGetPayload<S extends boolean | null | undefined | OptionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Option :
    S extends undefined ? never :
    S extends { include: any } & (OptionArgs | OptionFindManyArgs)
    ? Option  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'itemCategorys' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends 'itemTypes' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends 'workTypes' ? Array < WorkGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends '_count' ? OptionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (OptionArgs | OptionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'itemCategorys' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends 'itemTypes' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends 'workTypes' ? Array < WorkGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends '_count' ? OptionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Option ? Option[P] : never
  } 
      : Option


  type OptionCountArgs = 
    Omit<OptionFindManyArgs, 'select' | 'include'> & {
      select?: OptionCountAggregateInputType | true
    }

  export interface OptionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Option that matches the filter.
     * @param {OptionFindUniqueArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OptionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OptionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Option'> extends True ? Prisma__OptionClient<OptionGetPayload<T>> : Prisma__OptionClient<OptionGetPayload<T> | null, null>

    /**
     * Find one Option that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OptionFindUniqueOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OptionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, OptionFindUniqueOrThrowArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Find the first Option that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OptionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OptionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Option'> extends True ? Prisma__OptionClient<OptionGetPayload<T>> : Prisma__OptionClient<OptionGetPayload<T> | null, null>

    /**
     * Find the first Option that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindFirstOrThrowArgs} args - Arguments to find a Option
     * @example
     * // Get one Option
     * const option = await prisma.option.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, OptionFindFirstOrThrowArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Find zero or more Options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Options
     * const options = await prisma.option.findMany()
     * 
     * // Get first 10 Options
     * const options = await prisma.option.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const optionWithIdOnly = await prisma.option.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OptionFindManyArgs>(
      args?: SelectSubset<T, OptionFindManyArgs>
    ): Prisma.PrismaPromise<Array<OptionGetPayload<T>>>

    /**
     * Create a Option.
     * @param {OptionCreateArgs} args - Arguments to create a Option.
     * @example
     * // Create one Option
     * const Option = await prisma.option.create({
     *   data: {
     *     // ... data to create a Option
     *   }
     * })
     * 
    **/
    create<T extends OptionCreateArgs>(
      args: SelectSubset<T, OptionCreateArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Create many Options.
     *     @param {OptionCreateManyArgs} args - Arguments to create many Options.
     *     @example
     *     // Create many Options
     *     const option = await prisma.option.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OptionCreateManyArgs>(
      args?: SelectSubset<T, OptionCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Option.
     * @param {OptionDeleteArgs} args - Arguments to delete one Option.
     * @example
     * // Delete one Option
     * const Option = await prisma.option.delete({
     *   where: {
     *     // ... filter to delete one Option
     *   }
     * })
     * 
    **/
    delete<T extends OptionDeleteArgs>(
      args: SelectSubset<T, OptionDeleteArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Update one Option.
     * @param {OptionUpdateArgs} args - Arguments to update one Option.
     * @example
     * // Update one Option
     * const option = await prisma.option.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OptionUpdateArgs>(
      args: SelectSubset<T, OptionUpdateArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Delete zero or more Options.
     * @param {OptionDeleteManyArgs} args - Arguments to filter Options to delete.
     * @example
     * // Delete a few Options
     * const { count } = await prisma.option.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OptionDeleteManyArgs>(
      args?: SelectSubset<T, OptionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Options
     * const option = await prisma.option.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OptionUpdateManyArgs>(
      args: SelectSubset<T, OptionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Option.
     * @param {OptionUpsertArgs} args - Arguments to update or create a Option.
     * @example
     * // Update or create a Option
     * const option = await prisma.option.upsert({
     *   create: {
     *     // ... data to create a Option
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Option we want to update
     *   }
     * })
    **/
    upsert<T extends OptionUpsertArgs>(
      args: SelectSubset<T, OptionUpsertArgs>
    ): Prisma__OptionClient<OptionGetPayload<T>>

    /**
     * Find zero or more Options that matches the filter.
     * @param {OptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const option = await prisma.option.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OptionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Option.
     * @param {OptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const option = await prisma.option.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OptionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionCountArgs} args - Arguments to filter Options to count.
     * @example
     * // Count the number of Options
     * const count = await prisma.option.count({
     *   where: {
     *     // ... the filter for the Options we want to count
     *   }
     * })
    **/
    count<T extends OptionCountArgs>(
      args?: Subset<T, OptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OptionAggregateArgs>(args: Subset<T, OptionAggregateArgs>): Prisma.PrismaPromise<GetOptionAggregateType<T>>

    /**
     * Group by Option.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OptionGroupByArgs['orderBy'] }
        : { orderBy?: OptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Option.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OptionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    itemCategorys<T extends Option$itemCategorysArgs= {}>(args?: Subset<T, Option$itemCategorysArgs>): Prisma.PrismaPromise<Array<ItemGetPayload<T>>| Null>;

    itemTypes<T extends Option$itemTypesArgs= {}>(args?: Subset<T, Option$itemTypesArgs>): Prisma.PrismaPromise<Array<ItemGetPayload<T>>| Null>;

    workTypes<T extends Option$workTypesArgs= {}>(args?: Subset<T, Option$workTypesArgs>): Prisma.PrismaPromise<Array<WorkGetPayload<T>>| Null>;

    historis<T extends Option$historisArgs= {}>(args?: Subset<T, Option$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Option base type for findUnique actions
   */
  export type OptionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }

  /**
   * Option findUnique
   */
  export interface OptionFindUniqueArgs extends OptionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Option findUniqueOrThrow
   */
  export type OptionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     */
    where: OptionWhereUniqueInput
  }


  /**
   * Option base type for findFirst actions
   */
  export type OptionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: Enumerable<OptionScalarFieldEnum>
  }

  /**
   * Option findFirst
   */
  export interface OptionFindFirstArgs extends OptionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Option findFirstOrThrow
   */
  export type OptionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * Filter, which Option to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Options.
     */
    distinct?: Enumerable<OptionScalarFieldEnum>
  }


  /**
   * Option findMany
   */
  export type OptionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * Filter, which Options to fetch.
     */
    where?: OptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Options to fetch.
     */
    orderBy?: Enumerable<OptionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Options.
     */
    cursor?: OptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Options.
     */
    skip?: number
    distinct?: Enumerable<OptionScalarFieldEnum>
  }


  /**
   * Option create
   */
  export type OptionCreateArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * The data needed to create a Option.
     */
    data: XOR<OptionCreateInput, OptionUncheckedCreateInput>
  }


  /**
   * Option createMany
   */
  export type OptionCreateManyArgs = {
    /**
     * The data used to create many Options.
     */
    data: Enumerable<OptionCreateManyInput>
  }


  /**
   * Option update
   */
  export type OptionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * The data needed to update a Option.
     */
    data: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
    /**
     * Choose, which Option to update.
     */
    where: OptionWhereUniqueInput
  }


  /**
   * Option updateMany
   */
  export type OptionUpdateManyArgs = {
    /**
     * The data used to update Options.
     */
    data: XOR<OptionUpdateManyMutationInput, OptionUncheckedUpdateManyInput>
    /**
     * Filter which Options to update
     */
    where?: OptionWhereInput
  }


  /**
   * Option upsert
   */
  export type OptionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * The filter to search for the Option to update in case it exists.
     */
    where: OptionWhereUniqueInput
    /**
     * In case the Option found by the `where` argument doesn't exist, create a new Option with this data.
     */
    create: XOR<OptionCreateInput, OptionUncheckedCreateInput>
    /**
     * In case the Option was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OptionUpdateInput, OptionUncheckedUpdateInput>
  }


  /**
   * Option delete
   */
  export type OptionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
    /**
     * Filter which Option to delete.
     */
    where: OptionWhereUniqueInput
  }


  /**
   * Option deleteMany
   */
  export type OptionDeleteManyArgs = {
    /**
     * Filter which Options to delete
     */
    where?: OptionWhereInput
  }


  /**
   * Option findRaw
   */
  export type OptionFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Option aggregateRaw
   */
  export type OptionAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Option.itemCategorys
   */
  export type Option$itemCategorysArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Option.itemTypes
   */
  export type Option$itemTypesArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Option.workTypes
   */
  export type Option$workTypesArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    where?: WorkWhereInput
    orderBy?: Enumerable<WorkOrderByWithRelationInput>
    cursor?: WorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkScalarFieldEnum>
  }


  /**
   * Option.historis
   */
  export type Option$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Option without action
   */
  export type OptionArgs = {
    /**
     * Select specific fields to fetch from the Option
     */
    select?: OptionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OptionInclude | null
  }



  /**
   * Model Unit
   */


  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type UnitMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type UnitAggregateArgs = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs = {
    where?: UnitWhereInput
    orderBy?: Enumerable<UnitOrderByWithAggregationInput>
    by: UnitScalarFieldEnum[]
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }


  export type UnitGroupByOutputType = {
    id: string
    name: string
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect = {
    id?: boolean
    name?: boolean
    items?: boolean | Unit$itemsArgs
    works?: boolean | Unit$worksArgs
    workItems?: boolean | Unit$workItemsArgs
    historis?: boolean | Unit$historisArgs
    tWorkItems?: boolean | Unit$tWorkItemsArgs
    _count?: boolean | UnitCountOutputTypeArgs
  }


  export type UnitInclude = {
    items?: boolean | Unit$itemsArgs
    works?: boolean | Unit$worksArgs
    workItems?: boolean | Unit$workItemsArgs
    historis?: boolean | Unit$historisArgs
    tWorkItems?: boolean | Unit$tWorkItemsArgs
    _count?: boolean | UnitCountOutputTypeArgs
  }

  export type UnitGetPayload<S extends boolean | null | undefined | UnitArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Unit :
    S extends undefined ? never :
    S extends { include: any } & (UnitArgs | UnitFindManyArgs)
    ? Unit  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'items' ? Array < ItemGetPayload<S['include'][P]>>  :
        P extends 'works' ? Array < WorkGetPayload<S['include'][P]>>  :
        P extends 'workItems' ? Array < WorkItemsGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends 'tWorkItems' ? Array < TemplateWorkItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? UnitCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UnitArgs | UnitFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'items' ? Array < ItemGetPayload<S['select'][P]>>  :
        P extends 'works' ? Array < WorkGetPayload<S['select'][P]>>  :
        P extends 'workItems' ? Array < WorkItemsGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends 'tWorkItems' ? Array < TemplateWorkItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? UnitCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Unit ? Unit[P] : never
  } 
      : Unit


  type UnitCountArgs = 
    Omit<UnitFindManyArgs, 'select' | 'include'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UnitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Unit'> extends True ? Prisma__UnitClient<UnitGetPayload<T>> : Prisma__UnitClient<UnitGetPayload<T> | null, null>

    /**
     * Find one Unit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UnitFindUniqueOrThrowArgs>
    ): Prisma__UnitClient<UnitGetPayload<T>>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UnitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Unit'> extends True ? Prisma__UnitClient<UnitGetPayload<T>> : Prisma__UnitClient<UnitGetPayload<T> | null, null>

    /**
     * Find the first Unit that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UnitFindFirstOrThrowArgs>
    ): Prisma__UnitClient<UnitGetPayload<T>>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitFindManyArgs>(
      args?: SelectSubset<T, UnitFindManyArgs>
    ): Prisma.PrismaPromise<Array<UnitGetPayload<T>>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
    **/
    create<T extends UnitCreateArgs>(
      args: SelectSubset<T, UnitCreateArgs>
    ): Prisma__UnitClient<UnitGetPayload<T>>

    /**
     * Create many Units.
     *     @param {UnitCreateManyArgs} args - Arguments to create many Units.
     *     @example
     *     // Create many Units
     *     const unit = await prisma.unit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitCreateManyArgs>(
      args?: SelectSubset<T, UnitCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
    **/
    delete<T extends UnitDeleteArgs>(
      args: SelectSubset<T, UnitDeleteArgs>
    ): Prisma__UnitClient<UnitGetPayload<T>>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitUpdateArgs>(
      args: SelectSubset<T, UnitUpdateArgs>
    ): Prisma__UnitClient<UnitGetPayload<T>>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitDeleteManyArgs>(
      args?: SelectSubset<T, UnitDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitUpdateManyArgs>(
      args: SelectSubset<T, UnitUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
    **/
    upsert<T extends UnitUpsertArgs>(
      args: SelectSubset<T, UnitUpsertArgs>
    ): Prisma__UnitClient<UnitGetPayload<T>>

    /**
     * Find zero or more Units that matches the filter.
     * @param {UnitFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const unit = await prisma.unit.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UnitFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Unit.
     * @param {UnitAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const unit = await prisma.unit.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UnitAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UnitClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    items<T extends Unit$itemsArgs= {}>(args?: Subset<T, Unit$itemsArgs>): Prisma.PrismaPromise<Array<ItemGetPayload<T>>| Null>;

    works<T extends Unit$worksArgs= {}>(args?: Subset<T, Unit$worksArgs>): Prisma.PrismaPromise<Array<WorkGetPayload<T>>| Null>;

    workItems<T extends Unit$workItemsArgs= {}>(args?: Subset<T, Unit$workItemsArgs>): Prisma.PrismaPromise<Array<WorkItemsGetPayload<T>>| Null>;

    historis<T extends Unit$historisArgs= {}>(args?: Subset<T, Unit$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    tWorkItems<T extends Unit$tWorkItemsArgs= {}>(args?: Subset<T, Unit$tWorkItemsArgs>): Prisma.PrismaPromise<Array<TemplateWorkItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Unit base type for findUnique actions
   */
  export type UnitFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUnique
   */
  export interface UnitFindUniqueArgs extends UnitFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit base type for findFirst actions
   */
  export type UnitFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: Enumerable<UnitScalarFieldEnum>
  }

  /**
   * Unit findFirst
   */
  export interface UnitFindFirstArgs extends UnitFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: Enumerable<UnitScalarFieldEnum>
  }


  /**
   * Unit findMany
   */
  export type UnitFindManyArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: Enumerable<UnitScalarFieldEnum>
  }


  /**
   * Unit create
   */
  export type UnitCreateArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }


  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs = {
    /**
     * The data used to create many Units.
     */
    data: Enumerable<UnitCreateManyInput>
  }


  /**
   * Unit update
   */
  export type UnitUpdateArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
  }


  /**
   * Unit upsert
   */
  export type UnitUpsertArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }


  /**
   * Unit delete
   */
  export type UnitDeleteArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }


  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
  }


  /**
   * Unit findRaw
   */
  export type UnitFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Unit aggregateRaw
   */
  export type UnitAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Unit.items
   */
  export type Unit$itemsArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Unit.works
   */
  export type Unit$worksArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    where?: WorkWhereInput
    orderBy?: Enumerable<WorkOrderByWithRelationInput>
    cursor?: WorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkScalarFieldEnum>
  }


  /**
   * Unit.workItems
   */
  export type Unit$workItemsArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    where?: WorkItemsWhereInput
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    cursor?: WorkItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkItemsScalarFieldEnum>
  }


  /**
   * Unit.historis
   */
  export type Unit$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Unit.tWorkItems
   */
  export type Unit$tWorkItemsArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    where?: TemplateWorkItemWhereInput
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    cursor?: TemplateWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateWorkItemScalarFieldEnum>
  }


  /**
   * Unit without action
   */
  export type UnitArgs = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitInclude | null
  }



  /**
   * Model Item
   */


  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    price: number | null
  }

  export type ItemSumAggregateOutputType = {
    price: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    model: ItemModel | null
    categoryId: string | null
    typeId: string | null
    unitId: string | null
    code: string | null
    name: string | null
    price: number | null
    trim: boolean | null
    active: boolean | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    model: ItemModel | null
    categoryId: string | null
    typeId: string | null
    unitId: string | null
    code: string | null
    name: string | null
    price: number | null
    trim: boolean | null
    active: boolean | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    model: number
    categoryId: number
    typeId: number
    unitId: number
    code: number
    name: number
    price: number
    trim: number
    active: number
    introIds: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    price?: true
  }

  export type ItemSumAggregateInputType = {
    price?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    model?: true
    categoryId?: true
    typeId?: true
    unitId?: true
    code?: true
    name?: true
    price?: true
    trim?: true
    active?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    model?: true
    categoryId?: true
    typeId?: true
    unitId?: true
    code?: true
    name?: true
    price?: true
    trim?: true
    active?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    model?: true
    categoryId?: true
    typeId?: true
    unitId?: true
    code?: true
    name?: true
    price?: true
    trim?: true
    active?: true
    introIds?: true
    _all?: true
  }

  export type ItemAggregateArgs = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs = {
    where?: ItemWhereInput
    orderBy?: Enumerable<ItemOrderByWithAggregationInput>
    by: ItemScalarFieldEnum[]
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }


  export type ItemGroupByOutputType = {
    id: string
    model: ItemModel
    categoryId: string
    typeId: string | null
    unitId: string
    code: string | null
    name: string | null
    price: number
    trim: boolean
    active: boolean
    introIds: string[]
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect = {
    id?: boolean
    model?: boolean
    categoryId?: boolean
    typeId?: boolean
    unitId?: boolean
    code?: boolean
    name?: boolean
    price?: boolean
    trim?: boolean
    active?: boolean
    introIds?: boolean
    category?: boolean | OptionArgs
    type?: boolean | OptionArgs
    unit?: boolean | UnitArgs
    works?: boolean | Item$worksArgs
    historis?: boolean | Item$historisArgs
    tWorks?: boolean | Item$tWorksArgs
    _count?: boolean | ItemCountOutputTypeArgs
  }


  export type ItemInclude = {
    category?: boolean | OptionArgs
    type?: boolean | OptionArgs
    unit?: boolean | UnitArgs
    works?: boolean | Item$worksArgs
    historis?: boolean | Item$historisArgs
    tWorks?: boolean | Item$tWorksArgs
    _count?: boolean | ItemCountOutputTypeArgs
  }

  export type ItemGetPayload<S extends boolean | null | undefined | ItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Item :
    S extends undefined ? never :
    S extends { include: any } & (ItemArgs | ItemFindManyArgs)
    ? Item  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'category' ? OptionGetPayload<S['include'][P]> :
        P extends 'type' ? OptionGetPayload<S['include'][P]> | null :
        P extends 'unit' ? UnitGetPayload<S['include'][P]> :
        P extends 'works' ? Array < WorkItemsGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends 'tWorks' ? Array < TemplateWorkItemGetPayload<S['include'][P]>>  :
        P extends '_count' ? ItemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ItemArgs | ItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'category' ? OptionGetPayload<S['select'][P]> :
        P extends 'type' ? OptionGetPayload<S['select'][P]> | null :
        P extends 'unit' ? UnitGetPayload<S['select'][P]> :
        P extends 'works' ? Array < WorkItemsGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends 'tWorks' ? Array < TemplateWorkItemGetPayload<S['select'][P]>>  :
        P extends '_count' ? ItemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Item ? Item[P] : never
  } 
      : Item


  type ItemCountArgs = 
    Omit<ItemFindManyArgs, 'select' | 'include'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Item'> extends True ? Prisma__ItemClient<ItemGetPayload<T>> : Prisma__ItemClient<ItemGetPayload<T> | null, null>

    /**
     * Find one Item that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ItemFindUniqueOrThrowArgs>
    ): Prisma__ItemClient<ItemGetPayload<T>>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Item'> extends True ? Prisma__ItemClient<ItemGetPayload<T>> : Prisma__ItemClient<ItemGetPayload<T> | null, null>

    /**
     * Find the first Item that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ItemFindFirstOrThrowArgs>
    ): Prisma__ItemClient<ItemGetPayload<T>>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemFindManyArgs>(
      args?: SelectSubset<T, ItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<ItemGetPayload<T>>>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
    **/
    create<T extends ItemCreateArgs>(
      args: SelectSubset<T, ItemCreateArgs>
    ): Prisma__ItemClient<ItemGetPayload<T>>

    /**
     * Create many Items.
     *     @param {ItemCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const item = await prisma.item.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemCreateManyArgs>(
      args?: SelectSubset<T, ItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
    **/
    delete<T extends ItemDeleteArgs>(
      args: SelectSubset<T, ItemDeleteArgs>
    ): Prisma__ItemClient<ItemGetPayload<T>>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemUpdateArgs>(
      args: SelectSubset<T, ItemUpdateArgs>
    ): Prisma__ItemClient<ItemGetPayload<T>>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemDeleteManyArgs>(
      args?: SelectSubset<T, ItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemUpdateManyArgs>(
      args: SelectSubset<T, ItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
    **/
    upsert<T extends ItemUpsertArgs>(
      args: SelectSubset<T, ItemUpsertArgs>
    ): Prisma__ItemClient<ItemGetPayload<T>>

    /**
     * Find zero or more Items that matches the filter.
     * @param {ItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const item = await prisma.item.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ItemFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Item.
     * @param {ItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const item = await prisma.item.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ItemAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    category<T extends OptionArgs= {}>(args?: Subset<T, OptionArgs>): Prisma__OptionClient<OptionGetPayload<T> | Null>;

    type<T extends OptionArgs= {}>(args?: Subset<T, OptionArgs>): Prisma__OptionClient<OptionGetPayload<T> | Null>;

    unit<T extends UnitArgs= {}>(args?: Subset<T, UnitArgs>): Prisma__UnitClient<UnitGetPayload<T> | Null>;

    works<T extends Item$worksArgs= {}>(args?: Subset<T, Item$worksArgs>): Prisma.PrismaPromise<Array<WorkItemsGetPayload<T>>| Null>;

    historis<T extends Item$historisArgs= {}>(args?: Subset<T, Item$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    tWorks<T extends Item$tWorksArgs= {}>(args?: Subset<T, Item$tWorksArgs>): Prisma.PrismaPromise<Array<TemplateWorkItemGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Item base type for findUnique actions
   */
  export type ItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUnique
   */
  export interface ItemFindUniqueArgs extends ItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item base type for findFirst actions
   */
  export type ItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: Enumerable<ItemScalarFieldEnum>
  }

  /**
   * Item findFirst
   */
  export interface ItemFindFirstArgs extends ItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item findMany
   */
  export type ItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: Enumerable<ItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: Enumerable<ItemScalarFieldEnum>
  }


  /**
   * Item create
   */
  export type ItemCreateArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }


  /**
   * Item createMany
   */
  export type ItemCreateManyArgs = {
    /**
     * The data used to create many Items.
     */
    data: Enumerable<ItemCreateManyInput>
  }


  /**
   * Item update
   */
  export type ItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }


  /**
   * Item upsert
   */
  export type ItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }


  /**
   * Item delete
   */
  export type ItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }


  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }


  /**
   * Item findRaw
   */
  export type ItemFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Item aggregateRaw
   */
  export type ItemAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Item.works
   */
  export type Item$worksArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    where?: WorkItemsWhereInput
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    cursor?: WorkItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkItemsScalarFieldEnum>
  }


  /**
   * Item.historis
   */
  export type Item$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Item.tWorks
   */
  export type Item$tWorksArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    where?: TemplateWorkItemWhereInput
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    cursor?: TemplateWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateWorkItemScalarFieldEnum>
  }


  /**
   * Item without action
   */
  export type ItemArgs = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemInclude | null
  }



  /**
   * Model Work
   */


  export type AggregateWork = {
    _count: WorkCountAggregateOutputType | null
    _min: WorkMinAggregateOutputType | null
    _max: WorkMaxAggregateOutputType | null
  }

  export type WorkMinAggregateOutputType = {
    id: string | null
    model: WorkModel | null
    code: string | null
    name: string | null
    active: boolean | null
    typeId: string | null
    unitId: string | null
  }

  export type WorkMaxAggregateOutputType = {
    id: string | null
    model: WorkModel | null
    code: string | null
    name: string | null
    active: boolean | null
    typeId: string | null
    unitId: string | null
  }

  export type WorkCountAggregateOutputType = {
    id: number
    model: number
    code: number
    name: number
    active: number
    typeId: number
    unitId: number
    _all: number
  }


  export type WorkMinAggregateInputType = {
    id?: true
    model?: true
    code?: true
    name?: true
    active?: true
    typeId?: true
    unitId?: true
  }

  export type WorkMaxAggregateInputType = {
    id?: true
    model?: true
    code?: true
    name?: true
    active?: true
    typeId?: true
    unitId?: true
  }

  export type WorkCountAggregateInputType = {
    id?: true
    model?: true
    code?: true
    name?: true
    active?: true
    typeId?: true
    unitId?: true
    _all?: true
  }

  export type WorkAggregateArgs = {
    /**
     * Filter which Work to aggregate.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: Enumerable<WorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Works
    **/
    _count?: true | WorkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkMaxAggregateInputType
  }

  export type GetWorkAggregateType<T extends WorkAggregateArgs> = {
        [P in keyof T & keyof AggregateWork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWork[P]>
      : GetScalarType<T[P], AggregateWork[P]>
  }




  export type WorkGroupByArgs = {
    where?: WorkWhereInput
    orderBy?: Enumerable<WorkOrderByWithAggregationInput>
    by: WorkScalarFieldEnum[]
    having?: WorkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkCountAggregateInputType | true
    _min?: WorkMinAggregateInputType
    _max?: WorkMaxAggregateInputType
  }


  export type WorkGroupByOutputType = {
    id: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    unitId: string
    _count: WorkCountAggregateOutputType | null
    _min: WorkMinAggregateOutputType | null
    _max: WorkMaxAggregateOutputType | null
  }

  type GetWorkGroupByPayload<T extends WorkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WorkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkGroupByOutputType[P]>
            : GetScalarType<T[P], WorkGroupByOutputType[P]>
        }
      >
    >


  export type WorkSelect = {
    id?: boolean
    model?: boolean
    code?: boolean
    name?: boolean
    active?: boolean
    typeId?: boolean
    unitId?: boolean
    type?: boolean | OptionArgs
    unit?: boolean | UnitArgs
    items?: boolean | Work$itemsArgs
    historis?: boolean | Work$historisArgs
    templates?: boolean | Work$templatesArgs
    _count?: boolean | WorkCountOutputTypeArgs
  }


  export type WorkInclude = {
    type?: boolean | OptionArgs
    unit?: boolean | UnitArgs
    items?: boolean | Work$itemsArgs
    historis?: boolean | Work$historisArgs
    templates?: boolean | Work$templatesArgs
    _count?: boolean | WorkCountOutputTypeArgs
  }

  export type WorkGetPayload<S extends boolean | null | undefined | WorkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Work :
    S extends undefined ? never :
    S extends { include: any } & (WorkArgs | WorkFindManyArgs)
    ? Work  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'type' ? OptionGetPayload<S['include'][P]> :
        P extends 'unit' ? UnitGetPayload<S['include'][P]> :
        P extends 'items' ? Array < WorkItemsGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends 'templates' ? Array < TemplateWorkGetPayload<S['include'][P]>>  :
        P extends '_count' ? WorkCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkArgs | WorkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'type' ? OptionGetPayload<S['select'][P]> :
        P extends 'unit' ? UnitGetPayload<S['select'][P]> :
        P extends 'items' ? Array < WorkItemsGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends 'templates' ? Array < TemplateWorkGetPayload<S['select'][P]>>  :
        P extends '_count' ? WorkCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Work ? Work[P] : never
  } 
      : Work


  type WorkCountArgs = 
    Omit<WorkFindManyArgs, 'select' | 'include'> & {
      select?: WorkCountAggregateInputType | true
    }

  export interface WorkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Work that matches the filter.
     * @param {WorkFindUniqueArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Work'> extends True ? Prisma__WorkClient<WorkGetPayload<T>> : Prisma__WorkClient<WorkGetPayload<T> | null, null>

    /**
     * Find one Work that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkFindUniqueOrThrowArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkFindUniqueOrThrowArgs>
    ): Prisma__WorkClient<WorkGetPayload<T>>

    /**
     * Find the first Work that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFindFirstArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Work'> extends True ? Prisma__WorkClient<WorkGetPayload<T>> : Prisma__WorkClient<WorkGetPayload<T> | null, null>

    /**
     * Find the first Work that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFindFirstOrThrowArgs} args - Arguments to find a Work
     * @example
     * // Get one Work
     * const work = await prisma.work.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkFindFirstOrThrowArgs>
    ): Prisma__WorkClient<WorkGetPayload<T>>

    /**
     * Find zero or more Works that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Works
     * const works = await prisma.work.findMany()
     * 
     * // Get first 10 Works
     * const works = await prisma.work.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workWithIdOnly = await prisma.work.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkFindManyArgs>(
      args?: SelectSubset<T, WorkFindManyArgs>
    ): Prisma.PrismaPromise<Array<WorkGetPayload<T>>>

    /**
     * Create a Work.
     * @param {WorkCreateArgs} args - Arguments to create a Work.
     * @example
     * // Create one Work
     * const Work = await prisma.work.create({
     *   data: {
     *     // ... data to create a Work
     *   }
     * })
     * 
    **/
    create<T extends WorkCreateArgs>(
      args: SelectSubset<T, WorkCreateArgs>
    ): Prisma__WorkClient<WorkGetPayload<T>>

    /**
     * Create many Works.
     *     @param {WorkCreateManyArgs} args - Arguments to create many Works.
     *     @example
     *     // Create many Works
     *     const work = await prisma.work.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkCreateManyArgs>(
      args?: SelectSubset<T, WorkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Work.
     * @param {WorkDeleteArgs} args - Arguments to delete one Work.
     * @example
     * // Delete one Work
     * const Work = await prisma.work.delete({
     *   where: {
     *     // ... filter to delete one Work
     *   }
     * })
     * 
    **/
    delete<T extends WorkDeleteArgs>(
      args: SelectSubset<T, WorkDeleteArgs>
    ): Prisma__WorkClient<WorkGetPayload<T>>

    /**
     * Update one Work.
     * @param {WorkUpdateArgs} args - Arguments to update one Work.
     * @example
     * // Update one Work
     * const work = await prisma.work.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkUpdateArgs>(
      args: SelectSubset<T, WorkUpdateArgs>
    ): Prisma__WorkClient<WorkGetPayload<T>>

    /**
     * Delete zero or more Works.
     * @param {WorkDeleteManyArgs} args - Arguments to filter Works to delete.
     * @example
     * // Delete a few Works
     * const { count } = await prisma.work.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkDeleteManyArgs>(
      args?: SelectSubset<T, WorkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Works
     * const work = await prisma.work.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkUpdateManyArgs>(
      args: SelectSubset<T, WorkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Work.
     * @param {WorkUpsertArgs} args - Arguments to update or create a Work.
     * @example
     * // Update or create a Work
     * const work = await prisma.work.upsert({
     *   create: {
     *     // ... data to create a Work
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Work we want to update
     *   }
     * })
    **/
    upsert<T extends WorkUpsertArgs>(
      args: SelectSubset<T, WorkUpsertArgs>
    ): Prisma__WorkClient<WorkGetPayload<T>>

    /**
     * Find zero or more Works that matches the filter.
     * @param {WorkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const work = await prisma.work.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WorkFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Work.
     * @param {WorkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const work = await prisma.work.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WorkAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Works.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkCountArgs} args - Arguments to filter Works to count.
     * @example
     * // Count the number of Works
     * const count = await prisma.work.count({
     *   where: {
     *     // ... the filter for the Works we want to count
     *   }
     * })
    **/
    count<T extends WorkCountArgs>(
      args?: Subset<T, WorkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkAggregateArgs>(args: Subset<T, WorkAggregateArgs>): Prisma.PrismaPromise<GetWorkAggregateType<T>>

    /**
     * Group by Work.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkGroupByArgs['orderBy'] }
        : { orderBy?: WorkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Work.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    type<T extends OptionArgs= {}>(args?: Subset<T, OptionArgs>): Prisma__OptionClient<OptionGetPayload<T> | Null>;

    unit<T extends UnitArgs= {}>(args?: Subset<T, UnitArgs>): Prisma__UnitClient<UnitGetPayload<T> | Null>;

    items<T extends Work$itemsArgs= {}>(args?: Subset<T, Work$itemsArgs>): Prisma.PrismaPromise<Array<WorkItemsGetPayload<T>>| Null>;

    historis<T extends Work$historisArgs= {}>(args?: Subset<T, Work$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    templates<T extends Work$templatesArgs= {}>(args?: Subset<T, Work$templatesArgs>): Prisma.PrismaPromise<Array<TemplateWorkGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Work base type for findUnique actions
   */
  export type WorkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * Filter, which Work to fetch.
     */
    where: WorkWhereUniqueInput
  }

  /**
   * Work findUnique
   */
  export interface WorkFindUniqueArgs extends WorkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Work findUniqueOrThrow
   */
  export type WorkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * Filter, which Work to fetch.
     */
    where: WorkWhereUniqueInput
  }


  /**
   * Work base type for findFirst actions
   */
  export type WorkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * Filter, which Work to fetch.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: Enumerable<WorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Works.
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Works.
     */
    distinct?: Enumerable<WorkScalarFieldEnum>
  }

  /**
   * Work findFirst
   */
  export interface WorkFindFirstArgs extends WorkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Work findFirstOrThrow
   */
  export type WorkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * Filter, which Work to fetch.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: Enumerable<WorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Works.
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Works.
     */
    distinct?: Enumerable<WorkScalarFieldEnum>
  }


  /**
   * Work findMany
   */
  export type WorkFindManyArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * Filter, which Works to fetch.
     */
    where?: WorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Works to fetch.
     */
    orderBy?: Enumerable<WorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Works.
     */
    cursor?: WorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Works from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Works.
     */
    skip?: number
    distinct?: Enumerable<WorkScalarFieldEnum>
  }


  /**
   * Work create
   */
  export type WorkCreateArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * The data needed to create a Work.
     */
    data: XOR<WorkCreateInput, WorkUncheckedCreateInput>
  }


  /**
   * Work createMany
   */
  export type WorkCreateManyArgs = {
    /**
     * The data used to create many Works.
     */
    data: Enumerable<WorkCreateManyInput>
  }


  /**
   * Work update
   */
  export type WorkUpdateArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * The data needed to update a Work.
     */
    data: XOR<WorkUpdateInput, WorkUncheckedUpdateInput>
    /**
     * Choose, which Work to update.
     */
    where: WorkWhereUniqueInput
  }


  /**
   * Work updateMany
   */
  export type WorkUpdateManyArgs = {
    /**
     * The data used to update Works.
     */
    data: XOR<WorkUpdateManyMutationInput, WorkUncheckedUpdateManyInput>
    /**
     * Filter which Works to update
     */
    where?: WorkWhereInput
  }


  /**
   * Work upsert
   */
  export type WorkUpsertArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * The filter to search for the Work to update in case it exists.
     */
    where: WorkWhereUniqueInput
    /**
     * In case the Work found by the `where` argument doesn't exist, create a new Work with this data.
     */
    create: XOR<WorkCreateInput, WorkUncheckedCreateInput>
    /**
     * In case the Work was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkUpdateInput, WorkUncheckedUpdateInput>
  }


  /**
   * Work delete
   */
  export type WorkDeleteArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
    /**
     * Filter which Work to delete.
     */
    where: WorkWhereUniqueInput
  }


  /**
   * Work deleteMany
   */
  export type WorkDeleteManyArgs = {
    /**
     * Filter which Works to delete
     */
    where?: WorkWhereInput
  }


  /**
   * Work findRaw
   */
  export type WorkFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Work aggregateRaw
   */
  export type WorkAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Work.items
   */
  export type Work$itemsArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    where?: WorkItemsWhereInput
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    cursor?: WorkItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkItemsScalarFieldEnum>
  }


  /**
   * Work.historis
   */
  export type Work$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Work.templates
   */
  export type Work$templatesArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    where?: TemplateWorkWhereInput
    orderBy?: Enumerable<TemplateWorkOrderByWithRelationInput>
    cursor?: TemplateWorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateWorkScalarFieldEnum>
  }


  /**
   * Work without action
   */
  export type WorkArgs = {
    /**
     * Select specific fields to fetch from the Work
     */
    select?: WorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkInclude | null
  }



  /**
   * Model WorkItems
   */


  export type AggregateWorkItems = {
    _count: WorkItemsCountAggregateOutputType | null
    _avg: WorkItemsAvgAggregateOutputType | null
    _sum: WorkItemsSumAggregateOutputType | null
    _min: WorkItemsMinAggregateOutputType | null
    _max: WorkItemsMaxAggregateOutputType | null
  }

  export type WorkItemsAvgAggregateOutputType = {
    coefficient: number | null
  }

  export type WorkItemsSumAggregateOutputType = {
    coefficient: number | null
  }

  export type WorkItemsMinAggregateOutputType = {
    id: string | null
    model: WorkModel | null
    workId: string | null
    itemId: string | null
    coefficient: number | null
    unitId: string | null
  }

  export type WorkItemsMaxAggregateOutputType = {
    id: string | null
    model: WorkModel | null
    workId: string | null
    itemId: string | null
    coefficient: number | null
    unitId: string | null
  }

  export type WorkItemsCountAggregateOutputType = {
    id: number
    model: number
    workId: number
    itemId: number
    coefficient: number
    unitId: number
    _all: number
  }


  export type WorkItemsAvgAggregateInputType = {
    coefficient?: true
  }

  export type WorkItemsSumAggregateInputType = {
    coefficient?: true
  }

  export type WorkItemsMinAggregateInputType = {
    id?: true
    model?: true
    workId?: true
    itemId?: true
    coefficient?: true
    unitId?: true
  }

  export type WorkItemsMaxAggregateInputType = {
    id?: true
    model?: true
    workId?: true
    itemId?: true
    coefficient?: true
    unitId?: true
  }

  export type WorkItemsCountAggregateInputType = {
    id?: true
    model?: true
    workId?: true
    itemId?: true
    coefficient?: true
    unitId?: true
    _all?: true
  }

  export type WorkItemsAggregateArgs = {
    /**
     * Filter which WorkItems to aggregate.
     */
    where?: WorkItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkItems
    **/
    _count?: true | WorkItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkItemsMaxAggregateInputType
  }

  export type GetWorkItemsAggregateType<T extends WorkItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkItems[P]>
      : GetScalarType<T[P], AggregateWorkItems[P]>
  }




  export type WorkItemsGroupByArgs = {
    where?: WorkItemsWhereInput
    orderBy?: Enumerable<WorkItemsOrderByWithAggregationInput>
    by: WorkItemsScalarFieldEnum[]
    having?: WorkItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkItemsCountAggregateInputType | true
    _avg?: WorkItemsAvgAggregateInputType
    _sum?: WorkItemsSumAggregateInputType
    _min?: WorkItemsMinAggregateInputType
    _max?: WorkItemsMaxAggregateInputType
  }


  export type WorkItemsGroupByOutputType = {
    id: string
    model: WorkModel
    workId: string
    itemId: string
    coefficient: number
    unitId: string | null
    _count: WorkItemsCountAggregateOutputType | null
    _avg: WorkItemsAvgAggregateOutputType | null
    _sum: WorkItemsSumAggregateOutputType | null
    _min: WorkItemsMinAggregateOutputType | null
    _max: WorkItemsMaxAggregateOutputType | null
  }

  type GetWorkItemsGroupByPayload<T extends WorkItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WorkItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkItemsGroupByOutputType[P]>
            : GetScalarType<T[P], WorkItemsGroupByOutputType[P]>
        }
      >
    >


  export type WorkItemsSelect = {
    id?: boolean
    model?: boolean
    workId?: boolean
    itemId?: boolean
    coefficient?: boolean
    unitId?: boolean
    work?: boolean | WorkArgs
    item?: boolean | ItemArgs
    unit?: boolean | UnitArgs
    historis?: boolean | WorkItems$historisArgs
    _count?: boolean | WorkItemsCountOutputTypeArgs
  }


  export type WorkItemsInclude = {
    work?: boolean | WorkArgs
    item?: boolean | ItemArgs
    unit?: boolean | UnitArgs
    historis?: boolean | WorkItems$historisArgs
    _count?: boolean | WorkItemsCountOutputTypeArgs
  }

  export type WorkItemsGetPayload<S extends boolean | null | undefined | WorkItemsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkItems :
    S extends undefined ? never :
    S extends { include: any } & (WorkItemsArgs | WorkItemsFindManyArgs)
    ? WorkItems  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'work' ? WorkGetPayload<S['include'][P]> :
        P extends 'item' ? ItemGetPayload<S['include'][P]> :
        P extends 'unit' ? UnitGetPayload<S['include'][P]> | null :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends '_count' ? WorkItemsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkItemsArgs | WorkItemsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'work' ? WorkGetPayload<S['select'][P]> :
        P extends 'item' ? ItemGetPayload<S['select'][P]> :
        P extends 'unit' ? UnitGetPayload<S['select'][P]> | null :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends '_count' ? WorkItemsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WorkItems ? WorkItems[P] : never
  } 
      : WorkItems


  type WorkItemsCountArgs = 
    Omit<WorkItemsFindManyArgs, 'select' | 'include'> & {
      select?: WorkItemsCountAggregateInputType | true
    }

  export interface WorkItemsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WorkItems that matches the filter.
     * @param {WorkItemsFindUniqueArgs} args - Arguments to find a WorkItems
     * @example
     * // Get one WorkItems
     * const workItems = await prisma.workItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkItemsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkItemsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkItems'> extends True ? Prisma__WorkItemsClient<WorkItemsGetPayload<T>> : Prisma__WorkItemsClient<WorkItemsGetPayload<T> | null, null>

    /**
     * Find one WorkItems that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkItemsFindUniqueOrThrowArgs} args - Arguments to find a WorkItems
     * @example
     * // Get one WorkItems
     * const workItems = await prisma.workItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkItemsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkItemsFindUniqueOrThrowArgs>
    ): Prisma__WorkItemsClient<WorkItemsGetPayload<T>>

    /**
     * Find the first WorkItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsFindFirstArgs} args - Arguments to find a WorkItems
     * @example
     * // Get one WorkItems
     * const workItems = await prisma.workItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkItemsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkItemsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkItems'> extends True ? Prisma__WorkItemsClient<WorkItemsGetPayload<T>> : Prisma__WorkItemsClient<WorkItemsGetPayload<T> | null, null>

    /**
     * Find the first WorkItems that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsFindFirstOrThrowArgs} args - Arguments to find a WorkItems
     * @example
     * // Get one WorkItems
     * const workItems = await prisma.workItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkItemsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkItemsFindFirstOrThrowArgs>
    ): Prisma__WorkItemsClient<WorkItemsGetPayload<T>>

    /**
     * Find zero or more WorkItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkItems
     * const workItems = await prisma.workItems.findMany()
     * 
     * // Get first 10 WorkItems
     * const workItems = await prisma.workItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workItemsWithIdOnly = await prisma.workItems.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkItemsFindManyArgs>(
      args?: SelectSubset<T, WorkItemsFindManyArgs>
    ): Prisma.PrismaPromise<Array<WorkItemsGetPayload<T>>>

    /**
     * Create a WorkItems.
     * @param {WorkItemsCreateArgs} args - Arguments to create a WorkItems.
     * @example
     * // Create one WorkItems
     * const WorkItems = await prisma.workItems.create({
     *   data: {
     *     // ... data to create a WorkItems
     *   }
     * })
     * 
    **/
    create<T extends WorkItemsCreateArgs>(
      args: SelectSubset<T, WorkItemsCreateArgs>
    ): Prisma__WorkItemsClient<WorkItemsGetPayload<T>>

    /**
     * Create many WorkItems.
     *     @param {WorkItemsCreateManyArgs} args - Arguments to create many WorkItems.
     *     @example
     *     // Create many WorkItems
     *     const workItems = await prisma.workItems.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkItemsCreateManyArgs>(
      args?: SelectSubset<T, WorkItemsCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkItems.
     * @param {WorkItemsDeleteArgs} args - Arguments to delete one WorkItems.
     * @example
     * // Delete one WorkItems
     * const WorkItems = await prisma.workItems.delete({
     *   where: {
     *     // ... filter to delete one WorkItems
     *   }
     * })
     * 
    **/
    delete<T extends WorkItemsDeleteArgs>(
      args: SelectSubset<T, WorkItemsDeleteArgs>
    ): Prisma__WorkItemsClient<WorkItemsGetPayload<T>>

    /**
     * Update one WorkItems.
     * @param {WorkItemsUpdateArgs} args - Arguments to update one WorkItems.
     * @example
     * // Update one WorkItems
     * const workItems = await prisma.workItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkItemsUpdateArgs>(
      args: SelectSubset<T, WorkItemsUpdateArgs>
    ): Prisma__WorkItemsClient<WorkItemsGetPayload<T>>

    /**
     * Delete zero or more WorkItems.
     * @param {WorkItemsDeleteManyArgs} args - Arguments to filter WorkItems to delete.
     * @example
     * // Delete a few WorkItems
     * const { count } = await prisma.workItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkItemsDeleteManyArgs>(
      args?: SelectSubset<T, WorkItemsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkItems
     * const workItems = await prisma.workItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkItemsUpdateManyArgs>(
      args: SelectSubset<T, WorkItemsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkItems.
     * @param {WorkItemsUpsertArgs} args - Arguments to update or create a WorkItems.
     * @example
     * // Update or create a WorkItems
     * const workItems = await prisma.workItems.upsert({
     *   create: {
     *     // ... data to create a WorkItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkItems we want to update
     *   }
     * })
    **/
    upsert<T extends WorkItemsUpsertArgs>(
      args: SelectSubset<T, WorkItemsUpsertArgs>
    ): Prisma__WorkItemsClient<WorkItemsGetPayload<T>>

    /**
     * Find zero or more WorkItems that matches the filter.
     * @param {WorkItemsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const workItems = await prisma.workItems.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WorkItemsFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WorkItems.
     * @param {WorkItemsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const workItems = await prisma.workItems.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WorkItemsAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of WorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsCountArgs} args - Arguments to filter WorkItems to count.
     * @example
     * // Count the number of WorkItems
     * const count = await prisma.workItems.count({
     *   where: {
     *     // ... the filter for the WorkItems we want to count
     *   }
     * })
    **/
    count<T extends WorkItemsCountArgs>(
      args?: Subset<T, WorkItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkItemsAggregateArgs>(args: Subset<T, WorkItemsAggregateArgs>): Prisma.PrismaPromise<GetWorkItemsAggregateType<T>>

    /**
     * Group by WorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkItemsGroupByArgs['orderBy'] }
        : { orderBy?: WorkItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkItemsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    work<T extends WorkArgs= {}>(args?: Subset<T, WorkArgs>): Prisma__WorkClient<WorkGetPayload<T> | Null>;

    item<T extends ItemArgs= {}>(args?: Subset<T, ItemArgs>): Prisma__ItemClient<ItemGetPayload<T> | Null>;

    unit<T extends UnitArgs= {}>(args?: Subset<T, UnitArgs>): Prisma__UnitClient<UnitGetPayload<T> | Null>;

    historis<T extends WorkItems$historisArgs= {}>(args?: Subset<T, WorkItems$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WorkItems base type for findUnique actions
   */
  export type WorkItemsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * Filter, which WorkItems to fetch.
     */
    where: WorkItemsWhereUniqueInput
  }

  /**
   * WorkItems findUnique
   */
  export interface WorkItemsFindUniqueArgs extends WorkItemsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkItems findUniqueOrThrow
   */
  export type WorkItemsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * Filter, which WorkItems to fetch.
     */
    where: WorkItemsWhereUniqueInput
  }


  /**
   * WorkItems base type for findFirst actions
   */
  export type WorkItemsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * Filter, which WorkItems to fetch.
     */
    where?: WorkItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItems.
     */
    cursor?: WorkItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItems.
     */
    distinct?: Enumerable<WorkItemsScalarFieldEnum>
  }

  /**
   * WorkItems findFirst
   */
  export interface WorkItemsFindFirstArgs extends WorkItemsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkItems findFirstOrThrow
   */
  export type WorkItemsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * Filter, which WorkItems to fetch.
     */
    where?: WorkItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkItems.
     */
    cursor?: WorkItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkItems.
     */
    distinct?: Enumerable<WorkItemsScalarFieldEnum>
  }


  /**
   * WorkItems findMany
   */
  export type WorkItemsFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * Filter, which WorkItems to fetch.
     */
    where?: WorkItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkItems to fetch.
     */
    orderBy?: Enumerable<WorkItemsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkItems.
     */
    cursor?: WorkItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkItems.
     */
    skip?: number
    distinct?: Enumerable<WorkItemsScalarFieldEnum>
  }


  /**
   * WorkItems create
   */
  export type WorkItemsCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * The data needed to create a WorkItems.
     */
    data: XOR<WorkItemsCreateInput, WorkItemsUncheckedCreateInput>
  }


  /**
   * WorkItems createMany
   */
  export type WorkItemsCreateManyArgs = {
    /**
     * The data used to create many WorkItems.
     */
    data: Enumerable<WorkItemsCreateManyInput>
  }


  /**
   * WorkItems update
   */
  export type WorkItemsUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * The data needed to update a WorkItems.
     */
    data: XOR<WorkItemsUpdateInput, WorkItemsUncheckedUpdateInput>
    /**
     * Choose, which WorkItems to update.
     */
    where: WorkItemsWhereUniqueInput
  }


  /**
   * WorkItems updateMany
   */
  export type WorkItemsUpdateManyArgs = {
    /**
     * The data used to update WorkItems.
     */
    data: XOR<WorkItemsUpdateManyMutationInput, WorkItemsUncheckedUpdateManyInput>
    /**
     * Filter which WorkItems to update
     */
    where?: WorkItemsWhereInput
  }


  /**
   * WorkItems upsert
   */
  export type WorkItemsUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * The filter to search for the WorkItems to update in case it exists.
     */
    where: WorkItemsWhereUniqueInput
    /**
     * In case the WorkItems found by the `where` argument doesn't exist, create a new WorkItems with this data.
     */
    create: XOR<WorkItemsCreateInput, WorkItemsUncheckedCreateInput>
    /**
     * In case the WorkItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkItemsUpdateInput, WorkItemsUncheckedUpdateInput>
  }


  /**
   * WorkItems delete
   */
  export type WorkItemsDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
    /**
     * Filter which WorkItems to delete.
     */
    where: WorkItemsWhereUniqueInput
  }


  /**
   * WorkItems deleteMany
   */
  export type WorkItemsDeleteManyArgs = {
    /**
     * Filter which WorkItems to delete
     */
    where?: WorkItemsWhereInput
  }


  /**
   * WorkItems findRaw
   */
  export type WorkItemsFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * WorkItems aggregateRaw
   */
  export type WorkItemsAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * WorkItems.historis
   */
  export type WorkItems$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * WorkItems without action
   */
  export type WorkItemsArgs = {
    /**
     * Select specific fields to fetch from the WorkItems
     */
    select?: WorkItemsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkItemsInclude | null
  }



  /**
   * Model Template
   */


  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    activeId: string | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    activeId: string | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    activeId: number
    _all: number
  }


  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    activeId?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    activeId?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    activeId?: true
    _all?: true
  }

  export type TemplateAggregateArgs = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs = {
    where?: TemplateWhereInput
    orderBy?: Enumerable<TemplateOrderByWithAggregationInput>
    by: TemplateScalarFieldEnum[]
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }


  export type TemplateGroupByOutputType = {
    id: string
    name: string
    activeId: string | null
    _count: TemplateCountAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect = {
    id?: boolean
    name?: boolean
    activeId?: boolean
    active?: boolean | TemplateDataArgs
    records?: boolean | Template$recordsArgs
    historis?: boolean | Template$historisArgs
    _count?: boolean | TemplateCountOutputTypeArgs
  }


  export type TemplateInclude = {
    active?: boolean | TemplateDataArgs
    records?: boolean | Template$recordsArgs
    historis?: boolean | Template$historisArgs
    _count?: boolean | TemplateCountOutputTypeArgs
  }

  export type TemplateGetPayload<S extends boolean | null | undefined | TemplateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Template :
    S extends undefined ? never :
    S extends { include: any } & (TemplateArgs | TemplateFindManyArgs)
    ? Template  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'active' ? TemplateDataGetPayload<S['include'][P]> | null :
        P extends 'records' ? Array < TemplateDataGetPayload<S['include'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['include'][P]>>  :
        P extends '_count' ? TemplateCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TemplateArgs | TemplateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'active' ? TemplateDataGetPayload<S['select'][P]> | null :
        P extends 'records' ? Array < TemplateDataGetPayload<S['select'][P]>>  :
        P extends 'historis' ? Array < HistoriGetPayload<S['select'][P]>>  :
        P extends '_count' ? TemplateCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Template ? Template[P] : never
  } 
      : Template


  type TemplateCountArgs = 
    Omit<TemplateFindManyArgs, 'select' | 'include'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Template'> extends True ? Prisma__TemplateClient<TemplateGetPayload<T>> : Prisma__TemplateClient<TemplateGetPayload<T> | null, null>

    /**
     * Find one Template that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplateFindUniqueOrThrowArgs>
    ): Prisma__TemplateClient<TemplateGetPayload<T>>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Template'> extends True ? Prisma__TemplateClient<TemplateGetPayload<T>> : Prisma__TemplateClient<TemplateGetPayload<T> | null, null>

    /**
     * Find the first Template that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplateFindFirstOrThrowArgs>
    ): Prisma__TemplateClient<TemplateGetPayload<T>>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateFindManyArgs>(
      args?: SelectSubset<T, TemplateFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplateGetPayload<T>>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
    **/
    create<T extends TemplateCreateArgs>(
      args: SelectSubset<T, TemplateCreateArgs>
    ): Prisma__TemplateClient<TemplateGetPayload<T>>

    /**
     * Create many Templates.
     *     @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     *     @example
     *     // Create many Templates
     *     const template = await prisma.template.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateCreateManyArgs>(
      args?: SelectSubset<T, TemplateCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
    **/
    delete<T extends TemplateDeleteArgs>(
      args: SelectSubset<T, TemplateDeleteArgs>
    ): Prisma__TemplateClient<TemplateGetPayload<T>>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateUpdateArgs>(
      args: SelectSubset<T, TemplateUpdateArgs>
    ): Prisma__TemplateClient<TemplateGetPayload<T>>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateDeleteManyArgs>(
      args?: SelectSubset<T, TemplateDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateUpdateManyArgs>(
      args: SelectSubset<T, TemplateUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateUpsertArgs>(
      args: SelectSubset<T, TemplateUpsertArgs>
    ): Prisma__TemplateClient<TemplateGetPayload<T>>

    /**
     * Find zero or more Templates that matches the filter.
     * @param {TemplateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const template = await prisma.template.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemplateFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Template.
     * @param {TemplateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const template = await prisma.template.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemplateAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    active<T extends TemplateDataArgs= {}>(args?: Subset<T, TemplateDataArgs>): Prisma__TemplateDataClient<TemplateDataGetPayload<T> | Null>;

    records<T extends Template$recordsArgs= {}>(args?: Subset<T, Template$recordsArgs>): Prisma.PrismaPromise<Array<TemplateDataGetPayload<T>>| Null>;

    historis<T extends Template$historisArgs= {}>(args?: Subset<T, Template$historisArgs>): Prisma.PrismaPromise<Array<HistoriGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Template base type for findUnique actions
   */
  export type TemplateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUnique
   */
  export interface TemplateFindUniqueArgs extends TemplateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template base type for findFirst actions
   */
  export type TemplateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }

  /**
   * Template findFirst
   */
  export interface TemplateFindFirstArgs extends TemplateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }


  /**
   * Template findMany
   */
  export type TemplateFindManyArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }


  /**
   * Template create
   */
  export type TemplateCreateArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }


  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs = {
    /**
     * The data used to create many Templates.
     */
    data: Enumerable<TemplateCreateManyInput>
  }


  /**
   * Template update
   */
  export type TemplateUpdateArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }


  /**
   * Template upsert
   */
  export type TemplateUpsertArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }


  /**
   * Template delete
   */
  export type TemplateDeleteArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }


  /**
   * Template findRaw
   */
  export type TemplateFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Template aggregateRaw
   */
  export type TemplateAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Template.records
   */
  export type Template$recordsArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    where?: TemplateDataWhereInput
    orderBy?: Enumerable<TemplateDataOrderByWithRelationInput>
    cursor?: TemplateDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateDataScalarFieldEnum>
  }


  /**
   * Template.historis
   */
  export type Template$historisArgs = {
    /**
     * Select specific fields to fetch from the Histori
     */
    select?: HistoriSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistoriInclude | null
    where?: HistoriWhereInput
    orderBy?: Enumerable<HistoriOrderByWithRelationInput>
    cursor?: HistoriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<HistoriScalarFieldEnum>
  }


  /**
   * Template without action
   */
  export type TemplateArgs = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude | null
  }



  /**
   * Model TemplateWorkItem
   */


  export type AggregateTemplateWorkItem = {
    _count: TemplateWorkItemCountAggregateOutputType | null
    _avg: TemplateWorkItemAvgAggregateOutputType | null
    _sum: TemplateWorkItemSumAggregateOutputType | null
    _min: TemplateWorkItemMinAggregateOutputType | null
    _max: TemplateWorkItemMaxAggregateOutputType | null
  }

  export type TemplateWorkItemAvgAggregateOutputType = {
    coefficient: number | null
  }

  export type TemplateWorkItemSumAggregateOutputType = {
    coefficient: number | null
  }

  export type TemplateWorkItemMinAggregateOutputType = {
    id: string | null
    type: ItemModel | null
    itemId: string | null
    coefficient: number | null
    unitId: string | null
    parentId: string | null
  }

  export type TemplateWorkItemMaxAggregateOutputType = {
    id: string | null
    type: ItemModel | null
    itemId: string | null
    coefficient: number | null
    unitId: string | null
    parentId: string | null
  }

  export type TemplateWorkItemCountAggregateOutputType = {
    id: number
    type: number
    itemId: number
    coefficient: number
    unitId: number
    parentId: number
    _all: number
  }


  export type TemplateWorkItemAvgAggregateInputType = {
    coefficient?: true
  }

  export type TemplateWorkItemSumAggregateInputType = {
    coefficient?: true
  }

  export type TemplateWorkItemMinAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    coefficient?: true
    unitId?: true
    parentId?: true
  }

  export type TemplateWorkItemMaxAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    coefficient?: true
    unitId?: true
    parentId?: true
  }

  export type TemplateWorkItemCountAggregateInputType = {
    id?: true
    type?: true
    itemId?: true
    coefficient?: true
    unitId?: true
    parentId?: true
    _all?: true
  }

  export type TemplateWorkItemAggregateArgs = {
    /**
     * Filter which TemplateWorkItem to aggregate.
     */
    where?: TemplateWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorkItems to fetch.
     */
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateWorkItems
    **/
    _count?: true | TemplateWorkItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateWorkItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateWorkItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateWorkItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateWorkItemMaxAggregateInputType
  }

  export type GetTemplateWorkItemAggregateType<T extends TemplateWorkItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateWorkItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateWorkItem[P]>
      : GetScalarType<T[P], AggregateTemplateWorkItem[P]>
  }




  export type TemplateWorkItemGroupByArgs = {
    where?: TemplateWorkItemWhereInput
    orderBy?: Enumerable<TemplateWorkItemOrderByWithAggregationInput>
    by: TemplateWorkItemScalarFieldEnum[]
    having?: TemplateWorkItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateWorkItemCountAggregateInputType | true
    _avg?: TemplateWorkItemAvgAggregateInputType
    _sum?: TemplateWorkItemSumAggregateInputType
    _min?: TemplateWorkItemMinAggregateInputType
    _max?: TemplateWorkItemMaxAggregateInputType
  }


  export type TemplateWorkItemGroupByOutputType = {
    id: string
    type: ItemModel
    itemId: string
    coefficient: number
    unitId: string
    parentId: string
    _count: TemplateWorkItemCountAggregateOutputType | null
    _avg: TemplateWorkItemAvgAggregateOutputType | null
    _sum: TemplateWorkItemSumAggregateOutputType | null
    _min: TemplateWorkItemMinAggregateOutputType | null
    _max: TemplateWorkItemMaxAggregateOutputType | null
  }

  type GetTemplateWorkItemGroupByPayload<T extends TemplateWorkItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateWorkItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateWorkItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateWorkItemGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateWorkItemGroupByOutputType[P]>
        }
      >
    >


  export type TemplateWorkItemSelect = {
    id?: boolean
    type?: boolean
    itemId?: boolean
    coefficient?: boolean
    unitId?: boolean
    parentId?: boolean
    item?: boolean | ItemArgs
    unit?: boolean | UnitArgs
    parent?: boolean | TemplateWorkArgs
  }


  export type TemplateWorkItemInclude = {
    item?: boolean | ItemArgs
    unit?: boolean | UnitArgs
    parent?: boolean | TemplateWorkArgs
  }

  export type TemplateWorkItemGetPayload<S extends boolean | null | undefined | TemplateWorkItemArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateWorkItem :
    S extends undefined ? never :
    S extends { include: any } & (TemplateWorkItemArgs | TemplateWorkItemFindManyArgs)
    ? TemplateWorkItem  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'item' ? ItemGetPayload<S['include'][P]> :
        P extends 'unit' ? UnitGetPayload<S['include'][P]> :
        P extends 'parent' ? TemplateWorkGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TemplateWorkItemArgs | TemplateWorkItemFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'item' ? ItemGetPayload<S['select'][P]> :
        P extends 'unit' ? UnitGetPayload<S['select'][P]> :
        P extends 'parent' ? TemplateWorkGetPayload<S['select'][P]> :  P extends keyof TemplateWorkItem ? TemplateWorkItem[P] : never
  } 
      : TemplateWorkItem


  type TemplateWorkItemCountArgs = 
    Omit<TemplateWorkItemFindManyArgs, 'select' | 'include'> & {
      select?: TemplateWorkItemCountAggregateInputType | true
    }

  export interface TemplateWorkItemDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TemplateWorkItem that matches the filter.
     * @param {TemplateWorkItemFindUniqueArgs} args - Arguments to find a TemplateWorkItem
     * @example
     * // Get one TemplateWorkItem
     * const templateWorkItem = await prisma.templateWorkItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateWorkItemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateWorkItemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TemplateWorkItem'> extends True ? Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>> : Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T> | null, null>

    /**
     * Find one TemplateWorkItem that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateWorkItemFindUniqueOrThrowArgs} args - Arguments to find a TemplateWorkItem
     * @example
     * // Get one TemplateWorkItem
     * const templateWorkItem = await prisma.templateWorkItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateWorkItemFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplateWorkItemFindUniqueOrThrowArgs>
    ): Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>>

    /**
     * Find the first TemplateWorkItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemFindFirstArgs} args - Arguments to find a TemplateWorkItem
     * @example
     * // Get one TemplateWorkItem
     * const templateWorkItem = await prisma.templateWorkItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateWorkItemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateWorkItemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TemplateWorkItem'> extends True ? Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>> : Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T> | null, null>

    /**
     * Find the first TemplateWorkItem that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemFindFirstOrThrowArgs} args - Arguments to find a TemplateWorkItem
     * @example
     * // Get one TemplateWorkItem
     * const templateWorkItem = await prisma.templateWorkItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateWorkItemFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplateWorkItemFindFirstOrThrowArgs>
    ): Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>>

    /**
     * Find zero or more TemplateWorkItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateWorkItems
     * const templateWorkItems = await prisma.templateWorkItem.findMany()
     * 
     * // Get first 10 TemplateWorkItems
     * const templateWorkItems = await prisma.templateWorkItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWorkItemWithIdOnly = await prisma.templateWorkItem.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateWorkItemFindManyArgs>(
      args?: SelectSubset<T, TemplateWorkItemFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplateWorkItemGetPayload<T>>>

    /**
     * Create a TemplateWorkItem.
     * @param {TemplateWorkItemCreateArgs} args - Arguments to create a TemplateWorkItem.
     * @example
     * // Create one TemplateWorkItem
     * const TemplateWorkItem = await prisma.templateWorkItem.create({
     *   data: {
     *     // ... data to create a TemplateWorkItem
     *   }
     * })
     * 
    **/
    create<T extends TemplateWorkItemCreateArgs>(
      args: SelectSubset<T, TemplateWorkItemCreateArgs>
    ): Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>>

    /**
     * Create many TemplateWorkItems.
     *     @param {TemplateWorkItemCreateManyArgs} args - Arguments to create many TemplateWorkItems.
     *     @example
     *     // Create many TemplateWorkItems
     *     const templateWorkItem = await prisma.templateWorkItem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateWorkItemCreateManyArgs>(
      args?: SelectSubset<T, TemplateWorkItemCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateWorkItem.
     * @param {TemplateWorkItemDeleteArgs} args - Arguments to delete one TemplateWorkItem.
     * @example
     * // Delete one TemplateWorkItem
     * const TemplateWorkItem = await prisma.templateWorkItem.delete({
     *   where: {
     *     // ... filter to delete one TemplateWorkItem
     *   }
     * })
     * 
    **/
    delete<T extends TemplateWorkItemDeleteArgs>(
      args: SelectSubset<T, TemplateWorkItemDeleteArgs>
    ): Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>>

    /**
     * Update one TemplateWorkItem.
     * @param {TemplateWorkItemUpdateArgs} args - Arguments to update one TemplateWorkItem.
     * @example
     * // Update one TemplateWorkItem
     * const templateWorkItem = await prisma.templateWorkItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateWorkItemUpdateArgs>(
      args: SelectSubset<T, TemplateWorkItemUpdateArgs>
    ): Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>>

    /**
     * Delete zero or more TemplateWorkItems.
     * @param {TemplateWorkItemDeleteManyArgs} args - Arguments to filter TemplateWorkItems to delete.
     * @example
     * // Delete a few TemplateWorkItems
     * const { count } = await prisma.templateWorkItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateWorkItemDeleteManyArgs>(
      args?: SelectSubset<T, TemplateWorkItemDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateWorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateWorkItems
     * const templateWorkItem = await prisma.templateWorkItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateWorkItemUpdateManyArgs>(
      args: SelectSubset<T, TemplateWorkItemUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateWorkItem.
     * @param {TemplateWorkItemUpsertArgs} args - Arguments to update or create a TemplateWorkItem.
     * @example
     * // Update or create a TemplateWorkItem
     * const templateWorkItem = await prisma.templateWorkItem.upsert({
     *   create: {
     *     // ... data to create a TemplateWorkItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateWorkItem we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateWorkItemUpsertArgs>(
      args: SelectSubset<T, TemplateWorkItemUpsertArgs>
    ): Prisma__TemplateWorkItemClient<TemplateWorkItemGetPayload<T>>

    /**
     * Find zero or more TemplateWorkItems that matches the filter.
     * @param {TemplateWorkItemFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const templateWorkItem = await prisma.templateWorkItem.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemplateWorkItemFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TemplateWorkItem.
     * @param {TemplateWorkItemAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const templateWorkItem = await prisma.templateWorkItem.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemplateWorkItemAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TemplateWorkItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemCountArgs} args - Arguments to filter TemplateWorkItems to count.
     * @example
     * // Count the number of TemplateWorkItems
     * const count = await prisma.templateWorkItem.count({
     *   where: {
     *     // ... the filter for the TemplateWorkItems we want to count
     *   }
     * })
    **/
    count<T extends TemplateWorkItemCountArgs>(
      args?: Subset<T, TemplateWorkItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateWorkItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateWorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateWorkItemAggregateArgs>(args: Subset<T, TemplateWorkItemAggregateArgs>): Prisma.PrismaPromise<GetTemplateWorkItemAggregateType<T>>

    /**
     * Group by TemplateWorkItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateWorkItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateWorkItemGroupByArgs['orderBy'] }
        : { orderBy?: TemplateWorkItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateWorkItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateWorkItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateWorkItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateWorkItemClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    item<T extends ItemArgs= {}>(args?: Subset<T, ItemArgs>): Prisma__ItemClient<ItemGetPayload<T> | Null>;

    unit<T extends UnitArgs= {}>(args?: Subset<T, UnitArgs>): Prisma__UnitClient<UnitGetPayload<T> | Null>;

    parent<T extends TemplateWorkArgs= {}>(args?: Subset<T, TemplateWorkArgs>): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TemplateWorkItem base type for findUnique actions
   */
  export type TemplateWorkItemFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * Filter, which TemplateWorkItem to fetch.
     */
    where: TemplateWorkItemWhereUniqueInput
  }

  /**
   * TemplateWorkItem findUnique
   */
  export interface TemplateWorkItemFindUniqueArgs extends TemplateWorkItemFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateWorkItem findUniqueOrThrow
   */
  export type TemplateWorkItemFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * Filter, which TemplateWorkItem to fetch.
     */
    where: TemplateWorkItemWhereUniqueInput
  }


  /**
   * TemplateWorkItem base type for findFirst actions
   */
  export type TemplateWorkItemFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * Filter, which TemplateWorkItem to fetch.
     */
    where?: TemplateWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorkItems to fetch.
     */
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateWorkItems.
     */
    cursor?: TemplateWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateWorkItems.
     */
    distinct?: Enumerable<TemplateWorkItemScalarFieldEnum>
  }

  /**
   * TemplateWorkItem findFirst
   */
  export interface TemplateWorkItemFindFirstArgs extends TemplateWorkItemFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateWorkItem findFirstOrThrow
   */
  export type TemplateWorkItemFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * Filter, which TemplateWorkItem to fetch.
     */
    where?: TemplateWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorkItems to fetch.
     */
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateWorkItems.
     */
    cursor?: TemplateWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorkItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateWorkItems.
     */
    distinct?: Enumerable<TemplateWorkItemScalarFieldEnum>
  }


  /**
   * TemplateWorkItem findMany
   */
  export type TemplateWorkItemFindManyArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * Filter, which TemplateWorkItems to fetch.
     */
    where?: TemplateWorkItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorkItems to fetch.
     */
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateWorkItems.
     */
    cursor?: TemplateWorkItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorkItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorkItems.
     */
    skip?: number
    distinct?: Enumerable<TemplateWorkItemScalarFieldEnum>
  }


  /**
   * TemplateWorkItem create
   */
  export type TemplateWorkItemCreateArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * The data needed to create a TemplateWorkItem.
     */
    data: XOR<TemplateWorkItemCreateInput, TemplateWorkItemUncheckedCreateInput>
  }


  /**
   * TemplateWorkItem createMany
   */
  export type TemplateWorkItemCreateManyArgs = {
    /**
     * The data used to create many TemplateWorkItems.
     */
    data: Enumerable<TemplateWorkItemCreateManyInput>
  }


  /**
   * TemplateWorkItem update
   */
  export type TemplateWorkItemUpdateArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * The data needed to update a TemplateWorkItem.
     */
    data: XOR<TemplateWorkItemUpdateInput, TemplateWorkItemUncheckedUpdateInput>
    /**
     * Choose, which TemplateWorkItem to update.
     */
    where: TemplateWorkItemWhereUniqueInput
  }


  /**
   * TemplateWorkItem updateMany
   */
  export type TemplateWorkItemUpdateManyArgs = {
    /**
     * The data used to update TemplateWorkItems.
     */
    data: XOR<TemplateWorkItemUpdateManyMutationInput, TemplateWorkItemUncheckedUpdateManyInput>
    /**
     * Filter which TemplateWorkItems to update
     */
    where?: TemplateWorkItemWhereInput
  }


  /**
   * TemplateWorkItem upsert
   */
  export type TemplateWorkItemUpsertArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * The filter to search for the TemplateWorkItem to update in case it exists.
     */
    where: TemplateWorkItemWhereUniqueInput
    /**
     * In case the TemplateWorkItem found by the `where` argument doesn't exist, create a new TemplateWorkItem with this data.
     */
    create: XOR<TemplateWorkItemCreateInput, TemplateWorkItemUncheckedCreateInput>
    /**
     * In case the TemplateWorkItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateWorkItemUpdateInput, TemplateWorkItemUncheckedUpdateInput>
  }


  /**
   * TemplateWorkItem delete
   */
  export type TemplateWorkItemDeleteArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    /**
     * Filter which TemplateWorkItem to delete.
     */
    where: TemplateWorkItemWhereUniqueInput
  }


  /**
   * TemplateWorkItem deleteMany
   */
  export type TemplateWorkItemDeleteManyArgs = {
    /**
     * Filter which TemplateWorkItems to delete
     */
    where?: TemplateWorkItemWhereInput
  }


  /**
   * TemplateWorkItem findRaw
   */
  export type TemplateWorkItemFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateWorkItem aggregateRaw
   */
  export type TemplateWorkItemAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateWorkItem without action
   */
  export type TemplateWorkItemArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
  }



  /**
   * Model TemplateWork
   */


  export type AggregateTemplateWork = {
    _count: TemplateWorkCountAggregateOutputType | null
    _min: TemplateWorkMinAggregateOutputType | null
    _max: TemplateWorkMaxAggregateOutputType | null
  }

  export type TemplateWorkMinAggregateOutputType = {
    id: string | null
    dataId: string | null
    workId: string | null
  }

  export type TemplateWorkMaxAggregateOutputType = {
    id: string | null
    dataId: string | null
    workId: string | null
  }

  export type TemplateWorkCountAggregateOutputType = {
    id: number
    dataId: number
    workId: number
    _all: number
  }


  export type TemplateWorkMinAggregateInputType = {
    id?: true
    dataId?: true
    workId?: true
  }

  export type TemplateWorkMaxAggregateInputType = {
    id?: true
    dataId?: true
    workId?: true
  }

  export type TemplateWorkCountAggregateInputType = {
    id?: true
    dataId?: true
    workId?: true
    _all?: true
  }

  export type TemplateWorkAggregateArgs = {
    /**
     * Filter which TemplateWork to aggregate.
     */
    where?: TemplateWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorks to fetch.
     */
    orderBy?: Enumerable<TemplateWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateWorks
    **/
    _count?: true | TemplateWorkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateWorkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateWorkMaxAggregateInputType
  }

  export type GetTemplateWorkAggregateType<T extends TemplateWorkAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateWork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateWork[P]>
      : GetScalarType<T[P], AggregateTemplateWork[P]>
  }




  export type TemplateWorkGroupByArgs = {
    where?: TemplateWorkWhereInput
    orderBy?: Enumerable<TemplateWorkOrderByWithAggregationInput>
    by: TemplateWorkScalarFieldEnum[]
    having?: TemplateWorkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateWorkCountAggregateInputType | true
    _min?: TemplateWorkMinAggregateInputType
    _max?: TemplateWorkMaxAggregateInputType
  }


  export type TemplateWorkGroupByOutputType = {
    id: string
    dataId: string
    workId: string
    _count: TemplateWorkCountAggregateOutputType | null
    _min: TemplateWorkMinAggregateOutputType | null
    _max: TemplateWorkMaxAggregateOutputType | null
  }

  type GetTemplateWorkGroupByPayload<T extends TemplateWorkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateWorkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateWorkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateWorkGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateWorkGroupByOutputType[P]>
        }
      >
    >


  export type TemplateWorkSelect = {
    id?: boolean
    dataId?: boolean
    workId?: boolean
    data?: boolean | TemplateDataArgs
    work?: boolean | WorkArgs
    items?: boolean | TemplateWork$itemsArgs
    stages?: boolean | TemplateWork$stagesArgs
    _count?: boolean | TemplateWorkCountOutputTypeArgs
  }


  export type TemplateWorkInclude = {
    data?: boolean | TemplateDataArgs
    work?: boolean | WorkArgs
    items?: boolean | TemplateWork$itemsArgs
    stages?: boolean | TemplateWork$stagesArgs
    _count?: boolean | TemplateWorkCountOutputTypeArgs
  }

  export type TemplateWorkGetPayload<S extends boolean | null | undefined | TemplateWorkArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateWork :
    S extends undefined ? never :
    S extends { include: any } & (TemplateWorkArgs | TemplateWorkFindManyArgs)
    ? TemplateWork  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'data' ? TemplateDataGetPayload<S['include'][P]> :
        P extends 'work' ? WorkGetPayload<S['include'][P]> :
        P extends 'items' ? Array < TemplateWorkItemGetPayload<S['include'][P]>>  :
        P extends 'stages' ? Array < StageGetPayload<S['include'][P]>>  :
        P extends '_count' ? TemplateWorkCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TemplateWorkArgs | TemplateWorkFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'data' ? TemplateDataGetPayload<S['select'][P]> :
        P extends 'work' ? WorkGetPayload<S['select'][P]> :
        P extends 'items' ? Array < TemplateWorkItemGetPayload<S['select'][P]>>  :
        P extends 'stages' ? Array < StageGetPayload<S['select'][P]>>  :
        P extends '_count' ? TemplateWorkCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TemplateWork ? TemplateWork[P] : never
  } 
      : TemplateWork


  type TemplateWorkCountArgs = 
    Omit<TemplateWorkFindManyArgs, 'select' | 'include'> & {
      select?: TemplateWorkCountAggregateInputType | true
    }

  export interface TemplateWorkDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TemplateWork that matches the filter.
     * @param {TemplateWorkFindUniqueArgs} args - Arguments to find a TemplateWork
     * @example
     * // Get one TemplateWork
     * const templateWork = await prisma.templateWork.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateWorkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateWorkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TemplateWork'> extends True ? Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>> : Prisma__TemplateWorkClient<TemplateWorkGetPayload<T> | null, null>

    /**
     * Find one TemplateWork that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateWorkFindUniqueOrThrowArgs} args - Arguments to find a TemplateWork
     * @example
     * // Get one TemplateWork
     * const templateWork = await prisma.templateWork.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateWorkFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplateWorkFindUniqueOrThrowArgs>
    ): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>>

    /**
     * Find the first TemplateWork that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkFindFirstArgs} args - Arguments to find a TemplateWork
     * @example
     * // Get one TemplateWork
     * const templateWork = await prisma.templateWork.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateWorkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateWorkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TemplateWork'> extends True ? Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>> : Prisma__TemplateWorkClient<TemplateWorkGetPayload<T> | null, null>

    /**
     * Find the first TemplateWork that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkFindFirstOrThrowArgs} args - Arguments to find a TemplateWork
     * @example
     * // Get one TemplateWork
     * const templateWork = await prisma.templateWork.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateWorkFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplateWorkFindFirstOrThrowArgs>
    ): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>>

    /**
     * Find zero or more TemplateWorks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateWorks
     * const templateWorks = await prisma.templateWork.findMany()
     * 
     * // Get first 10 TemplateWorks
     * const templateWorks = await prisma.templateWork.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWorkWithIdOnly = await prisma.templateWork.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateWorkFindManyArgs>(
      args?: SelectSubset<T, TemplateWorkFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplateWorkGetPayload<T>>>

    /**
     * Create a TemplateWork.
     * @param {TemplateWorkCreateArgs} args - Arguments to create a TemplateWork.
     * @example
     * // Create one TemplateWork
     * const TemplateWork = await prisma.templateWork.create({
     *   data: {
     *     // ... data to create a TemplateWork
     *   }
     * })
     * 
    **/
    create<T extends TemplateWorkCreateArgs>(
      args: SelectSubset<T, TemplateWorkCreateArgs>
    ): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>>

    /**
     * Create many TemplateWorks.
     *     @param {TemplateWorkCreateManyArgs} args - Arguments to create many TemplateWorks.
     *     @example
     *     // Create many TemplateWorks
     *     const templateWork = await prisma.templateWork.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateWorkCreateManyArgs>(
      args?: SelectSubset<T, TemplateWorkCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateWork.
     * @param {TemplateWorkDeleteArgs} args - Arguments to delete one TemplateWork.
     * @example
     * // Delete one TemplateWork
     * const TemplateWork = await prisma.templateWork.delete({
     *   where: {
     *     // ... filter to delete one TemplateWork
     *   }
     * })
     * 
    **/
    delete<T extends TemplateWorkDeleteArgs>(
      args: SelectSubset<T, TemplateWorkDeleteArgs>
    ): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>>

    /**
     * Update one TemplateWork.
     * @param {TemplateWorkUpdateArgs} args - Arguments to update one TemplateWork.
     * @example
     * // Update one TemplateWork
     * const templateWork = await prisma.templateWork.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateWorkUpdateArgs>(
      args: SelectSubset<T, TemplateWorkUpdateArgs>
    ): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>>

    /**
     * Delete zero or more TemplateWorks.
     * @param {TemplateWorkDeleteManyArgs} args - Arguments to filter TemplateWorks to delete.
     * @example
     * // Delete a few TemplateWorks
     * const { count } = await prisma.templateWork.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateWorkDeleteManyArgs>(
      args?: SelectSubset<T, TemplateWorkDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateWorks
     * const templateWork = await prisma.templateWork.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateWorkUpdateManyArgs>(
      args: SelectSubset<T, TemplateWorkUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateWork.
     * @param {TemplateWorkUpsertArgs} args - Arguments to update or create a TemplateWork.
     * @example
     * // Update or create a TemplateWork
     * const templateWork = await prisma.templateWork.upsert({
     *   create: {
     *     // ... data to create a TemplateWork
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateWork we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateWorkUpsertArgs>(
      args: SelectSubset<T, TemplateWorkUpsertArgs>
    ): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T>>

    /**
     * Find zero or more TemplateWorks that matches the filter.
     * @param {TemplateWorkFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const templateWork = await prisma.templateWork.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemplateWorkFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TemplateWork.
     * @param {TemplateWorkAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const templateWork = await prisma.templateWork.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemplateWorkAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TemplateWorks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkCountArgs} args - Arguments to filter TemplateWorks to count.
     * @example
     * // Count the number of TemplateWorks
     * const count = await prisma.templateWork.count({
     *   where: {
     *     // ... the filter for the TemplateWorks we want to count
     *   }
     * })
    **/
    count<T extends TemplateWorkCountArgs>(
      args?: Subset<T, TemplateWorkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateWorkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateWorkAggregateArgs>(args: Subset<T, TemplateWorkAggregateArgs>): Prisma.PrismaPromise<GetTemplateWorkAggregateType<T>>

    /**
     * Group by TemplateWork.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateWorkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateWorkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateWorkGroupByArgs['orderBy'] }
        : { orderBy?: TemplateWorkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateWorkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateWorkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateWork.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateWorkClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    data<T extends TemplateDataArgs= {}>(args?: Subset<T, TemplateDataArgs>): Prisma__TemplateDataClient<TemplateDataGetPayload<T> | Null>;

    work<T extends WorkArgs= {}>(args?: Subset<T, WorkArgs>): Prisma__WorkClient<WorkGetPayload<T> | Null>;

    items<T extends TemplateWork$itemsArgs= {}>(args?: Subset<T, TemplateWork$itemsArgs>): Prisma.PrismaPromise<Array<TemplateWorkItemGetPayload<T>>| Null>;

    stages<T extends TemplateWork$stagesArgs= {}>(args?: Subset<T, TemplateWork$stagesArgs>): Prisma.PrismaPromise<Array<StageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TemplateWork base type for findUnique actions
   */
  export type TemplateWorkFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * Filter, which TemplateWork to fetch.
     */
    where: TemplateWorkWhereUniqueInput
  }

  /**
   * TemplateWork findUnique
   */
  export interface TemplateWorkFindUniqueArgs extends TemplateWorkFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateWork findUniqueOrThrow
   */
  export type TemplateWorkFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * Filter, which TemplateWork to fetch.
     */
    where: TemplateWorkWhereUniqueInput
  }


  /**
   * TemplateWork base type for findFirst actions
   */
  export type TemplateWorkFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * Filter, which TemplateWork to fetch.
     */
    where?: TemplateWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorks to fetch.
     */
    orderBy?: Enumerable<TemplateWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateWorks.
     */
    cursor?: TemplateWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateWorks.
     */
    distinct?: Enumerable<TemplateWorkScalarFieldEnum>
  }

  /**
   * TemplateWork findFirst
   */
  export interface TemplateWorkFindFirstArgs extends TemplateWorkFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateWork findFirstOrThrow
   */
  export type TemplateWorkFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * Filter, which TemplateWork to fetch.
     */
    where?: TemplateWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorks to fetch.
     */
    orderBy?: Enumerable<TemplateWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateWorks.
     */
    cursor?: TemplateWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateWorks.
     */
    distinct?: Enumerable<TemplateWorkScalarFieldEnum>
  }


  /**
   * TemplateWork findMany
   */
  export type TemplateWorkFindManyArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * Filter, which TemplateWorks to fetch.
     */
    where?: TemplateWorkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateWorks to fetch.
     */
    orderBy?: Enumerable<TemplateWorkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateWorks.
     */
    cursor?: TemplateWorkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateWorks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateWorks.
     */
    skip?: number
    distinct?: Enumerable<TemplateWorkScalarFieldEnum>
  }


  /**
   * TemplateWork create
   */
  export type TemplateWorkCreateArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * The data needed to create a TemplateWork.
     */
    data: XOR<TemplateWorkCreateInput, TemplateWorkUncheckedCreateInput>
  }


  /**
   * TemplateWork createMany
   */
  export type TemplateWorkCreateManyArgs = {
    /**
     * The data used to create many TemplateWorks.
     */
    data: Enumerable<TemplateWorkCreateManyInput>
  }


  /**
   * TemplateWork update
   */
  export type TemplateWorkUpdateArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * The data needed to update a TemplateWork.
     */
    data: XOR<TemplateWorkUpdateInput, TemplateWorkUncheckedUpdateInput>
    /**
     * Choose, which TemplateWork to update.
     */
    where: TemplateWorkWhereUniqueInput
  }


  /**
   * TemplateWork updateMany
   */
  export type TemplateWorkUpdateManyArgs = {
    /**
     * The data used to update TemplateWorks.
     */
    data: XOR<TemplateWorkUpdateManyMutationInput, TemplateWorkUncheckedUpdateManyInput>
    /**
     * Filter which TemplateWorks to update
     */
    where?: TemplateWorkWhereInput
  }


  /**
   * TemplateWork upsert
   */
  export type TemplateWorkUpsertArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * The filter to search for the TemplateWork to update in case it exists.
     */
    where: TemplateWorkWhereUniqueInput
    /**
     * In case the TemplateWork found by the `where` argument doesn't exist, create a new TemplateWork with this data.
     */
    create: XOR<TemplateWorkCreateInput, TemplateWorkUncheckedCreateInput>
    /**
     * In case the TemplateWork was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateWorkUpdateInput, TemplateWorkUncheckedUpdateInput>
  }


  /**
   * TemplateWork delete
   */
  export type TemplateWorkDeleteArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    /**
     * Filter which TemplateWork to delete.
     */
    where: TemplateWorkWhereUniqueInput
  }


  /**
   * TemplateWork deleteMany
   */
  export type TemplateWorkDeleteManyArgs = {
    /**
     * Filter which TemplateWorks to delete
     */
    where?: TemplateWorkWhereInput
  }


  /**
   * TemplateWork findRaw
   */
  export type TemplateWorkFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateWork aggregateRaw
   */
  export type TemplateWorkAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateWork.items
   */
  export type TemplateWork$itemsArgs = {
    /**
     * Select specific fields to fetch from the TemplateWorkItem
     */
    select?: TemplateWorkItemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkItemInclude | null
    where?: TemplateWorkItemWhereInput
    orderBy?: Enumerable<TemplateWorkItemOrderByWithRelationInput>
    cursor?: TemplateWorkItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateWorkItemScalarFieldEnum>
  }


  /**
   * TemplateWork.stages
   */
  export type TemplateWork$stagesArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    where?: StageWhereInput
    orderBy?: Enumerable<StageOrderByWithRelationInput>
    cursor?: StageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StageScalarFieldEnum>
  }


  /**
   * TemplateWork without action
   */
  export type TemplateWorkArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
  }



  /**
   * Model TemplateData
   */


  export type AggregateTemplateData = {
    _count: TemplateDataCountAggregateOutputType | null
    _avg: TemplateDataAvgAggregateOutputType | null
    _sum: TemplateDataSumAggregateOutputType | null
    _min: TemplateDataMinAggregateOutputType | null
    _max: TemplateDataMaxAggregateOutputType | null
  }

  export type TemplateDataAvgAggregateOutputType = {
    step: number | null
  }

  export type TemplateDataSumAggregateOutputType = {
    step: number | null
  }

  export type TemplateDataMinAggregateOutputType = {
    id: string | null
    step: number | null
    publish: boolean | null
    templateId: string | null
  }

  export type TemplateDataMaxAggregateOutputType = {
    id: string | null
    step: number | null
    publish: boolean | null
    templateId: string | null
  }

  export type TemplateDataCountAggregateOutputType = {
    id: number
    step: number
    publish: number
    templateId: number
    _all: number
  }


  export type TemplateDataAvgAggregateInputType = {
    step?: true
  }

  export type TemplateDataSumAggregateInputType = {
    step?: true
  }

  export type TemplateDataMinAggregateInputType = {
    id?: true
    step?: true
    publish?: true
    templateId?: true
  }

  export type TemplateDataMaxAggregateInputType = {
    id?: true
    step?: true
    publish?: true
    templateId?: true
  }

  export type TemplateDataCountAggregateInputType = {
    id?: true
    step?: true
    publish?: true
    templateId?: true
    _all?: true
  }

  export type TemplateDataAggregateArgs = {
    /**
     * Filter which TemplateData to aggregate.
     */
    where?: TemplateDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateData to fetch.
     */
    orderBy?: Enumerable<TemplateDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateData
    **/
    _count?: true | TemplateDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateDataMaxAggregateInputType
  }

  export type GetTemplateDataAggregateType<T extends TemplateDataAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateData[P]>
      : GetScalarType<T[P], AggregateTemplateData[P]>
  }




  export type TemplateDataGroupByArgs = {
    where?: TemplateDataWhereInput
    orderBy?: Enumerable<TemplateDataOrderByWithAggregationInput>
    by: TemplateDataScalarFieldEnum[]
    having?: TemplateDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateDataCountAggregateInputType | true
    _avg?: TemplateDataAvgAggregateInputType
    _sum?: TemplateDataSumAggregateInputType
    _min?: TemplateDataMinAggregateInputType
    _max?: TemplateDataMaxAggregateInputType
  }


  export type TemplateDataGroupByOutputType = {
    id: string
    step: number
    publish: boolean
    templateId: string
    _count: TemplateDataCountAggregateOutputType | null
    _avg: TemplateDataAvgAggregateOutputType | null
    _sum: TemplateDataSumAggregateOutputType | null
    _min: TemplateDataMinAggregateOutputType | null
    _max: TemplateDataMaxAggregateOutputType | null
  }

  type GetTemplateDataGroupByPayload<T extends TemplateDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateDataGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateDataGroupByOutputType[P]>
        }
      >
    >


  export type TemplateDataSelect = {
    id?: boolean
    step?: boolean
    publish?: boolean
    templateId?: boolean
    around?: boolean | TAroundArgs
    properties?: boolean | TPropertyArgs
    active?: boolean | TemplateArgs
    template?: boolean | TemplateArgs
    spaces?: boolean | TemplateData$spacesArgs
    works?: boolean | TemplateData$worksArgs
    deds?: boolean | TemplateData$dedsArgs
    fields?: boolean | TemplateData$fieldsArgs
    _count?: boolean | TemplateDataCountOutputTypeArgs
  }


  export type TemplateDataInclude = {
    active?: boolean | TemplateArgs
    template?: boolean | TemplateArgs
    spaces?: boolean | TemplateData$spacesArgs
    works?: boolean | TemplateData$worksArgs
    deds?: boolean | TemplateData$dedsArgs
    fields?: boolean | TemplateData$fieldsArgs
    _count?: boolean | TemplateDataCountOutputTypeArgs
  }

  export type TemplateDataGetPayload<S extends boolean | null | undefined | TemplateDataArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateData :
    S extends undefined ? never :
    S extends { include: any } & (TemplateDataArgs | TemplateDataFindManyArgs)
    ? TemplateData  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'active' ? TemplateGetPayload<S['include'][P]> | null :
        P extends 'template' ? TemplateGetPayload<S['include'][P]> :
        P extends 'spaces' ? Array < SpaceGetPayload<S['include'][P]>>  :
        P extends 'works' ? Array < TemplateWorkGetPayload<S['include'][P]>>  :
        P extends 'deds' ? Array < TemplateDEDGetPayload<S['include'][P]>>  :
        P extends 'fields' ? Array < TemplateFieldGetPayload<S['include'][P]>>  :
        P extends '_count' ? TemplateDataCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TemplateDataArgs | TemplateDataFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'around' ? TAroundGetPayload<S['select'][P]> | null :
        P extends 'properties' ? TPropertyGetPayload<S['select'][P]> :
        P extends 'active' ? TemplateGetPayload<S['select'][P]> | null :
        P extends 'template' ? TemplateGetPayload<S['select'][P]> :
        P extends 'spaces' ? Array < SpaceGetPayload<S['select'][P]>>  :
        P extends 'works' ? Array < TemplateWorkGetPayload<S['select'][P]>>  :
        P extends 'deds' ? Array < TemplateDEDGetPayload<S['select'][P]>>  :
        P extends 'fields' ? Array < TemplateFieldGetPayload<S['select'][P]>>  :
        P extends '_count' ? TemplateDataCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof TemplateData ? TemplateData[P] : never
  } 
      : TemplateData


  type TemplateDataCountArgs = 
    Omit<TemplateDataFindManyArgs, 'select' | 'include'> & {
      select?: TemplateDataCountAggregateInputType | true
    }

  export interface TemplateDataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TemplateData that matches the filter.
     * @param {TemplateDataFindUniqueArgs} args - Arguments to find a TemplateData
     * @example
     * // Get one TemplateData
     * const templateData = await prisma.templateData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateDataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateDataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TemplateData'> extends True ? Prisma__TemplateDataClient<TemplateDataGetPayload<T>> : Prisma__TemplateDataClient<TemplateDataGetPayload<T> | null, null>

    /**
     * Find one TemplateData that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateDataFindUniqueOrThrowArgs} args - Arguments to find a TemplateData
     * @example
     * // Get one TemplateData
     * const templateData = await prisma.templateData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateDataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplateDataFindUniqueOrThrowArgs>
    ): Prisma__TemplateDataClient<TemplateDataGetPayload<T>>

    /**
     * Find the first TemplateData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataFindFirstArgs} args - Arguments to find a TemplateData
     * @example
     * // Get one TemplateData
     * const templateData = await prisma.templateData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateDataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateDataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TemplateData'> extends True ? Prisma__TemplateDataClient<TemplateDataGetPayload<T>> : Prisma__TemplateDataClient<TemplateDataGetPayload<T> | null, null>

    /**
     * Find the first TemplateData that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataFindFirstOrThrowArgs} args - Arguments to find a TemplateData
     * @example
     * // Get one TemplateData
     * const templateData = await prisma.templateData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateDataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplateDataFindFirstOrThrowArgs>
    ): Prisma__TemplateDataClient<TemplateDataGetPayload<T>>

    /**
     * Find zero or more TemplateData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateData
     * const templateData = await prisma.templateData.findMany()
     * 
     * // Get first 10 TemplateData
     * const templateData = await prisma.templateData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateDataWithIdOnly = await prisma.templateData.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateDataFindManyArgs>(
      args?: SelectSubset<T, TemplateDataFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplateDataGetPayload<T>>>

    /**
     * Create a TemplateData.
     * @param {TemplateDataCreateArgs} args - Arguments to create a TemplateData.
     * @example
     * // Create one TemplateData
     * const TemplateData = await prisma.templateData.create({
     *   data: {
     *     // ... data to create a TemplateData
     *   }
     * })
     * 
    **/
    create<T extends TemplateDataCreateArgs>(
      args: SelectSubset<T, TemplateDataCreateArgs>
    ): Prisma__TemplateDataClient<TemplateDataGetPayload<T>>

    /**
     * Create many TemplateData.
     *     @param {TemplateDataCreateManyArgs} args - Arguments to create many TemplateData.
     *     @example
     *     // Create many TemplateData
     *     const templateData = await prisma.templateData.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateDataCreateManyArgs>(
      args?: SelectSubset<T, TemplateDataCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateData.
     * @param {TemplateDataDeleteArgs} args - Arguments to delete one TemplateData.
     * @example
     * // Delete one TemplateData
     * const TemplateData = await prisma.templateData.delete({
     *   where: {
     *     // ... filter to delete one TemplateData
     *   }
     * })
     * 
    **/
    delete<T extends TemplateDataDeleteArgs>(
      args: SelectSubset<T, TemplateDataDeleteArgs>
    ): Prisma__TemplateDataClient<TemplateDataGetPayload<T>>

    /**
     * Update one TemplateData.
     * @param {TemplateDataUpdateArgs} args - Arguments to update one TemplateData.
     * @example
     * // Update one TemplateData
     * const templateData = await prisma.templateData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateDataUpdateArgs>(
      args: SelectSubset<T, TemplateDataUpdateArgs>
    ): Prisma__TemplateDataClient<TemplateDataGetPayload<T>>

    /**
     * Delete zero or more TemplateData.
     * @param {TemplateDataDeleteManyArgs} args - Arguments to filter TemplateData to delete.
     * @example
     * // Delete a few TemplateData
     * const { count } = await prisma.templateData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateDataDeleteManyArgs>(
      args?: SelectSubset<T, TemplateDataDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateData
     * const templateData = await prisma.templateData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateDataUpdateManyArgs>(
      args: SelectSubset<T, TemplateDataUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateData.
     * @param {TemplateDataUpsertArgs} args - Arguments to update or create a TemplateData.
     * @example
     * // Update or create a TemplateData
     * const templateData = await prisma.templateData.upsert({
     *   create: {
     *     // ... data to create a TemplateData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateData we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateDataUpsertArgs>(
      args: SelectSubset<T, TemplateDataUpsertArgs>
    ): Prisma__TemplateDataClient<TemplateDataGetPayload<T>>

    /**
     * Find zero or more TemplateData that matches the filter.
     * @param {TemplateDataFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const templateData = await prisma.templateData.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemplateDataFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TemplateData.
     * @param {TemplateDataAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const templateData = await prisma.templateData.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemplateDataAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TemplateData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataCountArgs} args - Arguments to filter TemplateData to count.
     * @example
     * // Count the number of TemplateData
     * const count = await prisma.templateData.count({
     *   where: {
     *     // ... the filter for the TemplateData we want to count
     *   }
     * })
    **/
    count<T extends TemplateDataCountArgs>(
      args?: Subset<T, TemplateDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateDataAggregateArgs>(args: Subset<T, TemplateDataAggregateArgs>): Prisma.PrismaPromise<GetTemplateDataAggregateType<T>>

    /**
     * Group by TemplateData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateDataGroupByArgs['orderBy'] }
        : { orderBy?: TemplateDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateDataClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    around<T extends TAroundArgs= {}>(args?: Subset<T, TAroundArgs>): Prisma__TAroundClient<TAroundGetPayload<T> | Null>;

    properties<T extends TPropertyArgs= {}>(args?: Subset<T, TPropertyArgs>): Prisma__TPropertyClient<TPropertyGetPayload<T> | Null>;

    active<T extends TemplateArgs= {}>(args?: Subset<T, TemplateArgs>): Prisma__TemplateClient<TemplateGetPayload<T> | Null>;

    template<T extends TemplateArgs= {}>(args?: Subset<T, TemplateArgs>): Prisma__TemplateClient<TemplateGetPayload<T> | Null>;

    spaces<T extends TemplateData$spacesArgs= {}>(args?: Subset<T, TemplateData$spacesArgs>): Prisma.PrismaPromise<Array<SpaceGetPayload<T>>| Null>;

    works<T extends TemplateData$worksArgs= {}>(args?: Subset<T, TemplateData$worksArgs>): Prisma.PrismaPromise<Array<TemplateWorkGetPayload<T>>| Null>;

    deds<T extends TemplateData$dedsArgs= {}>(args?: Subset<T, TemplateData$dedsArgs>): Prisma.PrismaPromise<Array<TemplateDEDGetPayload<T>>| Null>;

    fields<T extends TemplateData$fieldsArgs= {}>(args?: Subset<T, TemplateData$fieldsArgs>): Prisma.PrismaPromise<Array<TemplateFieldGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TemplateData base type for findUnique actions
   */
  export type TemplateDataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * Filter, which TemplateData to fetch.
     */
    where: TemplateDataWhereUniqueInput
  }

  /**
   * TemplateData findUnique
   */
  export interface TemplateDataFindUniqueArgs extends TemplateDataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateData findUniqueOrThrow
   */
  export type TemplateDataFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * Filter, which TemplateData to fetch.
     */
    where: TemplateDataWhereUniqueInput
  }


  /**
   * TemplateData base type for findFirst actions
   */
  export type TemplateDataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * Filter, which TemplateData to fetch.
     */
    where?: TemplateDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateData to fetch.
     */
    orderBy?: Enumerable<TemplateDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateData.
     */
    cursor?: TemplateDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateData.
     */
    distinct?: Enumerable<TemplateDataScalarFieldEnum>
  }

  /**
   * TemplateData findFirst
   */
  export interface TemplateDataFindFirstArgs extends TemplateDataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateData findFirstOrThrow
   */
  export type TemplateDataFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * Filter, which TemplateData to fetch.
     */
    where?: TemplateDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateData to fetch.
     */
    orderBy?: Enumerable<TemplateDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateData.
     */
    cursor?: TemplateDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateData.
     */
    distinct?: Enumerable<TemplateDataScalarFieldEnum>
  }


  /**
   * TemplateData findMany
   */
  export type TemplateDataFindManyArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * Filter, which TemplateData to fetch.
     */
    where?: TemplateDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateData to fetch.
     */
    orderBy?: Enumerable<TemplateDataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateData.
     */
    cursor?: TemplateDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateData.
     */
    skip?: number
    distinct?: Enumerable<TemplateDataScalarFieldEnum>
  }


  /**
   * TemplateData create
   */
  export type TemplateDataCreateArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * The data needed to create a TemplateData.
     */
    data: XOR<TemplateDataCreateInput, TemplateDataUncheckedCreateInput>
  }


  /**
   * TemplateData createMany
   */
  export type TemplateDataCreateManyArgs = {
    /**
     * The data used to create many TemplateData.
     */
    data: Enumerable<TemplateDataCreateManyInput>
  }


  /**
   * TemplateData update
   */
  export type TemplateDataUpdateArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * The data needed to update a TemplateData.
     */
    data: XOR<TemplateDataUpdateInput, TemplateDataUncheckedUpdateInput>
    /**
     * Choose, which TemplateData to update.
     */
    where: TemplateDataWhereUniqueInput
  }


  /**
   * TemplateData updateMany
   */
  export type TemplateDataUpdateManyArgs = {
    /**
     * The data used to update TemplateData.
     */
    data: XOR<TemplateDataUpdateManyMutationInput, TemplateDataUncheckedUpdateManyInput>
    /**
     * Filter which TemplateData to update
     */
    where?: TemplateDataWhereInput
  }


  /**
   * TemplateData upsert
   */
  export type TemplateDataUpsertArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * The filter to search for the TemplateData to update in case it exists.
     */
    where: TemplateDataWhereUniqueInput
    /**
     * In case the TemplateData found by the `where` argument doesn't exist, create a new TemplateData with this data.
     */
    create: XOR<TemplateDataCreateInput, TemplateDataUncheckedCreateInput>
    /**
     * In case the TemplateData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateDataUpdateInput, TemplateDataUncheckedUpdateInput>
  }


  /**
   * TemplateData delete
   */
  export type TemplateDataDeleteArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
    /**
     * Filter which TemplateData to delete.
     */
    where: TemplateDataWhereUniqueInput
  }


  /**
   * TemplateData deleteMany
   */
  export type TemplateDataDeleteManyArgs = {
    /**
     * Filter which TemplateData to delete
     */
    where?: TemplateDataWhereInput
  }


  /**
   * TemplateData findRaw
   */
  export type TemplateDataFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateData aggregateRaw
   */
  export type TemplateDataAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateData.spaces
   */
  export type TemplateData$spacesArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    where?: SpaceWhereInput
    orderBy?: Enumerable<SpaceOrderByWithRelationInput>
    cursor?: SpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SpaceScalarFieldEnum>
  }


  /**
   * TemplateData.works
   */
  export type TemplateData$worksArgs = {
    /**
     * Select specific fields to fetch from the TemplateWork
     */
    select?: TemplateWorkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateWorkInclude | null
    where?: TemplateWorkWhereInput
    orderBy?: Enumerable<TemplateWorkOrderByWithRelationInput>
    cursor?: TemplateWorkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateWorkScalarFieldEnum>
  }


  /**
   * TemplateData.deds
   */
  export type TemplateData$dedsArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    where?: TemplateDEDWhereInput
    orderBy?: Enumerable<TemplateDEDOrderByWithRelationInput>
    cursor?: TemplateDEDWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateDEDScalarFieldEnum>
  }


  /**
   * TemplateData.fields
   */
  export type TemplateData$fieldsArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    where?: TemplateFieldWhereInput
    orderBy?: Enumerable<TemplateFieldOrderByWithRelationInput>
    cursor?: TemplateFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateFieldScalarFieldEnum>
  }


  /**
   * TemplateData without action
   */
  export type TemplateDataArgs = {
    /**
     * Select specific fields to fetch from the TemplateData
     */
    select?: TemplateDataSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDataInclude | null
  }



  /**
   * Model TemplateField
   */


  export type AggregateTemplateField = {
    _count: TemplateFieldCountAggregateOutputType | null
    _min: TemplateFieldMinAggregateOutputType | null
    _max: TemplateFieldMaxAggregateOutputType | null
  }

  export type TemplateFieldMinAggregateOutputType = {
    id: string | null
    dataId: string | null
    name: string | null
    imageId: string | null
    imageUrl: string | null
  }

  export type TemplateFieldMaxAggregateOutputType = {
    id: string | null
    dataId: string | null
    name: string | null
    imageId: string | null
    imageUrl: string | null
  }

  export type TemplateFieldCountAggregateOutputType = {
    id: number
    dataId: number
    name: number
    imageId: number
    imageUrl: number
    _all: number
  }


  export type TemplateFieldMinAggregateInputType = {
    id?: true
    dataId?: true
    name?: true
    imageId?: true
    imageUrl?: true
  }

  export type TemplateFieldMaxAggregateInputType = {
    id?: true
    dataId?: true
    name?: true
    imageId?: true
    imageUrl?: true
  }

  export type TemplateFieldCountAggregateInputType = {
    id?: true
    dataId?: true
    name?: true
    imageId?: true
    imageUrl?: true
    _all?: true
  }

  export type TemplateFieldAggregateArgs = {
    /**
     * Filter which TemplateField to aggregate.
     */
    where?: TemplateFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFields to fetch.
     */
    orderBy?: Enumerable<TemplateFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateFields
    **/
    _count?: true | TemplateFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateFieldMaxAggregateInputType
  }

  export type GetTemplateFieldAggregateType<T extends TemplateFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateField[P]>
      : GetScalarType<T[P], AggregateTemplateField[P]>
  }




  export type TemplateFieldGroupByArgs = {
    where?: TemplateFieldWhereInput
    orderBy?: Enumerable<TemplateFieldOrderByWithAggregationInput>
    by: TemplateFieldScalarFieldEnum[]
    having?: TemplateFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateFieldCountAggregateInputType | true
    _min?: TemplateFieldMinAggregateInputType
    _max?: TemplateFieldMaxAggregateInputType
  }


  export type TemplateFieldGroupByOutputType = {
    id: string
    dataId: string
    name: string
    imageId: string | null
    imageUrl: string | null
    _count: TemplateFieldCountAggregateOutputType | null
    _min: TemplateFieldMinAggregateOutputType | null
    _max: TemplateFieldMaxAggregateOutputType | null
  }

  type GetTemplateFieldGroupByPayload<T extends TemplateFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateFieldGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateFieldGroupByOutputType[P]>
        }
      >
    >


  export type TemplateFieldSelect = {
    id?: boolean
    dataId?: boolean
    name?: boolean
    imageId?: boolean
    imageUrl?: boolean
    lists?: boolean | TFieldListArgs
    data?: boolean | TemplateDataArgs
    image?: boolean | FileArgs
  }


  export type TemplateFieldInclude = {
    data?: boolean | TemplateDataArgs
    image?: boolean | FileArgs
  }

  export type TemplateFieldGetPayload<S extends boolean | null | undefined | TemplateFieldArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateField :
    S extends undefined ? never :
    S extends { include: any } & (TemplateFieldArgs | TemplateFieldFindManyArgs)
    ? TemplateField  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'data' ? TemplateDataGetPayload<S['include'][P]> :
        P extends 'image' ? FileGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (TemplateFieldArgs | TemplateFieldFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'lists' ? Array < TFieldListGetPayload<S['select'][P]>>  :
        P extends 'data' ? TemplateDataGetPayload<S['select'][P]> :
        P extends 'image' ? FileGetPayload<S['select'][P]> | null :  P extends keyof TemplateField ? TemplateField[P] : never
  } 
      : TemplateField


  type TemplateFieldCountArgs = 
    Omit<TemplateFieldFindManyArgs, 'select' | 'include'> & {
      select?: TemplateFieldCountAggregateInputType | true
    }

  export interface TemplateFieldDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TemplateField that matches the filter.
     * @param {TemplateFieldFindUniqueArgs} args - Arguments to find a TemplateField
     * @example
     * // Get one TemplateField
     * const templateField = await prisma.templateField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateFieldFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateFieldFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TemplateField'> extends True ? Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>> : Prisma__TemplateFieldClient<TemplateFieldGetPayload<T> | null, null>

    /**
     * Find one TemplateField that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateFieldFindUniqueOrThrowArgs} args - Arguments to find a TemplateField
     * @example
     * // Get one TemplateField
     * const templateField = await prisma.templateField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateFieldFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplateFieldFindUniqueOrThrowArgs>
    ): Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>>

    /**
     * Find the first TemplateField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldFindFirstArgs} args - Arguments to find a TemplateField
     * @example
     * // Get one TemplateField
     * const templateField = await prisma.templateField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateFieldFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateFieldFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TemplateField'> extends True ? Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>> : Prisma__TemplateFieldClient<TemplateFieldGetPayload<T> | null, null>

    /**
     * Find the first TemplateField that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldFindFirstOrThrowArgs} args - Arguments to find a TemplateField
     * @example
     * // Get one TemplateField
     * const templateField = await prisma.templateField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateFieldFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplateFieldFindFirstOrThrowArgs>
    ): Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>>

    /**
     * Find zero or more TemplateFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateFields
     * const templateFields = await prisma.templateField.findMany()
     * 
     * // Get first 10 TemplateFields
     * const templateFields = await prisma.templateField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateFieldWithIdOnly = await prisma.templateField.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateFieldFindManyArgs>(
      args?: SelectSubset<T, TemplateFieldFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplateFieldGetPayload<T>>>

    /**
     * Create a TemplateField.
     * @param {TemplateFieldCreateArgs} args - Arguments to create a TemplateField.
     * @example
     * // Create one TemplateField
     * const TemplateField = await prisma.templateField.create({
     *   data: {
     *     // ... data to create a TemplateField
     *   }
     * })
     * 
    **/
    create<T extends TemplateFieldCreateArgs>(
      args: SelectSubset<T, TemplateFieldCreateArgs>
    ): Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>>

    /**
     * Create many TemplateFields.
     *     @param {TemplateFieldCreateManyArgs} args - Arguments to create many TemplateFields.
     *     @example
     *     // Create many TemplateFields
     *     const templateField = await prisma.templateField.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateFieldCreateManyArgs>(
      args?: SelectSubset<T, TemplateFieldCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateField.
     * @param {TemplateFieldDeleteArgs} args - Arguments to delete one TemplateField.
     * @example
     * // Delete one TemplateField
     * const TemplateField = await prisma.templateField.delete({
     *   where: {
     *     // ... filter to delete one TemplateField
     *   }
     * })
     * 
    **/
    delete<T extends TemplateFieldDeleteArgs>(
      args: SelectSubset<T, TemplateFieldDeleteArgs>
    ): Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>>

    /**
     * Update one TemplateField.
     * @param {TemplateFieldUpdateArgs} args - Arguments to update one TemplateField.
     * @example
     * // Update one TemplateField
     * const templateField = await prisma.templateField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateFieldUpdateArgs>(
      args: SelectSubset<T, TemplateFieldUpdateArgs>
    ): Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>>

    /**
     * Delete zero or more TemplateFields.
     * @param {TemplateFieldDeleteManyArgs} args - Arguments to filter TemplateFields to delete.
     * @example
     * // Delete a few TemplateFields
     * const { count } = await prisma.templateField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateFieldDeleteManyArgs>(
      args?: SelectSubset<T, TemplateFieldDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateFields
     * const templateField = await prisma.templateField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateFieldUpdateManyArgs>(
      args: SelectSubset<T, TemplateFieldUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateField.
     * @param {TemplateFieldUpsertArgs} args - Arguments to update or create a TemplateField.
     * @example
     * // Update or create a TemplateField
     * const templateField = await prisma.templateField.upsert({
     *   create: {
     *     // ... data to create a TemplateField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateField we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateFieldUpsertArgs>(
      args: SelectSubset<T, TemplateFieldUpsertArgs>
    ): Prisma__TemplateFieldClient<TemplateFieldGetPayload<T>>

    /**
     * Find zero or more TemplateFields that matches the filter.
     * @param {TemplateFieldFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const templateField = await prisma.templateField.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemplateFieldFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TemplateField.
     * @param {TemplateFieldAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const templateField = await prisma.templateField.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemplateFieldAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TemplateFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldCountArgs} args - Arguments to filter TemplateFields to count.
     * @example
     * // Count the number of TemplateFields
     * const count = await prisma.templateField.count({
     *   where: {
     *     // ... the filter for the TemplateFields we want to count
     *   }
     * })
    **/
    count<T extends TemplateFieldCountArgs>(
      args?: Subset<T, TemplateFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateFieldAggregateArgs>(args: Subset<T, TemplateFieldAggregateArgs>): Prisma.PrismaPromise<GetTemplateFieldAggregateType<T>>

    /**
     * Group by TemplateField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateFieldGroupByArgs['orderBy'] }
        : { orderBy?: TemplateFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateFieldClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    lists<T extends TFieldListArgs= {}>(args?: Subset<T, TFieldListArgs>): Prisma.PrismaPromise<Array<TFieldListGetPayload<T>>| Null>;

    data<T extends TemplateDataArgs= {}>(args?: Subset<T, TemplateDataArgs>): Prisma__TemplateDataClient<TemplateDataGetPayload<T> | Null>;

    image<T extends FileArgs= {}>(args?: Subset<T, FileArgs>): Prisma__FileClient<FileGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TemplateField base type for findUnique actions
   */
  export type TemplateFieldFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * Filter, which TemplateField to fetch.
     */
    where: TemplateFieldWhereUniqueInput
  }

  /**
   * TemplateField findUnique
   */
  export interface TemplateFieldFindUniqueArgs extends TemplateFieldFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateField findUniqueOrThrow
   */
  export type TemplateFieldFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * Filter, which TemplateField to fetch.
     */
    where: TemplateFieldWhereUniqueInput
  }


  /**
   * TemplateField base type for findFirst actions
   */
  export type TemplateFieldFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * Filter, which TemplateField to fetch.
     */
    where?: TemplateFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFields to fetch.
     */
    orderBy?: Enumerable<TemplateFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateFields.
     */
    cursor?: TemplateFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateFields.
     */
    distinct?: Enumerable<TemplateFieldScalarFieldEnum>
  }

  /**
   * TemplateField findFirst
   */
  export interface TemplateFieldFindFirstArgs extends TemplateFieldFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateField findFirstOrThrow
   */
  export type TemplateFieldFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * Filter, which TemplateField to fetch.
     */
    where?: TemplateFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFields to fetch.
     */
    orderBy?: Enumerable<TemplateFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateFields.
     */
    cursor?: TemplateFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateFields.
     */
    distinct?: Enumerable<TemplateFieldScalarFieldEnum>
  }


  /**
   * TemplateField findMany
   */
  export type TemplateFieldFindManyArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * Filter, which TemplateFields to fetch.
     */
    where?: TemplateFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateFields to fetch.
     */
    orderBy?: Enumerable<TemplateFieldOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateFields.
     */
    cursor?: TemplateFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateFields.
     */
    skip?: number
    distinct?: Enumerable<TemplateFieldScalarFieldEnum>
  }


  /**
   * TemplateField create
   */
  export type TemplateFieldCreateArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * The data needed to create a TemplateField.
     */
    data: XOR<TemplateFieldCreateInput, TemplateFieldUncheckedCreateInput>
  }


  /**
   * TemplateField createMany
   */
  export type TemplateFieldCreateManyArgs = {
    /**
     * The data used to create many TemplateFields.
     */
    data: Enumerable<TemplateFieldCreateManyInput>
  }


  /**
   * TemplateField update
   */
  export type TemplateFieldUpdateArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * The data needed to update a TemplateField.
     */
    data: XOR<TemplateFieldUpdateInput, TemplateFieldUncheckedUpdateInput>
    /**
     * Choose, which TemplateField to update.
     */
    where: TemplateFieldWhereUniqueInput
  }


  /**
   * TemplateField updateMany
   */
  export type TemplateFieldUpdateManyArgs = {
    /**
     * The data used to update TemplateFields.
     */
    data: XOR<TemplateFieldUpdateManyMutationInput, TemplateFieldUncheckedUpdateManyInput>
    /**
     * Filter which TemplateFields to update
     */
    where?: TemplateFieldWhereInput
  }


  /**
   * TemplateField upsert
   */
  export type TemplateFieldUpsertArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * The filter to search for the TemplateField to update in case it exists.
     */
    where: TemplateFieldWhereUniqueInput
    /**
     * In case the TemplateField found by the `where` argument doesn't exist, create a new TemplateField with this data.
     */
    create: XOR<TemplateFieldCreateInput, TemplateFieldUncheckedCreateInput>
    /**
     * In case the TemplateField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateFieldUpdateInput, TemplateFieldUncheckedUpdateInput>
  }


  /**
   * TemplateField delete
   */
  export type TemplateFieldDeleteArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
    /**
     * Filter which TemplateField to delete.
     */
    where: TemplateFieldWhereUniqueInput
  }


  /**
   * TemplateField deleteMany
   */
  export type TemplateFieldDeleteManyArgs = {
    /**
     * Filter which TemplateFields to delete
     */
    where?: TemplateFieldWhereInput
  }


  /**
   * TemplateField findRaw
   */
  export type TemplateFieldFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateField aggregateRaw
   */
  export type TemplateFieldAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateField without action
   */
  export type TemplateFieldArgs = {
    /**
     * Select specific fields to fetch from the TemplateField
     */
    select?: TemplateFieldSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateFieldInclude | null
  }



  /**
   * Model TemplateDED
   */


  export type AggregateTemplateDED = {
    _count: TemplateDEDCountAggregateOutputType | null
    _min: TemplateDEDMinAggregateOutputType | null
    _max: TemplateDEDMaxAggregateOutputType | null
  }

  export type TemplateDEDMinAggregateOutputType = {
    id: string | null
    dataId: string | null
    name: string | null
  }

  export type TemplateDEDMaxAggregateOutputType = {
    id: string | null
    dataId: string | null
    name: string | null
  }

  export type TemplateDEDCountAggregateOutputType = {
    id: number
    dataId: number
    name: number
    _all: number
  }


  export type TemplateDEDMinAggregateInputType = {
    id?: true
    dataId?: true
    name?: true
  }

  export type TemplateDEDMaxAggregateInputType = {
    id?: true
    dataId?: true
    name?: true
  }

  export type TemplateDEDCountAggregateInputType = {
    id?: true
    dataId?: true
    name?: true
    _all?: true
  }

  export type TemplateDEDAggregateArgs = {
    /**
     * Filter which TemplateDED to aggregate.
     */
    where?: TemplateDEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDEDS to fetch.
     */
    orderBy?: Enumerable<TemplateDEDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateDEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDEDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateDEDS
    **/
    _count?: true | TemplateDEDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateDEDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateDEDMaxAggregateInputType
  }

  export type GetTemplateDEDAggregateType<T extends TemplateDEDAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateDED]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateDED[P]>
      : GetScalarType<T[P], AggregateTemplateDED[P]>
  }




  export type TemplateDEDGroupByArgs = {
    where?: TemplateDEDWhereInput
    orderBy?: Enumerable<TemplateDEDOrderByWithAggregationInput>
    by: TemplateDEDScalarFieldEnum[]
    having?: TemplateDEDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateDEDCountAggregateInputType | true
    _min?: TemplateDEDMinAggregateInputType
    _max?: TemplateDEDMaxAggregateInputType
  }


  export type TemplateDEDGroupByOutputType = {
    id: string
    dataId: string
    name: string
    _count: TemplateDEDCountAggregateOutputType | null
    _min: TemplateDEDMinAggregateOutputType | null
    _max: TemplateDEDMaxAggregateOutputType | null
  }

  type GetTemplateDEDGroupByPayload<T extends TemplateDEDGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateDEDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateDEDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateDEDGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateDEDGroupByOutputType[P]>
        }
      >
    >


  export type TemplateDEDSelect = {
    id?: boolean
    dataId?: boolean
    name?: boolean
    lists?: boolean | TDeDListArgs
    data?: boolean | TemplateDataArgs
  }


  export type TemplateDEDInclude = {
    data?: boolean | TemplateDataArgs
  }

  export type TemplateDEDGetPayload<S extends boolean | null | undefined | TemplateDEDArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TemplateDED :
    S extends undefined ? never :
    S extends { include: any } & (TemplateDEDArgs | TemplateDEDFindManyArgs)
    ? TemplateDED  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'data' ? TemplateDataGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TemplateDEDArgs | TemplateDEDFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'lists' ? Array < TDeDListGetPayload<S['select'][P]>>  :
        P extends 'data' ? TemplateDataGetPayload<S['select'][P]> :  P extends keyof TemplateDED ? TemplateDED[P] : never
  } 
      : TemplateDED


  type TemplateDEDCountArgs = 
    Omit<TemplateDEDFindManyArgs, 'select' | 'include'> & {
      select?: TemplateDEDCountAggregateInputType | true
    }

  export interface TemplateDEDDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one TemplateDED that matches the filter.
     * @param {TemplateDEDFindUniqueArgs} args - Arguments to find a TemplateDED
     * @example
     * // Get one TemplateDED
     * const templateDED = await prisma.templateDED.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateDEDFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateDEDFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TemplateDED'> extends True ? Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>> : Prisma__TemplateDEDClient<TemplateDEDGetPayload<T> | null, null>

    /**
     * Find one TemplateDED that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateDEDFindUniqueOrThrowArgs} args - Arguments to find a TemplateDED
     * @example
     * // Get one TemplateDED
     * const templateDED = await prisma.templateDED.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateDEDFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TemplateDEDFindUniqueOrThrowArgs>
    ): Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>>

    /**
     * Find the first TemplateDED that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDFindFirstArgs} args - Arguments to find a TemplateDED
     * @example
     * // Get one TemplateDED
     * const templateDED = await prisma.templateDED.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateDEDFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateDEDFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TemplateDED'> extends True ? Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>> : Prisma__TemplateDEDClient<TemplateDEDGetPayload<T> | null, null>

    /**
     * Find the first TemplateDED that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDFindFirstOrThrowArgs} args - Arguments to find a TemplateDED
     * @example
     * // Get one TemplateDED
     * const templateDED = await prisma.templateDED.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateDEDFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TemplateDEDFindFirstOrThrowArgs>
    ): Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>>

    /**
     * Find zero or more TemplateDEDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateDEDS
     * const templateDEDS = await prisma.templateDED.findMany()
     * 
     * // Get first 10 TemplateDEDS
     * const templateDEDS = await prisma.templateDED.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateDEDWithIdOnly = await prisma.templateDED.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateDEDFindManyArgs>(
      args?: SelectSubset<T, TemplateDEDFindManyArgs>
    ): Prisma.PrismaPromise<Array<TemplateDEDGetPayload<T>>>

    /**
     * Create a TemplateDED.
     * @param {TemplateDEDCreateArgs} args - Arguments to create a TemplateDED.
     * @example
     * // Create one TemplateDED
     * const TemplateDED = await prisma.templateDED.create({
     *   data: {
     *     // ... data to create a TemplateDED
     *   }
     * })
     * 
    **/
    create<T extends TemplateDEDCreateArgs>(
      args: SelectSubset<T, TemplateDEDCreateArgs>
    ): Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>>

    /**
     * Create many TemplateDEDS.
     *     @param {TemplateDEDCreateManyArgs} args - Arguments to create many TemplateDEDS.
     *     @example
     *     // Create many TemplateDEDS
     *     const templateDED = await prisma.templateDED.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateDEDCreateManyArgs>(
      args?: SelectSubset<T, TemplateDEDCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TemplateDED.
     * @param {TemplateDEDDeleteArgs} args - Arguments to delete one TemplateDED.
     * @example
     * // Delete one TemplateDED
     * const TemplateDED = await prisma.templateDED.delete({
     *   where: {
     *     // ... filter to delete one TemplateDED
     *   }
     * })
     * 
    **/
    delete<T extends TemplateDEDDeleteArgs>(
      args: SelectSubset<T, TemplateDEDDeleteArgs>
    ): Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>>

    /**
     * Update one TemplateDED.
     * @param {TemplateDEDUpdateArgs} args - Arguments to update one TemplateDED.
     * @example
     * // Update one TemplateDED
     * const templateDED = await prisma.templateDED.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateDEDUpdateArgs>(
      args: SelectSubset<T, TemplateDEDUpdateArgs>
    ): Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>>

    /**
     * Delete zero or more TemplateDEDS.
     * @param {TemplateDEDDeleteManyArgs} args - Arguments to filter TemplateDEDS to delete.
     * @example
     * // Delete a few TemplateDEDS
     * const { count } = await prisma.templateDED.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateDEDDeleteManyArgs>(
      args?: SelectSubset<T, TemplateDEDDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateDEDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateDEDS
     * const templateDED = await prisma.templateDED.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateDEDUpdateManyArgs>(
      args: SelectSubset<T, TemplateDEDUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TemplateDED.
     * @param {TemplateDEDUpsertArgs} args - Arguments to update or create a TemplateDED.
     * @example
     * // Update or create a TemplateDED
     * const templateDED = await prisma.templateDED.upsert({
     *   create: {
     *     // ... data to create a TemplateDED
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateDED we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateDEDUpsertArgs>(
      args: SelectSubset<T, TemplateDEDUpsertArgs>
    ): Prisma__TemplateDEDClient<TemplateDEDGetPayload<T>>

    /**
     * Find zero or more TemplateDEDS that matches the filter.
     * @param {TemplateDEDFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const templateDED = await prisma.templateDED.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TemplateDEDFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TemplateDED.
     * @param {TemplateDEDAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const templateDED = await prisma.templateDED.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TemplateDEDAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TemplateDEDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDCountArgs} args - Arguments to filter TemplateDEDS to count.
     * @example
     * // Count the number of TemplateDEDS
     * const count = await prisma.templateDED.count({
     *   where: {
     *     // ... the filter for the TemplateDEDS we want to count
     *   }
     * })
    **/
    count<T extends TemplateDEDCountArgs>(
      args?: Subset<T, TemplateDEDCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateDEDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateDED.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateDEDAggregateArgs>(args: Subset<T, TemplateDEDAggregateArgs>): Prisma.PrismaPromise<GetTemplateDEDAggregateType<T>>

    /**
     * Group by TemplateDED.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateDEDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateDEDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateDEDGroupByArgs['orderBy'] }
        : { orderBy?: TemplateDEDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateDEDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateDEDGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateDED.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateDEDClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    lists<T extends TDeDListArgs= {}>(args?: Subset<T, TDeDListArgs>): Prisma.PrismaPromise<Array<TDeDListGetPayload<T>>| Null>;

    data<T extends TemplateDataArgs= {}>(args?: Subset<T, TemplateDataArgs>): Prisma__TemplateDataClient<TemplateDataGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * TemplateDED base type for findUnique actions
   */
  export type TemplateDEDFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * Filter, which TemplateDED to fetch.
     */
    where: TemplateDEDWhereUniqueInput
  }

  /**
   * TemplateDED findUnique
   */
  export interface TemplateDEDFindUniqueArgs extends TemplateDEDFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateDED findUniqueOrThrow
   */
  export type TemplateDEDFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * Filter, which TemplateDED to fetch.
     */
    where: TemplateDEDWhereUniqueInput
  }


  /**
   * TemplateDED base type for findFirst actions
   */
  export type TemplateDEDFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * Filter, which TemplateDED to fetch.
     */
    where?: TemplateDEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDEDS to fetch.
     */
    orderBy?: Enumerable<TemplateDEDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateDEDS.
     */
    cursor?: TemplateDEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDEDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateDEDS.
     */
    distinct?: Enumerable<TemplateDEDScalarFieldEnum>
  }

  /**
   * TemplateDED findFirst
   */
  export interface TemplateDEDFindFirstArgs extends TemplateDEDFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * TemplateDED findFirstOrThrow
   */
  export type TemplateDEDFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * Filter, which TemplateDED to fetch.
     */
    where?: TemplateDEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDEDS to fetch.
     */
    orderBy?: Enumerable<TemplateDEDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateDEDS.
     */
    cursor?: TemplateDEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDEDS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateDEDS.
     */
    distinct?: Enumerable<TemplateDEDScalarFieldEnum>
  }


  /**
   * TemplateDED findMany
   */
  export type TemplateDEDFindManyArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * Filter, which TemplateDEDS to fetch.
     */
    where?: TemplateDEDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateDEDS to fetch.
     */
    orderBy?: Enumerable<TemplateDEDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateDEDS.
     */
    cursor?: TemplateDEDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateDEDS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateDEDS.
     */
    skip?: number
    distinct?: Enumerable<TemplateDEDScalarFieldEnum>
  }


  /**
   * TemplateDED create
   */
  export type TemplateDEDCreateArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * The data needed to create a TemplateDED.
     */
    data: XOR<TemplateDEDCreateInput, TemplateDEDUncheckedCreateInput>
  }


  /**
   * TemplateDED createMany
   */
  export type TemplateDEDCreateManyArgs = {
    /**
     * The data used to create many TemplateDEDS.
     */
    data: Enumerable<TemplateDEDCreateManyInput>
  }


  /**
   * TemplateDED update
   */
  export type TemplateDEDUpdateArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * The data needed to update a TemplateDED.
     */
    data: XOR<TemplateDEDUpdateInput, TemplateDEDUncheckedUpdateInput>
    /**
     * Choose, which TemplateDED to update.
     */
    where: TemplateDEDWhereUniqueInput
  }


  /**
   * TemplateDED updateMany
   */
  export type TemplateDEDUpdateManyArgs = {
    /**
     * The data used to update TemplateDEDS.
     */
    data: XOR<TemplateDEDUpdateManyMutationInput, TemplateDEDUncheckedUpdateManyInput>
    /**
     * Filter which TemplateDEDS to update
     */
    where?: TemplateDEDWhereInput
  }


  /**
   * TemplateDED upsert
   */
  export type TemplateDEDUpsertArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * The filter to search for the TemplateDED to update in case it exists.
     */
    where: TemplateDEDWhereUniqueInput
    /**
     * In case the TemplateDED found by the `where` argument doesn't exist, create a new TemplateDED with this data.
     */
    create: XOR<TemplateDEDCreateInput, TemplateDEDUncheckedCreateInput>
    /**
     * In case the TemplateDED was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateDEDUpdateInput, TemplateDEDUncheckedUpdateInput>
  }


  /**
   * TemplateDED delete
   */
  export type TemplateDEDDeleteArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
    /**
     * Filter which TemplateDED to delete.
     */
    where: TemplateDEDWhereUniqueInput
  }


  /**
   * TemplateDED deleteMany
   */
  export type TemplateDEDDeleteManyArgs = {
    /**
     * Filter which TemplateDEDS to delete
     */
    where?: TemplateDEDWhereInput
  }


  /**
   * TemplateDED findRaw
   */
  export type TemplateDEDFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateDED aggregateRaw
   */
  export type TemplateDEDAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TemplateDED without action
   */
  export type TemplateDEDArgs = {
    /**
     * Select specific fields to fetch from the TemplateDED
     */
    select?: TemplateDEDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateDEDInclude | null
  }



  /**
   * Model Space
   */


  export type AggregateSpace = {
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  export type SpaceMinAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
  }

  export type SpaceMaxAggregateOutputType = {
    id: string | null
    refId: string | null
    name: string | null
  }

  export type SpaceCountAggregateOutputType = {
    id: number
    refId: number
    name: number
    _all: number
  }


  export type SpaceMinAggregateInputType = {
    id?: true
    refId?: true
    name?: true
  }

  export type SpaceMaxAggregateInputType = {
    id?: true
    refId?: true
    name?: true
  }

  export type SpaceCountAggregateInputType = {
    id?: true
    refId?: true
    name?: true
    _all?: true
  }

  export type SpaceAggregateArgs = {
    /**
     * Filter which Space to aggregate.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: Enumerable<SpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Spaces
    **/
    _count?: true | SpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpaceMaxAggregateInputType
  }

  export type GetSpaceAggregateType<T extends SpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpace[P]>
      : GetScalarType<T[P], AggregateSpace[P]>
  }




  export type SpaceGroupByArgs = {
    where?: SpaceWhereInput
    orderBy?: Enumerable<SpaceOrderByWithAggregationInput>
    by: SpaceScalarFieldEnum[]
    having?: SpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpaceCountAggregateInputType | true
    _min?: SpaceMinAggregateInputType
    _max?: SpaceMaxAggregateInputType
  }


  export type SpaceGroupByOutputType = {
    id: string
    refId: string
    name: string
    _count: SpaceCountAggregateOutputType | null
    _min: SpaceMinAggregateOutputType | null
    _max: SpaceMaxAggregateOutputType | null
  }

  type GetSpaceGroupByPayload<T extends SpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpaceGroupByOutputType[P]>
            : GetScalarType<T[P], SpaceGroupByOutputType[P]>
        }
      >
    >


  export type SpaceSelect = {
    id?: boolean
    refId?: boolean
    name?: boolean
    long?: boolean | SpaceValueArgs
    width?: boolean | SpaceValueArgs
    height?: boolean | SpaceValueArgs
    amount?: boolean | SpaceValueArgs
    values?: boolean | TValuesArgs
    ref?: boolean | TemplateDataArgs
  }


  export type SpaceInclude = {
    ref?: boolean | TemplateDataArgs
  }

  export type SpaceGetPayload<S extends boolean | null | undefined | SpaceArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Space :
    S extends undefined ? never :
    S extends { include: any } & (SpaceArgs | SpaceFindManyArgs)
    ? Space  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'ref' ? TemplateDataGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (SpaceArgs | SpaceFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'long' ? SpaceValueGetPayload<S['select'][P]> :
        P extends 'width' ? SpaceValueGetPayload<S['select'][P]> :
        P extends 'height' ? SpaceValueGetPayload<S['select'][P]> :
        P extends 'amount' ? SpaceValueGetPayload<S['select'][P]> :
        P extends 'values' ? TValuesGetPayload<S['select'][P]> :
        P extends 'ref' ? TemplateDataGetPayload<S['select'][P]> :  P extends keyof Space ? Space[P] : never
  } 
      : Space


  type SpaceCountArgs = 
    Omit<SpaceFindManyArgs, 'select' | 'include'> & {
      select?: SpaceCountAggregateInputType | true
    }

  export interface SpaceDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Space that matches the filter.
     * @param {SpaceFindUniqueArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpaceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpaceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Space'> extends True ? Prisma__SpaceClient<SpaceGetPayload<T>> : Prisma__SpaceClient<SpaceGetPayload<T> | null, null>

    /**
     * Find one Space that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpaceFindUniqueOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpaceFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, SpaceFindUniqueOrThrowArgs>
    ): Prisma__SpaceClient<SpaceGetPayload<T>>

    /**
     * Find the first Space that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpaceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpaceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Space'> extends True ? Prisma__SpaceClient<SpaceGetPayload<T>> : Prisma__SpaceClient<SpaceGetPayload<T> | null, null>

    /**
     * Find the first Space that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindFirstOrThrowArgs} args - Arguments to find a Space
     * @example
     * // Get one Space
     * const space = await prisma.space.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpaceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SpaceFindFirstOrThrowArgs>
    ): Prisma__SpaceClient<SpaceGetPayload<T>>

    /**
     * Find zero or more Spaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Spaces
     * const spaces = await prisma.space.findMany()
     * 
     * // Get first 10 Spaces
     * const spaces = await prisma.space.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spaceWithIdOnly = await prisma.space.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpaceFindManyArgs>(
      args?: SelectSubset<T, SpaceFindManyArgs>
    ): Prisma.PrismaPromise<Array<SpaceGetPayload<T>>>

    /**
     * Create a Space.
     * @param {SpaceCreateArgs} args - Arguments to create a Space.
     * @example
     * // Create one Space
     * const Space = await prisma.space.create({
     *   data: {
     *     // ... data to create a Space
     *   }
     * })
     * 
    **/
    create<T extends SpaceCreateArgs>(
      args: SelectSubset<T, SpaceCreateArgs>
    ): Prisma__SpaceClient<SpaceGetPayload<T>>

    /**
     * Create many Spaces.
     *     @param {SpaceCreateManyArgs} args - Arguments to create many Spaces.
     *     @example
     *     // Create many Spaces
     *     const space = await prisma.space.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpaceCreateManyArgs>(
      args?: SelectSubset<T, SpaceCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Space.
     * @param {SpaceDeleteArgs} args - Arguments to delete one Space.
     * @example
     * // Delete one Space
     * const Space = await prisma.space.delete({
     *   where: {
     *     // ... filter to delete one Space
     *   }
     * })
     * 
    **/
    delete<T extends SpaceDeleteArgs>(
      args: SelectSubset<T, SpaceDeleteArgs>
    ): Prisma__SpaceClient<SpaceGetPayload<T>>

    /**
     * Update one Space.
     * @param {SpaceUpdateArgs} args - Arguments to update one Space.
     * @example
     * // Update one Space
     * const space = await prisma.space.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpaceUpdateArgs>(
      args: SelectSubset<T, SpaceUpdateArgs>
    ): Prisma__SpaceClient<SpaceGetPayload<T>>

    /**
     * Delete zero or more Spaces.
     * @param {SpaceDeleteManyArgs} args - Arguments to filter Spaces to delete.
     * @example
     * // Delete a few Spaces
     * const { count } = await prisma.space.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpaceDeleteManyArgs>(
      args?: SelectSubset<T, SpaceDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Spaces
     * const space = await prisma.space.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpaceUpdateManyArgs>(
      args: SelectSubset<T, SpaceUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Space.
     * @param {SpaceUpsertArgs} args - Arguments to update or create a Space.
     * @example
     * // Update or create a Space
     * const space = await prisma.space.upsert({
     *   create: {
     *     // ... data to create a Space
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Space we want to update
     *   }
     * })
    **/
    upsert<T extends SpaceUpsertArgs>(
      args: SelectSubset<T, SpaceUpsertArgs>
    ): Prisma__SpaceClient<SpaceGetPayload<T>>

    /**
     * Find zero or more Spaces that matches the filter.
     * @param {SpaceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const space = await prisma.space.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SpaceFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Space.
     * @param {SpaceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const space = await prisma.space.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SpaceAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Spaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceCountArgs} args - Arguments to filter Spaces to count.
     * @example
     * // Count the number of Spaces
     * const count = await prisma.space.count({
     *   where: {
     *     // ... the filter for the Spaces we want to count
     *   }
     * })
    **/
    count<T extends SpaceCountArgs>(
      args?: Subset<T, SpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpaceAggregateArgs>(args: Subset<T, SpaceAggregateArgs>): Prisma.PrismaPromise<GetSpaceAggregateType<T>>

    /**
     * Group by Space.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpaceGroupByArgs['orderBy'] }
        : { orderBy?: SpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Space.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpaceClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    long<T extends SpaceValueArgs= {}>(args?: Subset<T, SpaceValueArgs>): Prisma__SpaceValueClient<SpaceValueGetPayload<T> | Null>;

    width<T extends SpaceValueArgs= {}>(args?: Subset<T, SpaceValueArgs>): Prisma__SpaceValueClient<SpaceValueGetPayload<T> | Null>;

    height<T extends SpaceValueArgs= {}>(args?: Subset<T, SpaceValueArgs>): Prisma__SpaceValueClient<SpaceValueGetPayload<T> | Null>;

    amount<T extends SpaceValueArgs= {}>(args?: Subset<T, SpaceValueArgs>): Prisma__SpaceValueClient<SpaceValueGetPayload<T> | Null>;

    values<T extends TValuesArgs= {}>(args?: Subset<T, TValuesArgs>): Prisma__TValuesClient<TValuesGetPayload<T> | Null>;

    ref<T extends TemplateDataArgs= {}>(args?: Subset<T, TemplateDataArgs>): Prisma__TemplateDataClient<TemplateDataGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Space base type for findUnique actions
   */
  export type SpaceFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }

  /**
   * Space findUnique
   */
  export interface SpaceFindUniqueArgs extends SpaceFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Space findUniqueOrThrow
   */
  export type SpaceFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * Filter, which Space to fetch.
     */
    where: SpaceWhereUniqueInput
  }


  /**
   * Space base type for findFirst actions
   */
  export type SpaceFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: Enumerable<SpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: Enumerable<SpaceScalarFieldEnum>
  }

  /**
   * Space findFirst
   */
  export interface SpaceFindFirstArgs extends SpaceFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Space findFirstOrThrow
   */
  export type SpaceFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * Filter, which Space to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: Enumerable<SpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Spaces.
     */
    distinct?: Enumerable<SpaceScalarFieldEnum>
  }


  /**
   * Space findMany
   */
  export type SpaceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * Filter, which Spaces to fetch.
     */
    where?: SpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Spaces to fetch.
     */
    orderBy?: Enumerable<SpaceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Spaces.
     */
    cursor?: SpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Spaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Spaces.
     */
    skip?: number
    distinct?: Enumerable<SpaceScalarFieldEnum>
  }


  /**
   * Space create
   */
  export type SpaceCreateArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * The data needed to create a Space.
     */
    data: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
  }


  /**
   * Space createMany
   */
  export type SpaceCreateManyArgs = {
    /**
     * The data used to create many Spaces.
     */
    data: Enumerable<SpaceCreateManyInput>
  }


  /**
   * Space update
   */
  export type SpaceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * The data needed to update a Space.
     */
    data: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
    /**
     * Choose, which Space to update.
     */
    where: SpaceWhereUniqueInput
  }


  /**
   * Space updateMany
   */
  export type SpaceUpdateManyArgs = {
    /**
     * The data used to update Spaces.
     */
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyInput>
    /**
     * Filter which Spaces to update
     */
    where?: SpaceWhereInput
  }


  /**
   * Space upsert
   */
  export type SpaceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * The filter to search for the Space to update in case it exists.
     */
    where: SpaceWhereUniqueInput
    /**
     * In case the Space found by the `where` argument doesn't exist, create a new Space with this data.
     */
    create: XOR<SpaceCreateInput, SpaceUncheckedCreateInput>
    /**
     * In case the Space was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpaceUpdateInput, SpaceUncheckedUpdateInput>
  }


  /**
   * Space delete
   */
  export type SpaceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
    /**
     * Filter which Space to delete.
     */
    where: SpaceWhereUniqueInput
  }


  /**
   * Space deleteMany
   */
  export type SpaceDeleteManyArgs = {
    /**
     * Filter which Spaces to delete
     */
    where?: SpaceWhereInput
  }


  /**
   * Space findRaw
   */
  export type SpaceFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Space aggregateRaw
   */
  export type SpaceAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Space without action
   */
  export type SpaceArgs = {
    /**
     * Select specific fields to fetch from the Space
     */
    select?: SpaceSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpaceInclude | null
  }



  /**
   * Model Stage
   */


  export type AggregateStage = {
    _count: StageCountAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  export type StageMinAggregateOutputType = {
    id: string | null
    workId: string | null
    type: StageType | null
    operation: StageOpr | null
    parentId: string | null
    refs: string | null
    refParent: boolean | null
    name: string | null
  }

  export type StageMaxAggregateOutputType = {
    id: string | null
    workId: string | null
    type: StageType | null
    operation: StageOpr | null
    parentId: string | null
    refs: string | null
    refParent: boolean | null
    name: string | null
  }

  export type StageCountAggregateOutputType = {
    id: number
    workId: number
    type: number
    operation: number
    parentId: number
    refs: number
    refParent: number
    name: number
    _all: number
  }


  export type StageMinAggregateInputType = {
    id?: true
    workId?: true
    type?: true
    operation?: true
    parentId?: true
    refs?: true
    refParent?: true
    name?: true
  }

  export type StageMaxAggregateInputType = {
    id?: true
    workId?: true
    type?: true
    operation?: true
    parentId?: true
    refs?: true
    refParent?: true
    name?: true
  }

  export type StageCountAggregateInputType = {
    id?: true
    workId?: true
    type?: true
    operation?: true
    parentId?: true
    refs?: true
    refParent?: true
    name?: true
    _all?: true
  }

  export type StageAggregateArgs = {
    /**
     * Filter which Stage to aggregate.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: Enumerable<StageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stages
    **/
    _count?: true | StageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageMaxAggregateInputType
  }

  export type GetStageAggregateType<T extends StageAggregateArgs> = {
        [P in keyof T & keyof AggregateStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStage[P]>
      : GetScalarType<T[P], AggregateStage[P]>
  }




  export type StageGroupByArgs = {
    where?: StageWhereInput
    orderBy?: Enumerable<StageOrderByWithAggregationInput>
    by: StageScalarFieldEnum[]
    having?: StageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageCountAggregateInputType | true
    _min?: StageMinAggregateInputType
    _max?: StageMaxAggregateInputType
  }


  export type StageGroupByOutputType = {
    id: string
    workId: string
    type: StageType
    operation: StageOpr
    parentId: string | null
    refs: string | null
    refParent: boolean | null
    name: string | null
    _count: StageCountAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  type GetStageGroupByPayload<T extends StageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageGroupByOutputType[P]>
            : GetScalarType<T[P], StageGroupByOutputType[P]>
        }
      >
    >


  export type StageSelect = {
    id?: boolean
    workId?: boolean
    type?: boolean
    operation?: boolean
    parentId?: boolean
    refs?: boolean
    refParent?: boolean
    name?: boolean
    long?: boolean | StageValueArgs
    width?: boolean | StageValueArgs
    height?: boolean | StageValueArgs
    amount?: boolean | StageValueArgs
    values?: boolean | TValuesArgs
    work?: boolean | TemplateWorkArgs
  }


  export type StageInclude = {
    work?: boolean | TemplateWorkArgs
  }

  export type StageGetPayload<S extends boolean | null | undefined | StageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Stage :
    S extends undefined ? never :
    S extends { include: any } & (StageArgs | StageFindManyArgs)
    ? Stage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'work' ? TemplateWorkGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StageArgs | StageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'long' ? StageValueGetPayload<S['select'][P]> :
        P extends 'width' ? StageValueGetPayload<S['select'][P]> :
        P extends 'height' ? StageValueGetPayload<S['select'][P]> :
        P extends 'amount' ? StageValueGetPayload<S['select'][P]> :
        P extends 'values' ? TValuesGetPayload<S['select'][P]> :
        P extends 'work' ? TemplateWorkGetPayload<S['select'][P]> :  P extends keyof Stage ? Stage[P] : never
  } 
      : Stage


  type StageCountArgs = 
    Omit<StageFindManyArgs, 'select' | 'include'> & {
      select?: StageCountAggregateInputType | true
    }

  export interface StageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Stage that matches the filter.
     * @param {StageFindUniqueArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Stage'> extends True ? Prisma__StageClient<StageGetPayload<T>> : Prisma__StageClient<StageGetPayload<T> | null, null>

    /**
     * Find one Stage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StageFindUniqueOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StageFindUniqueOrThrowArgs>
    ): Prisma__StageClient<StageGetPayload<T>>

    /**
     * Find the first Stage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Stage'> extends True ? Prisma__StageClient<StageGetPayload<T>> : Prisma__StageClient<StageGetPayload<T> | null, null>

    /**
     * Find the first Stage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StageFindFirstOrThrowArgs>
    ): Prisma__StageClient<StageGetPayload<T>>

    /**
     * Find zero or more Stages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stages
     * const stages = await prisma.stage.findMany()
     * 
     * // Get first 10 Stages
     * const stages = await prisma.stage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageWithIdOnly = await prisma.stage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StageFindManyArgs>(
      args?: SelectSubset<T, StageFindManyArgs>
    ): Prisma.PrismaPromise<Array<StageGetPayload<T>>>

    /**
     * Create a Stage.
     * @param {StageCreateArgs} args - Arguments to create a Stage.
     * @example
     * // Create one Stage
     * const Stage = await prisma.stage.create({
     *   data: {
     *     // ... data to create a Stage
     *   }
     * })
     * 
    **/
    create<T extends StageCreateArgs>(
      args: SelectSubset<T, StageCreateArgs>
    ): Prisma__StageClient<StageGetPayload<T>>

    /**
     * Create many Stages.
     *     @param {StageCreateManyArgs} args - Arguments to create many Stages.
     *     @example
     *     // Create many Stages
     *     const stage = await prisma.stage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StageCreateManyArgs>(
      args?: SelectSubset<T, StageCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stage.
     * @param {StageDeleteArgs} args - Arguments to delete one Stage.
     * @example
     * // Delete one Stage
     * const Stage = await prisma.stage.delete({
     *   where: {
     *     // ... filter to delete one Stage
     *   }
     * })
     * 
    **/
    delete<T extends StageDeleteArgs>(
      args: SelectSubset<T, StageDeleteArgs>
    ): Prisma__StageClient<StageGetPayload<T>>

    /**
     * Update one Stage.
     * @param {StageUpdateArgs} args - Arguments to update one Stage.
     * @example
     * // Update one Stage
     * const stage = await prisma.stage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StageUpdateArgs>(
      args: SelectSubset<T, StageUpdateArgs>
    ): Prisma__StageClient<StageGetPayload<T>>

    /**
     * Delete zero or more Stages.
     * @param {StageDeleteManyArgs} args - Arguments to filter Stages to delete.
     * @example
     * // Delete a few Stages
     * const { count } = await prisma.stage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StageDeleteManyArgs>(
      args?: SelectSubset<T, StageDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stages
     * const stage = await prisma.stage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StageUpdateManyArgs>(
      args: SelectSubset<T, StageUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stage.
     * @param {StageUpsertArgs} args - Arguments to update or create a Stage.
     * @example
     * // Update or create a Stage
     * const stage = await prisma.stage.upsert({
     *   create: {
     *     // ... data to create a Stage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stage we want to update
     *   }
     * })
    **/
    upsert<T extends StageUpsertArgs>(
      args: SelectSubset<T, StageUpsertArgs>
    ): Prisma__StageClient<StageGetPayload<T>>

    /**
     * Find zero or more Stages that matches the filter.
     * @param {StageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const stage = await prisma.stage.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: StageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Stage.
     * @param {StageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const stage = await prisma.stage.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: StageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageCountArgs} args - Arguments to filter Stages to count.
     * @example
     * // Count the number of Stages
     * const count = await prisma.stage.count({
     *   where: {
     *     // ... the filter for the Stages we want to count
     *   }
     * })
    **/
    count<T extends StageCountArgs>(
      args?: Subset<T, StageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageAggregateArgs>(args: Subset<T, StageAggregateArgs>): Prisma.PrismaPromise<GetStageAggregateType<T>>

    /**
     * Group by Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageGroupByArgs['orderBy'] }
        : { orderBy?: StageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Stage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StageClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    long<T extends StageValueArgs= {}>(args?: Subset<T, StageValueArgs>): Prisma__StageValueClient<StageValueGetPayload<T> | Null>;

    width<T extends StageValueArgs= {}>(args?: Subset<T, StageValueArgs>): Prisma__StageValueClient<StageValueGetPayload<T> | Null>;

    height<T extends StageValueArgs= {}>(args?: Subset<T, StageValueArgs>): Prisma__StageValueClient<StageValueGetPayload<T> | Null>;

    amount<T extends StageValueArgs= {}>(args?: Subset<T, StageValueArgs>): Prisma__StageValueClient<StageValueGetPayload<T> | Null>;

    values<T extends TValuesArgs= {}>(args?: Subset<T, TValuesArgs>): Prisma__TValuesClient<TValuesGetPayload<T> | Null>;

    work<T extends TemplateWorkArgs= {}>(args?: Subset<T, TemplateWorkArgs>): Prisma__TemplateWorkClient<TemplateWorkGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Stage base type for findUnique actions
   */
  export type StageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findUnique
   */
  export interface StageFindUniqueArgs extends StageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Stage findUniqueOrThrow
   */
  export type StageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }


  /**
   * Stage base type for findFirst actions
   */
  export type StageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: Enumerable<StageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: Enumerable<StageScalarFieldEnum>
  }

  /**
   * Stage findFirst
   */
  export interface StageFindFirstArgs extends StageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Stage findFirstOrThrow
   */
  export type StageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: Enumerable<StageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: Enumerable<StageScalarFieldEnum>
  }


  /**
   * Stage findMany
   */
  export type StageFindManyArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * Filter, which Stages to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: Enumerable<StageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    distinct?: Enumerable<StageScalarFieldEnum>
  }


  /**
   * Stage create
   */
  export type StageCreateArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * The data needed to create a Stage.
     */
    data: XOR<StageCreateInput, StageUncheckedCreateInput>
  }


  /**
   * Stage createMany
   */
  export type StageCreateManyArgs = {
    /**
     * The data used to create many Stages.
     */
    data: Enumerable<StageCreateManyInput>
  }


  /**
   * Stage update
   */
  export type StageUpdateArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * The data needed to update a Stage.
     */
    data: XOR<StageUpdateInput, StageUncheckedUpdateInput>
    /**
     * Choose, which Stage to update.
     */
    where: StageWhereUniqueInput
  }


  /**
   * Stage updateMany
   */
  export type StageUpdateManyArgs = {
    /**
     * The data used to update Stages.
     */
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyInput>
    /**
     * Filter which Stages to update
     */
    where?: StageWhereInput
  }


  /**
   * Stage upsert
   */
  export type StageUpsertArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * The filter to search for the Stage to update in case it exists.
     */
    where: StageWhereUniqueInput
    /**
     * In case the Stage found by the `where` argument doesn't exist, create a new Stage with this data.
     */
    create: XOR<StageCreateInput, StageUncheckedCreateInput>
    /**
     * In case the Stage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageUpdateInput, StageUncheckedUpdateInput>
  }


  /**
   * Stage delete
   */
  export type StageDeleteArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
    /**
     * Filter which Stage to delete.
     */
    where: StageWhereUniqueInput
  }


  /**
   * Stage deleteMany
   */
  export type StageDeleteManyArgs = {
    /**
     * Filter which Stages to delete
     */
    where?: StageWhereInput
  }


  /**
   * Stage findRaw
   */
  export type StageFindRawArgs = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Stage aggregateRaw
   */
  export type StageAggregateRawArgs = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Stage without action
   */
  export type StageArgs = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StageInclude | null
  }



  /**
   * Enums
   */

  export const CompanyScalarFieldEnum: {
    id: 'id',
    gid: 'gid',
    name: 'name',
    limit: 'limit'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    model: 'model',
    manufacturer: 'manufacturer',
    userId: 'userId'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    size: 'size',
    width: 'width',
    height: 'height',
    type: 'type',
    groupId: 'groupId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const HistoriScalarFieldEnum: {
    id: 'id',
    type: 'type',
    model: 'model',
    step: 'step',
    message: 'message',
    refId: 'refId',
    createdAt: 'createdAt',
    userId: 'userId',
    companyId: 'companyId',
    optionId: 'optionId',
    unitId: 'unitId',
    itemId: 'itemId',
    workId: 'workId',
    workItemsId: 'workItemsId',
    templateId: 'templateId',
    imageId: 'imageId',
    fileId: 'fileId'
  };

  export type HistoriScalarFieldEnum = (typeof HistoriScalarFieldEnum)[keyof typeof HistoriScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    model: 'model',
    categoryId: 'categoryId',
    typeId: 'typeId',
    unitId: 'unitId',
    code: 'code',
    name: 'name',
    price: 'price',
    trim: 'trim',
    active: 'active',
    introIds: 'introIds'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const OptionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    code: 'code',
    name: 'name'
  };

  export type OptionScalarFieldEnum = (typeof OptionScalarFieldEnum)[keyof typeof OptionScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SpaceScalarFieldEnum: {
    id: 'id',
    refId: 'refId',
    name: 'name'
  };

  export type SpaceScalarFieldEnum = (typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum]


  export const StageScalarFieldEnum: {
    id: 'id',
    workId: 'workId',
    type: 'type',
    operation: 'operation',
    parentId: 'parentId',
    refs: 'refs',
    refParent: 'refParent',
    name: 'name'
  };

  export type StageScalarFieldEnum = (typeof StageScalarFieldEnum)[keyof typeof StageScalarFieldEnum]


  export const TemplateDEDScalarFieldEnum: {
    id: 'id',
    dataId: 'dataId',
    name: 'name'
  };

  export type TemplateDEDScalarFieldEnum = (typeof TemplateDEDScalarFieldEnum)[keyof typeof TemplateDEDScalarFieldEnum]


  export const TemplateDataScalarFieldEnum: {
    id: 'id',
    step: 'step',
    publish: 'publish',
    templateId: 'templateId'
  };

  export type TemplateDataScalarFieldEnum = (typeof TemplateDataScalarFieldEnum)[keyof typeof TemplateDataScalarFieldEnum]


  export const TemplateFieldScalarFieldEnum: {
    id: 'id',
    dataId: 'dataId',
    name: 'name',
    imageId: 'imageId',
    imageUrl: 'imageUrl'
  };

  export type TemplateFieldScalarFieldEnum = (typeof TemplateFieldScalarFieldEnum)[keyof typeof TemplateFieldScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    activeId: 'activeId'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const TemplateWorkItemScalarFieldEnum: {
    id: 'id',
    type: 'type',
    itemId: 'itemId',
    coefficient: 'coefficient',
    unitId: 'unitId',
    parentId: 'parentId'
  };

  export type TemplateWorkItemScalarFieldEnum = (typeof TemplateWorkItemScalarFieldEnum)[keyof typeof TemplateWorkItemScalarFieldEnum]


  export const TemplateWorkScalarFieldEnum: {
    id: 'id',
    dataId: 'dataId',
    workId: 'workId'
  };

  export type TemplateWorkScalarFieldEnum = (typeof TemplateWorkScalarFieldEnum)[keyof typeof TemplateWorkScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    username: 'username',
    password: 'password',
    passhash: 'passhash',
    role: 'role',
    active: 'active',
    companyId: 'companyId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkItemsScalarFieldEnum: {
    id: 'id',
    model: 'model',
    workId: 'workId',
    itemId: 'itemId',
    coefficient: 'coefficient',
    unitId: 'unitId'
  };

  export type WorkItemsScalarFieldEnum = (typeof WorkItemsScalarFieldEnum)[keyof typeof WorkItemsScalarFieldEnum]


  export const WorkScalarFieldEnum: {
    id: 'id',
    model: 'model',
    code: 'code',
    name: 'name',
    active: 'active',
    typeId: 'typeId',
    unitId: 'unitId'
  };

  export type WorkScalarFieldEnum = (typeof WorkScalarFieldEnum)[keyof typeof WorkScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type HistoriWhereInput = {
    AND?: Enumerable<HistoriWhereInput>
    OR?: Enumerable<HistoriWhereInput>
    NOT?: Enumerable<HistoriWhereInput>
    id?: StringFilter | string
    type?: EnumHistoriTypeFilter | HistoriType
    model?: EnumHistoriModelFilter | HistoriModel
    step?: IntNullableFilter | number | null
    message?: StringNullableFilter | string | null
    refId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
    companyId?: StringNullableFilter | string | null
    optionId?: StringNullableFilter | string | null
    unitId?: StringNullableFilter | string | null
    itemId?: StringNullableFilter | string | null
    workId?: StringNullableFilter | string | null
    workItemsId?: StringNullableFilter | string | null
    templateId?: StringNullableFilter | string | null
    imageId?: StringNullableFilter | string | null
    fileId?: StringNullableFilter | string | null
    ref?: XOR<UserRelationFilter, UserWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    option?: XOR<OptionRelationFilter, OptionWhereInput> | null
    unit?: XOR<UnitRelationFilter, UnitWhereInput> | null
    item?: XOR<ItemRelationFilter, ItemWhereInput> | null
    work?: XOR<WorkRelationFilter, WorkWhereInput> | null
    workItems?: XOR<WorkItemsRelationFilter, WorkItemsWhereInput> | null
    template?: XOR<TemplateRelationFilter, TemplateWhereInput> | null
    image?: XOR<ImageRelationFilter, ImageWhereInput> | null
    file?: XOR<FileRelationFilter, FileWhereInput> | null
  }

  export type HistoriOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    model?: SortOrder
    step?: SortOrder
    message?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    optionId?: SortOrder
    unitId?: SortOrder
    itemId?: SortOrder
    workId?: SortOrder
    workItemsId?: SortOrder
    templateId?: SortOrder
    imageId?: SortOrder
    fileId?: SortOrder
    ref?: UserOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    option?: OptionOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    work?: WorkOrderByWithRelationInput
    workItems?: WorkItemsOrderByWithRelationInput
    template?: TemplateOrderByWithRelationInput
    image?: ImageOrderByWithRelationInput
    file?: FileOrderByWithRelationInput
  }

  export type HistoriWhereUniqueInput = {
    id?: string
  }

  export type HistoriOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    model?: SortOrder
    step?: SortOrder
    message?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    optionId?: SortOrder
    unitId?: SortOrder
    itemId?: SortOrder
    workId?: SortOrder
    workItemsId?: SortOrder
    templateId?: SortOrder
    imageId?: SortOrder
    fileId?: SortOrder
    _count?: HistoriCountOrderByAggregateInput
    _avg?: HistoriAvgOrderByAggregateInput
    _max?: HistoriMaxOrderByAggregateInput
    _min?: HistoriMinOrderByAggregateInput
    _sum?: HistoriSumOrderByAggregateInput
  }

  export type HistoriScalarWhereWithAggregatesInput = {
    AND?: Enumerable<HistoriScalarWhereWithAggregatesInput>
    OR?: Enumerable<HistoriScalarWhereWithAggregatesInput>
    NOT?: Enumerable<HistoriScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumHistoriTypeWithAggregatesFilter | HistoriType
    model?: EnumHistoriModelWithAggregatesFilter | HistoriModel
    step?: IntNullableWithAggregatesFilter | number | null
    message?: StringNullableWithAggregatesFilter | string | null
    refId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringNullableWithAggregatesFilter | string | null
    companyId?: StringNullableWithAggregatesFilter | string | null
    optionId?: StringNullableWithAggregatesFilter | string | null
    unitId?: StringNullableWithAggregatesFilter | string | null
    itemId?: StringNullableWithAggregatesFilter | string | null
    workId?: StringNullableWithAggregatesFilter | string | null
    workItemsId?: StringNullableWithAggregatesFilter | string | null
    templateId?: StringNullableWithAggregatesFilter | string | null
    imageId?: StringNullableWithAggregatesFilter | string | null
    fileId?: StringNullableWithAggregatesFilter | string | null
  }

  export type DeviceWhereInput = {
    AND?: Enumerable<DeviceWhereInput>
    OR?: Enumerable<DeviceWhereInput>
    NOT?: Enumerable<DeviceWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    model?: StringFilter | string
    manufacturer?: StringFilter | string
    userId?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceWhereUniqueInput = {
    id?: string
  }

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    userId?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeviceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    uuid?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    manufacturer?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type CompanyWhereInput = {
    AND?: Enumerable<CompanyWhereInput>
    OR?: Enumerable<CompanyWhereInput>
    NOT?: Enumerable<CompanyWhereInput>
    id?: StringFilter | string
    gid?: StringNullableFilter | string | null
    name?: StringFilter | string
    address?: XOR<AddressCompositeFilter, AddressObjectEqualityInput>
    phone?: XOR<TPhoneNullableCompositeFilter, TPhoneObjectEqualityInput> | null
    limit?: IntFilter | number
    users?: UserListRelationFilter
    historis?: HistoriListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    gid?: SortOrder
    name?: SortOrder
    address?: AddressOrderByInput
    phone?: TPhoneOrderByInput
    limit?: SortOrder
    users?: UserOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = {
    id?: string
  }

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    gid?: SortOrder
    name?: SortOrder
    limit?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    OR?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CompanyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    gid?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    limit?: IntWithAggregatesFilter | number
  }

  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    passhash?: StringFilter | string
    role?: EnumUserRoleFilter | UserRole
    active?: BoolFilter | boolean
    companyId?: StringNullableFilter | string | null
    company?: XOR<CompanyRelationFilter, CompanyWhereInput> | null
    trackers?: HistoriListRelationFilter
    historis?: HistoriListRelationFilter
    devices?: DeviceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    role?: SortOrder
    active?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    trackers?: HistoriOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    username?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    role?: SortOrder
    active?: SortOrder
    companyId?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    username?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    passhash?: StringWithAggregatesFilter | string
    role?: EnumUserRoleWithAggregatesFilter | UserRole
    active?: BoolWithAggregatesFilter | boolean
    companyId?: StringNullableWithAggregatesFilter | string | null
  }

  export type FileWhereInput = {
    AND?: Enumerable<FileWhereInput>
    OR?: Enumerable<FileWhereInput>
    NOT?: Enumerable<FileWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    url?: StringFilter | string
    size?: IntFilter | number
    width?: IntFilter | number
    height?: IntFilter | number
    type?: StringFilter | string
    groupId?: StringFilter | string
    group?: XOR<ImageRelationFilter, ImageWhereInput>
    historis?: HistoriListRelationFilter
    fields?: TemplateFieldListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    group?: ImageOrderByWithRelationInput
    historis?: HistoriOrderByRelationAggregateInput
    fields?: TemplateFieldOrderByRelationAggregateInput
  }

  export type FileWhereUniqueInput = {
    id?: string
  }

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FileScalarWhereWithAggregatesInput>
    OR?: Enumerable<FileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    size?: IntWithAggregatesFilter | number
    width?: IntWithAggregatesFilter | number
    height?: IntWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    groupId?: StringWithAggregatesFilter | string
  }

  export type ImageWhereInput = {
    AND?: Enumerable<ImageWhereInput>
    OR?: Enumerable<ImageWhereInput>
    NOT?: Enumerable<ImageWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    files?: FileListRelationFilter
    historis?: HistoriListRelationFilter
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    files?: FileOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
  }

  export type ImageWhereUniqueInput = {
    id?: string
  }

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type OptionWhereInput = {
    AND?: Enumerable<OptionWhereInput>
    OR?: Enumerable<OptionWhereInput>
    NOT?: Enumerable<OptionWhereInput>
    id?: StringFilter | string
    type?: EnumOptionTypeFilter | OptionType
    code?: StringNullableFilter | string | null
    name?: StringFilter | string
    itemCategorys?: ItemListRelationFilter
    itemTypes?: ItemListRelationFilter
    workTypes?: WorkListRelationFilter
    historis?: HistoriListRelationFilter
  }

  export type OptionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    itemCategorys?: ItemOrderByRelationAggregateInput
    itemTypes?: ItemOrderByRelationAggregateInput
    workTypes?: WorkOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
  }

  export type OptionWhereUniqueInput = {
    id?: string
    type_name?: OptionTypeNameCompoundUniqueInput
  }

  export type OptionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: OptionCountOrderByAggregateInput
    _max?: OptionMaxOrderByAggregateInput
    _min?: OptionMinOrderByAggregateInput
  }

  export type OptionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OptionScalarWhereWithAggregatesInput>
    OR?: Enumerable<OptionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OptionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumOptionTypeWithAggregatesFilter | OptionType
    code?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
  }

  export type UnitWhereInput = {
    AND?: Enumerable<UnitWhereInput>
    OR?: Enumerable<UnitWhereInput>
    NOT?: Enumerable<UnitWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    items?: ItemListRelationFilter
    works?: WorkListRelationFilter
    workItems?: WorkItemsListRelationFilter
    historis?: HistoriListRelationFilter
    tWorkItems?: TemplateWorkItemListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    items?: ItemOrderByRelationAggregateInput
    works?: WorkOrderByRelationAggregateInput
    workItems?: WorkItemsOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
    tWorkItems?: TemplateWorkItemOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UnitScalarWhereWithAggregatesInput>
    OR?: Enumerable<UnitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UnitScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type ItemWhereInput = {
    AND?: Enumerable<ItemWhereInput>
    OR?: Enumerable<ItemWhereInput>
    NOT?: Enumerable<ItemWhereInput>
    id?: StringFilter | string
    model?: EnumItemModelFilter | ItemModel
    categoryId?: StringFilter | string
    typeId?: StringNullableFilter | string | null
    unitId?: StringFilter | string
    code?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    price?: IntFilter | number
    trim?: BoolFilter | boolean
    active?: BoolFilter | boolean
    introIds?: StringNullableListFilter
    category?: XOR<OptionRelationFilter, OptionWhereInput>
    type?: XOR<OptionRelationFilter, OptionWhereInput> | null
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    works?: WorkItemsListRelationFilter
    historis?: HistoriListRelationFilter
    tWorks?: TemplateWorkItemListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    model?: SortOrder
    categoryId?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    trim?: SortOrder
    active?: SortOrder
    introIds?: SortOrder
    category?: OptionOrderByWithRelationInput
    type?: OptionOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    works?: WorkItemsOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
    tWorks?: TemplateWorkItemOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = {
    id?: string
  }

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    model?: SortOrder
    categoryId?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    trim?: SortOrder
    active?: SortOrder
    introIds?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<ItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    model?: EnumItemModelWithAggregatesFilter | ItemModel
    categoryId?: StringWithAggregatesFilter | string
    typeId?: StringNullableWithAggregatesFilter | string | null
    unitId?: StringWithAggregatesFilter | string
    code?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    price?: IntWithAggregatesFilter | number
    trim?: BoolWithAggregatesFilter | boolean
    active?: BoolWithAggregatesFilter | boolean
    introIds?: StringNullableListFilter
  }

  export type WorkWhereInput = {
    AND?: Enumerable<WorkWhereInput>
    OR?: Enumerable<WorkWhereInput>
    NOT?: Enumerable<WorkWhereInput>
    id?: StringFilter | string
    model?: EnumWorkModelFilter | WorkModel
    code?: StringFilter | string
    name?: StringFilter | string
    active?: BoolFilter | boolean
    typeId?: StringFilter | string
    unitId?: StringFilter | string
    type?: XOR<OptionRelationFilter, OptionWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    items?: WorkItemsListRelationFilter
    historis?: HistoriListRelationFilter
    templates?: TemplateWorkListRelationFilter
  }

  export type WorkOrderByWithRelationInput = {
    id?: SortOrder
    model?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    type?: OptionOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    items?: WorkItemsOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
    templates?: TemplateWorkOrderByRelationAggregateInput
  }

  export type WorkWhereUniqueInput = {
    id?: string
  }

  export type WorkOrderByWithAggregationInput = {
    id?: SortOrder
    model?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    _count?: WorkCountOrderByAggregateInput
    _max?: WorkMaxOrderByAggregateInput
    _min?: WorkMinOrderByAggregateInput
  }

  export type WorkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    model?: EnumWorkModelWithAggregatesFilter | WorkModel
    code?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    active?: BoolWithAggregatesFilter | boolean
    typeId?: StringWithAggregatesFilter | string
    unitId?: StringWithAggregatesFilter | string
  }

  export type WorkItemsWhereInput = {
    AND?: Enumerable<WorkItemsWhereInput>
    OR?: Enumerable<WorkItemsWhereInput>
    NOT?: Enumerable<WorkItemsWhereInput>
    id?: StringFilter | string
    model?: EnumWorkModelFilter | WorkModel
    workId?: StringFilter | string
    itemId?: StringFilter | string
    coefficient?: FloatFilter | number
    unitId?: StringNullableFilter | string | null
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput> | null
    historis?: HistoriListRelationFilter
  }

  export type WorkItemsOrderByWithRelationInput = {
    id?: SortOrder
    model?: SortOrder
    workId?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    work?: WorkOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    historis?: HistoriOrderByRelationAggregateInput
  }

  export type WorkItemsWhereUniqueInput = {
    id?: string
  }

  export type WorkItemsOrderByWithAggregationInput = {
    id?: SortOrder
    model?: SortOrder
    workId?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    _count?: WorkItemsCountOrderByAggregateInput
    _avg?: WorkItemsAvgOrderByAggregateInput
    _max?: WorkItemsMaxOrderByAggregateInput
    _min?: WorkItemsMinOrderByAggregateInput
    _sum?: WorkItemsSumOrderByAggregateInput
  }

  export type WorkItemsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkItemsScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkItemsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkItemsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    model?: EnumWorkModelWithAggregatesFilter | WorkModel
    workId?: StringWithAggregatesFilter | string
    itemId?: StringWithAggregatesFilter | string
    coefficient?: FloatWithAggregatesFilter | number
    unitId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TemplateWhereInput = {
    AND?: Enumerable<TemplateWhereInput>
    OR?: Enumerable<TemplateWhereInput>
    NOT?: Enumerable<TemplateWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    activeId?: StringNullableFilter | string | null
    active?: XOR<TemplateDataRelationFilter, TemplateDataWhereInput> | null
    records?: TemplateDataListRelationFilter
    historis?: HistoriListRelationFilter
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    activeId?: SortOrder
    active?: TemplateDataOrderByWithRelationInput
    records?: TemplateDataOrderByRelationAggregateInput
    historis?: HistoriOrderByRelationAggregateInput
  }

  export type TemplateWhereUniqueInput = {
    id?: string
    name?: string
    activeId?: string
  }

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    activeId?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    activeId?: StringNullableWithAggregatesFilter | string | null
  }

  export type TemplateWorkItemWhereInput = {
    AND?: Enumerable<TemplateWorkItemWhereInput>
    OR?: Enumerable<TemplateWorkItemWhereInput>
    NOT?: Enumerable<TemplateWorkItemWhereInput>
    id?: StringFilter | string
    type?: EnumItemModelFilter | ItemModel
    itemId?: StringFilter | string
    coefficient?: FloatFilter | number
    unitId?: StringFilter | string
    parentId?: StringFilter | string
    item?: XOR<ItemRelationFilter, ItemWhereInput>
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    parent?: XOR<TemplateWorkRelationFilter, TemplateWorkWhereInput>
  }

  export type TemplateWorkItemOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    parentId?: SortOrder
    item?: ItemOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    parent?: TemplateWorkOrderByWithRelationInput
  }

  export type TemplateWorkItemWhereUniqueInput = {
    id?: string
    parentId_itemId?: TemplateWorkItemParentIdItemIdCompoundUniqueInput
  }

  export type TemplateWorkItemOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    parentId?: SortOrder
    _count?: TemplateWorkItemCountOrderByAggregateInput
    _avg?: TemplateWorkItemAvgOrderByAggregateInput
    _max?: TemplateWorkItemMaxOrderByAggregateInput
    _min?: TemplateWorkItemMinOrderByAggregateInput
    _sum?: TemplateWorkItemSumOrderByAggregateInput
  }

  export type TemplateWorkItemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateWorkItemScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateWorkItemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateWorkItemScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: EnumItemModelWithAggregatesFilter | ItemModel
    itemId?: StringWithAggregatesFilter | string
    coefficient?: FloatWithAggregatesFilter | number
    unitId?: StringWithAggregatesFilter | string
    parentId?: StringWithAggregatesFilter | string
  }

  export type TemplateWorkWhereInput = {
    AND?: Enumerable<TemplateWorkWhereInput>
    OR?: Enumerable<TemplateWorkWhereInput>
    NOT?: Enumerable<TemplateWorkWhereInput>
    id?: StringFilter | string
    dataId?: StringFilter | string
    workId?: StringFilter | string
    data?: XOR<TemplateDataRelationFilter, TemplateDataWhereInput>
    work?: XOR<WorkRelationFilter, WorkWhereInput>
    items?: TemplateWorkItemListRelationFilter
    stages?: StageListRelationFilter
  }

  export type TemplateWorkOrderByWithRelationInput = {
    id?: SortOrder
    dataId?: SortOrder
    workId?: SortOrder
    data?: TemplateDataOrderByWithRelationInput
    work?: WorkOrderByWithRelationInput
    items?: TemplateWorkItemOrderByRelationAggregateInput
    stages?: StageOrderByRelationAggregateInput
  }

  export type TemplateWorkWhereUniqueInput = {
    id?: string
  }

  export type TemplateWorkOrderByWithAggregationInput = {
    id?: SortOrder
    dataId?: SortOrder
    workId?: SortOrder
    _count?: TemplateWorkCountOrderByAggregateInput
    _max?: TemplateWorkMaxOrderByAggregateInput
    _min?: TemplateWorkMinOrderByAggregateInput
  }

  export type TemplateWorkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateWorkScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateWorkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateWorkScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    dataId?: StringWithAggregatesFilter | string
    workId?: StringWithAggregatesFilter | string
  }

  export type TemplateDataWhereInput = {
    AND?: Enumerable<TemplateDataWhereInput>
    OR?: Enumerable<TemplateDataWhereInput>
    NOT?: Enumerable<TemplateDataWhereInput>
    id?: StringFilter | string
    step?: IntFilter | number
    publish?: BoolFilter | boolean
    templateId?: StringFilter | string
    around?: XOR<TAroundNullableCompositeFilter, TAroundObjectEqualityInput> | null
    properties?: XOR<TPropertyCompositeFilter, TPropertyObjectEqualityInput>
    active?: XOR<TemplateRelationFilter, TemplateWhereInput> | null
    template?: XOR<TemplateRelationFilter, TemplateWhereInput>
    spaces?: SpaceListRelationFilter
    works?: TemplateWorkListRelationFilter
    deds?: TemplateDEDListRelationFilter
    fields?: TemplateFieldListRelationFilter
  }

  export type TemplateDataOrderByWithRelationInput = {
    id?: SortOrder
    step?: SortOrder
    publish?: SortOrder
    templateId?: SortOrder
    around?: TAroundOrderByInput
    properties?: TPropertyOrderByInput
    active?: TemplateOrderByWithRelationInput
    template?: TemplateOrderByWithRelationInput
    spaces?: SpaceOrderByRelationAggregateInput
    works?: TemplateWorkOrderByRelationAggregateInput
    deds?: TemplateDEDOrderByRelationAggregateInput
    fields?: TemplateFieldOrderByRelationAggregateInput
  }

  export type TemplateDataWhereUniqueInput = {
    id?: string
  }

  export type TemplateDataOrderByWithAggregationInput = {
    id?: SortOrder
    step?: SortOrder
    publish?: SortOrder
    templateId?: SortOrder
    _count?: TemplateDataCountOrderByAggregateInput
    _avg?: TemplateDataAvgOrderByAggregateInput
    _max?: TemplateDataMaxOrderByAggregateInput
    _min?: TemplateDataMinOrderByAggregateInput
    _sum?: TemplateDataSumOrderByAggregateInput
  }

  export type TemplateDataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateDataScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateDataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateDataScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    step?: IntWithAggregatesFilter | number
    publish?: BoolWithAggregatesFilter | boolean
    templateId?: StringWithAggregatesFilter | string
  }

  export type TemplateFieldWhereInput = {
    AND?: Enumerable<TemplateFieldWhereInput>
    OR?: Enumerable<TemplateFieldWhereInput>
    NOT?: Enumerable<TemplateFieldWhereInput>
    id?: StringFilter | string
    dataId?: StringFilter | string
    name?: StringFilter | string
    imageId?: StringNullableFilter | string | null
    imageUrl?: StringNullableFilter | string | null
    lists?: XOR<TFieldListCompositeListFilter, Enumerable<TFieldListObjectEqualityInput>>
    data?: XOR<TemplateDataRelationFilter, TemplateDataWhereInput>
    image?: XOR<FileRelationFilter, FileWhereInput> | null
  }

  export type TemplateFieldOrderByWithRelationInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    imageId?: SortOrder
    imageUrl?: SortOrder
    lists?: TFieldListOrderByCompositeAggregateInput
    data?: TemplateDataOrderByWithRelationInput
    image?: FileOrderByWithRelationInput
  }

  export type TemplateFieldWhereUniqueInput = {
    id?: string
  }

  export type TemplateFieldOrderByWithAggregationInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    imageId?: SortOrder
    imageUrl?: SortOrder
    _count?: TemplateFieldCountOrderByAggregateInput
    _max?: TemplateFieldMaxOrderByAggregateInput
    _min?: TemplateFieldMinOrderByAggregateInput
  }

  export type TemplateFieldScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateFieldScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateFieldScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateFieldScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    dataId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    imageId?: StringNullableWithAggregatesFilter | string | null
    imageUrl?: StringNullableWithAggregatesFilter | string | null
  }

  export type TemplateDEDWhereInput = {
    AND?: Enumerable<TemplateDEDWhereInput>
    OR?: Enumerable<TemplateDEDWhereInput>
    NOT?: Enumerable<TemplateDEDWhereInput>
    id?: StringFilter | string
    dataId?: StringFilter | string
    name?: StringFilter | string
    lists?: XOR<TDeDListCompositeListFilter, Enumerable<TDeDListObjectEqualityInput>>
    data?: XOR<TemplateDataRelationFilter, TemplateDataWhereInput>
  }

  export type TemplateDEDOrderByWithRelationInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    lists?: TDeDListOrderByCompositeAggregateInput
    data?: TemplateDataOrderByWithRelationInput
  }

  export type TemplateDEDWhereUniqueInput = {
    id?: string
  }

  export type TemplateDEDOrderByWithAggregationInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    _count?: TemplateDEDCountOrderByAggregateInput
    _max?: TemplateDEDMaxOrderByAggregateInput
    _min?: TemplateDEDMinOrderByAggregateInput
  }

  export type TemplateDEDScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateDEDScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateDEDScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateDEDScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    dataId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type SpaceWhereInput = {
    AND?: Enumerable<SpaceWhereInput>
    OR?: Enumerable<SpaceWhereInput>
    NOT?: Enumerable<SpaceWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
    long?: XOR<SpaceValueCompositeFilter, SpaceValueObjectEqualityInput>
    width?: XOR<SpaceValueCompositeFilter, SpaceValueObjectEqualityInput>
    height?: XOR<SpaceValueCompositeFilter, SpaceValueObjectEqualityInput>
    amount?: XOR<SpaceValueCompositeFilter, SpaceValueObjectEqualityInput>
    values?: XOR<TValuesCompositeFilter, TValuesObjectEqualityInput>
    ref?: XOR<TemplateDataRelationFilter, TemplateDataWhereInput>
  }

  export type SpaceOrderByWithRelationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    long?: SpaceValueOrderByInput
    width?: SpaceValueOrderByInput
    height?: SpaceValueOrderByInput
    amount?: SpaceValueOrderByInput
    values?: TValuesOrderByInput
    ref?: TemplateDataOrderByWithRelationInput
  }

  export type SpaceWhereUniqueInput = {
    id?: string
  }

  export type SpaceOrderByWithAggregationInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
    _count?: SpaceCountOrderByAggregateInput
    _max?: SpaceMaxOrderByAggregateInput
    _min?: SpaceMinOrderByAggregateInput
  }

  export type SpaceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpaceScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpaceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpaceScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    refId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type StageWhereInput = {
    AND?: Enumerable<StageWhereInput>
    OR?: Enumerable<StageWhereInput>
    NOT?: Enumerable<StageWhereInput>
    id?: StringFilter | string
    workId?: StringFilter | string
    type?: EnumStageTypeFilter | StageType
    operation?: EnumStageOprFilter | StageOpr
    parentId?: StringNullableFilter | string | null
    refs?: StringNullableFilter | string | null
    refParent?: BoolNullableFilter | boolean | null
    name?: StringNullableFilter | string | null
    long?: XOR<StageValueCompositeFilter, StageValueObjectEqualityInput>
    width?: XOR<StageValueCompositeFilter, StageValueObjectEqualityInput>
    height?: XOR<StageValueCompositeFilter, StageValueObjectEqualityInput>
    amount?: XOR<StageValueCompositeFilter, StageValueObjectEqualityInput>
    values?: XOR<TValuesCompositeFilter, TValuesObjectEqualityInput>
    work?: XOR<TemplateWorkRelationFilter, TemplateWorkWhereInput>
  }

  export type StageOrderByWithRelationInput = {
    id?: SortOrder
    workId?: SortOrder
    type?: SortOrder
    operation?: SortOrder
    parentId?: SortOrder
    refs?: SortOrder
    refParent?: SortOrder
    name?: SortOrder
    long?: StageValueOrderByInput
    width?: StageValueOrderByInput
    height?: StageValueOrderByInput
    amount?: StageValueOrderByInput
    values?: TValuesOrderByInput
    work?: TemplateWorkOrderByWithRelationInput
  }

  export type StageWhereUniqueInput = {
    id?: string
  }

  export type StageOrderByWithAggregationInput = {
    id?: SortOrder
    workId?: SortOrder
    type?: SortOrder
    operation?: SortOrder
    parentId?: SortOrder
    refs?: SortOrder
    refParent?: SortOrder
    name?: SortOrder
    _count?: StageCountOrderByAggregateInput
    _max?: StageMaxOrderByAggregateInput
    _min?: StageMinOrderByAggregateInput
  }

  export type StageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StageScalarWhereWithAggregatesInput>
    OR?: Enumerable<StageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    workId?: StringWithAggregatesFilter | string
    type?: EnumStageTypeWithAggregatesFilter | StageType
    operation?: EnumStageOprWithAggregatesFilter | StageOpr
    parentId?: StringNullableWithAggregatesFilter | string | null
    refs?: StringNullableWithAggregatesFilter | string | null
    refParent?: BoolNullableWithAggregatesFilter | boolean | null
    name?: StringNullableWithAggregatesFilter | string | null
  }

  export type HistoriCreateInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriUpdateInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriCreateManyInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriUpdateManyMutationInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoriUncheckedUpdateManyInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceCreateInput = {
    id?: string
    uuid: string
    model: string
    manufacturer: string
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    uuid: string
    model: string
    manufacturer: string
    userId: string
  }

  export type DeviceUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCreateManyInput = {
    id?: string
    uuid: string
    model: string
    manufacturer: string
    userId: string
  }

  export type DeviceUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyCreateInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
    users?: UserCreateNestedManyWithoutCompanyInput
    historis?: HistoriCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
    historis?: HistoriUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutCompanyNestedInput
    historis?: HistoriUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
  }

  export type CompanyUpdateManyMutationInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type CompanyUncheckedUpdateManyInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    company?: CompanyCreateNestedOneWithoutUsersInput
    trackers?: HistoriCreateNestedManyWithoutRefInput
    historis?: HistoriCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    companyId?: string | null
    trackers?: HistoriUncheckedCreateNestedManyWithoutRefInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneWithoutUsersNestedInput
    trackers?: HistoriUpdateManyWithoutRefNestedInput
    historis?: HistoriUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    trackers?: HistoriUncheckedUpdateManyWithoutRefNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    companyId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileCreateInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    group: ImageCreateNestedOneWithoutFilesInput
    historis?: HistoriCreateNestedManyWithoutFileInput
    fields?: TemplateFieldCreateNestedManyWithoutImageInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    groupId: string
    historis?: HistoriUncheckedCreateNestedManyWithoutFileInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutImageInput
  }

  export type FileUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    group?: ImageUpdateOneRequiredWithoutFilesNestedInput
    historis?: HistoriUpdateManyWithoutFileNestedInput
    fields?: TemplateFieldUpdateManyWithoutImageNestedInput
  }

  export type FileUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUncheckedUpdateManyWithoutFileNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutImageNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    groupId: string
  }

  export type FileUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type FileUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    id?: string
    name: string
    files?: FileCreateNestedManyWithoutGroupInput
    historis?: HistoriCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    name: string
    files?: FileUncheckedCreateNestedManyWithoutGroupInput
    historis?: HistoriUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    files?: FileUpdateManyWithoutGroupNestedInput
    historis?: HistoriUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutGroupNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageCreateManyInput = {
    id?: string
    name: string
  }

  export type ImageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OptionCreateInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemCreateNestedManyWithoutCategoryInput
    itemTypes?: ItemCreateNestedManyWithoutTypeInput
    workTypes?: WorkCreateNestedManyWithoutTypeInput
    historis?: HistoriCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    itemTypes?: ItemUncheckedCreateNestedManyWithoutTypeInput
    workTypes?: WorkUncheckedCreateNestedManyWithoutTypeInput
    historis?: HistoriUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionUpdateInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUpdateManyWithoutCategoryNestedInput
    itemTypes?: ItemUpdateManyWithoutTypeNestedInput
    workTypes?: WorkUpdateManyWithoutTypeNestedInput
    historis?: HistoriUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    itemTypes?: ItemUncheckedUpdateManyWithoutTypeNestedInput
    workTypes?: WorkUncheckedUpdateManyWithoutTypeNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionCreateManyInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
  }

  export type OptionUpdateManyMutationInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OptionUncheckedUpdateManyInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UnitCreateInput = {
    id?: string
    name: string
    items?: ItemCreateNestedManyWithoutUnitInput
    works?: WorkCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsCreateNestedManyWithoutUnitInput
    historis?: HistoriCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: string
    name: string
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
    works?: WorkUncheckedCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsUncheckedCreateNestedManyWithoutUnitInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutUnitNestedInput
    works?: WorkUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUpdateManyWithoutUnitNestedInput
    historis?: HistoriUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
    works?: WorkUncheckedUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUncheckedUpdateManyWithoutUnitNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    id?: string
    name: string
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ItemCreateInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    category: OptionCreateNestedOneWithoutItemCategorysInput
    type?: OptionCreateNestedOneWithoutItemTypesInput
    unit: UnitCreateNestedOneWithoutItemsInput
    works?: WorkItemsCreateNestedManyWithoutItemInput
    historis?: HistoriCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedCreateNestedManyWithoutItemInput
    historis?: HistoriUncheckedCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    category?: OptionUpdateOneRequiredWithoutItemCategorysNestedInput
    type?: OptionUpdateOneWithoutItemTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    works?: WorkItemsUpdateManyWithoutItemNestedInput
    historis?: HistoriUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedUpdateManyWithoutItemNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
  }

  export type ItemUpdateManyMutationInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
  }

  export type ItemUncheckedUpdateManyInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
  }

  export type WorkCreateInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    type: OptionCreateNestedOneWithoutWorkTypesInput
    unit: UnitCreateNestedOneWithoutWorksInput
    items?: WorkItemsCreateNestedManyWithoutWorkInput
    historis?: HistoriCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    unitId: string
    items?: WorkItemsUncheckedCreateNestedManyWithoutWorkInput
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkUpdateInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: OptionUpdateOneRequiredWithoutWorkTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutWorksNestedInput
    items?: WorkItemsUpdateManyWithoutWorkNestedInput
    historis?: HistoriUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    items?: WorkItemsUncheckedUpdateManyWithoutWorkNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkCreateManyInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    unitId: string
  }

  export type WorkUpdateManyMutationInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkUncheckedUpdateManyInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemsCreateInput = {
    id?: string
    model: WorkModel
    coefficient: number
    work: WorkCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutWorksInput
    unit?: UnitCreateNestedOneWithoutWorkItemsInput
    historis?: HistoriCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsUncheckedCreateInput = {
    id?: string
    model: WorkModel
    workId: string
    itemId: string
    coefficient: number
    unitId?: string | null
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsUpdateInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    work?: WorkUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutWorksNestedInput
    unit?: UnitUpdateOneWithoutWorkItemsNestedInput
    historis?: HistoriUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    historis?: HistoriUncheckedUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsCreateManyInput = {
    id?: string
    model: WorkModel
    workId: string
    itemId: string
    coefficient: number
    unitId?: string | null
  }

  export type WorkItemsUpdateManyMutationInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    coefficient?: FloatFieldUpdateOperationsInput | number
  }

  export type WorkItemsUncheckedUpdateManyInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateCreateInput = {
    id?: string
    name: string
    active?: TemplateDataCreateNestedOneWithoutActiveInput
    records?: TemplateDataCreateNestedManyWithoutTemplateInput
    historis?: HistoriCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    name: string
    activeId?: string | null
    records?: TemplateDataUncheckedCreateNestedManyWithoutTemplateInput
    historis?: HistoriUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: TemplateDataUpdateOneWithoutActiveNestedInput
    records?: TemplateDataUpdateManyWithoutTemplateNestedInput
    historis?: HistoriUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    activeId?: NullableStringFieldUpdateOperationsInput | string | null
    records?: TemplateDataUncheckedUpdateManyWithoutTemplateNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateCreateManyInput = {
    id?: string
    name: string
    activeId?: string | null
  }

  export type TemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    activeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateWorkItemCreateInput = {
    id?: string
    type: ItemModel
    coefficient: number
    item: ItemCreateNestedOneWithoutTWorksInput
    unit: UnitCreateNestedOneWithoutTWorkItemsInput
    parent: TemplateWorkCreateNestedOneWithoutItemsInput
  }

  export type TemplateWorkItemUncheckedCreateInput = {
    id?: string
    type: ItemModel
    itemId: string
    coefficient: number
    unitId: string
    parentId: string
  }

  export type TemplateWorkItemUpdateInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutTWorksNestedInput
    unit?: UnitUpdateOneRequiredWithoutTWorkItemsNestedInput
    parent?: TemplateWorkUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateWorkItemUncheckedUpdateInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateWorkItemCreateManyInput = {
    id?: string
    type: ItemModel
    itemId: string
    coefficient: number
    unitId: string
    parentId: string
  }

  export type TemplateWorkItemUpdateManyMutationInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
  }

  export type TemplateWorkItemUncheckedUpdateManyInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateWorkCreateInput = {
    id?: string
    data: TemplateDataCreateNestedOneWithoutWorksInput
    work: WorkCreateNestedOneWithoutTemplatesInput
    items?: TemplateWorkItemCreateNestedManyWithoutParentInput
    stages?: StageCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkUncheckedCreateInput = {
    id?: string
    dataId: string
    workId: string
    items?: TemplateWorkItemUncheckedCreateNestedManyWithoutParentInput
    stages?: StageUncheckedCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkUpdateInput = {
    data?: TemplateDataUpdateOneRequiredWithoutWorksNestedInput
    work?: WorkUpdateOneRequiredWithoutTemplatesNestedInput
    items?: TemplateWorkItemUpdateManyWithoutParentNestedInput
    stages?: StageUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkUncheckedUpdateInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    items?: TemplateWorkItemUncheckedUpdateManyWithoutParentNestedInput
    stages?: StageUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkCreateManyInput = {
    id?: string
    dataId: string
    workId: string
  }

  export type TemplateWorkUpdateManyMutationInput = {

  }

  export type TemplateWorkUncheckedUpdateManyInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateDataCreateInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateCreateNestedOneWithoutActiveInput
    template: TemplateCreateNestedOneWithoutRecordsInput
    spaces?: SpaceCreateNestedManyWithoutRefInput
    works?: TemplateWorkCreateNestedManyWithoutDataInput
    deds?: TemplateDEDCreateNestedManyWithoutDataInput
    fields?: TemplateFieldCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedCreateNestedOneWithoutActiveInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutRefInput
    works?: TemplateWorkUncheckedCreateNestedManyWithoutDataInput
    deds?: TemplateDEDUncheckedCreateNestedManyWithoutDataInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUpdateInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUpdateOneWithoutActiveNestedInput
    template?: TemplateUpdateOneRequiredWithoutRecordsNestedInput
    spaces?: SpaceUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedUpdateOneWithoutActiveNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUncheckedUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUncheckedUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataCreateManyInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
  }

  export type TemplateDataUpdateManyMutationInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
  }

  export type TemplateDataUncheckedUpdateManyInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
  }

  export type TemplateFieldCreateInput = {
    id?: string
    name: string
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
    data: TemplateDataCreateNestedOneWithoutFieldsInput
    image?: FileCreateNestedOneWithoutFieldsInput
  }

  export type TemplateFieldUncheckedCreateInput = {
    id?: string
    dataId: string
    name: string
    imageId?: string | null
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
    data?: TemplateDataUpdateOneRequiredWithoutFieldsNestedInput
    image?: FileUpdateOneWithoutFieldsNestedInput
  }

  export type TemplateFieldUncheckedUpdateInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldCreateManyInput = {
    id?: string
    dataId: string
    name: string
    imageId?: string | null
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldUncheckedUpdateManyInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateDEDCreateInput = {
    id?: string
    name: string
    lists?: XOR<TDeDListListCreateEnvelopeInput, Enumerable<TDeDListCreateInput>>
    data: TemplateDataCreateNestedOneWithoutDedsInput
  }

  export type TemplateDEDUncheckedCreateInput = {
    id?: string
    dataId: string
    name: string
    lists?: XOR<TDeDListListCreateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
    data?: TemplateDataUpdateOneRequiredWithoutDedsNestedInput
  }

  export type TemplateDEDUncheckedUpdateInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDCreateManyInput = {
    id?: string
    dataId: string
    name: string
    lists?: XOR<TDeDListListCreateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDUncheckedUpdateManyInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type SpaceCreateInput = {
    id?: string
    name: string
    long: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    width: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    height: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    amount: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
    ref: TemplateDataCreateNestedOneWithoutSpacesInput
  }

  export type SpaceUncheckedCreateInput = {
    id?: string
    refId: string
    name: string
    long: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    width: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    height: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    amount: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
    ref?: TemplateDataUpdateOneRequiredWithoutSpacesNestedInput
  }

  export type SpaceUncheckedUpdateInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceCreateManyInput = {
    id?: string
    refId: string
    name: string
    long: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    width: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    height: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    amount: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceUncheckedUpdateManyInput = {
    refId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type StageCreateInput = {
    id?: string
    type: StageType
    operation: StageOpr
    parentId?: string | null
    refs?: string | null
    refParent?: boolean | null
    name?: string | null
    long: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    width: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    height: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    amount: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
    work: TemplateWorkCreateNestedOneWithoutStagesInput
  }

  export type StageUncheckedCreateInput = {
    id?: string
    workId: string
    type: StageType
    operation: StageOpr
    parentId?: string | null
    refs?: string | null
    refParent?: boolean | null
    name?: string | null
    long: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    width: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    height: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    amount: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type StageUpdateInput = {
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
    work?: TemplateWorkUpdateOneRequiredWithoutStagesNestedInput
  }

  export type StageUncheckedUpdateInput = {
    workId?: StringFieldUpdateOperationsInput | string
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type StageCreateManyInput = {
    id?: string
    workId: string
    type: StageType
    operation: StageOpr
    parentId?: string | null
    refs?: string | null
    refParent?: boolean | null
    name?: string | null
    long: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    width: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    height: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    amount: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type StageUpdateManyMutationInput = {
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type StageUncheckedUpdateManyInput = {
    workId?: StringFieldUpdateOperationsInput | string
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type EnumHistoriTypeFilter = {
    equals?: HistoriType
    in?: Enumerable<HistoriType>
    notIn?: Enumerable<HistoriType>
    not?: NestedEnumHistoriTypeFilter | HistoriType
  }

  export type EnumHistoriModelFilter = {
    equals?: HistoriModel
    in?: Enumerable<HistoriModel>
    notIn?: Enumerable<HistoriModel>
    not?: NestedEnumHistoriModelFilter | HistoriModel
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type OptionRelationFilter = {
    is?: OptionWhereInput
    isNot?: OptionWhereInput
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type WorkRelationFilter = {
    is?: WorkWhereInput
    isNot?: WorkWhereInput
  }

  export type WorkItemsRelationFilter = {
    is?: WorkItemsWhereInput | null
    isNot?: WorkItemsWhereInput | null
  }

  export type TemplateRelationFilter = {
    is?: TemplateWhereInput | null
    isNot?: TemplateWhereInput | null
  }

  export type ImageRelationFilter = {
    is?: ImageWhereInput
    isNot?: ImageWhereInput
  }

  export type FileRelationFilter = {
    is?: FileWhereInput | null
    isNot?: FileWhereInput | null
  }

  export type HistoriCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    model?: SortOrder
    step?: SortOrder
    message?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    optionId?: SortOrder
    unitId?: SortOrder
    itemId?: SortOrder
    workId?: SortOrder
    workItemsId?: SortOrder
    templateId?: SortOrder
    imageId?: SortOrder
    fileId?: SortOrder
  }

  export type HistoriAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type HistoriMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    model?: SortOrder
    step?: SortOrder
    message?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    optionId?: SortOrder
    unitId?: SortOrder
    itemId?: SortOrder
    workId?: SortOrder
    workItemsId?: SortOrder
    templateId?: SortOrder
    imageId?: SortOrder
    fileId?: SortOrder
  }

  export type HistoriMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    model?: SortOrder
    step?: SortOrder
    message?: SortOrder
    refId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    optionId?: SortOrder
    unitId?: SortOrder
    itemId?: SortOrder
    workId?: SortOrder
    workItemsId?: SortOrder
    templateId?: SortOrder
    imageId?: SortOrder
    fileId?: SortOrder
  }

  export type HistoriSumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type EnumHistoriTypeWithAggregatesFilter = {
    equals?: HistoriType
    in?: Enumerable<HistoriType>
    notIn?: Enumerable<HistoriType>
    not?: NestedEnumHistoriTypeWithAggregatesFilter | HistoriType
    _count?: NestedIntFilter
    _min?: NestedEnumHistoriTypeFilter
    _max?: NestedEnumHistoriTypeFilter
  }

  export type EnumHistoriModelWithAggregatesFilter = {
    equals?: HistoriModel
    in?: Enumerable<HistoriModel>
    notIn?: Enumerable<HistoriModel>
    not?: NestedEnumHistoriModelWithAggregatesFilter | HistoriModel
    _count?: NestedIntFilter
    _min?: NestedEnumHistoriModelFilter
    _max?: NestedEnumHistoriModelFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    userId?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    model?: SortOrder
    manufacturer?: SortOrder
    userId?: SortOrder
  }

  export type AddressCompositeFilter = {
    equals?: AddressObjectEqualityInput
    is?: AddressWhereInput
    isNot?: AddressWhereInput
  }

  export type AddressObjectEqualityInput = {
    provinsi: string
    kabupaten: string
    kecamatan: string
    kelurahan: string
    kodepos: string
    jalan: string
    coordinate?: CoordinateObjectEqualityInput | null
  }

  export type TPhoneNullableCompositeFilter = {
    equals?: TPhoneObjectEqualityInput | null
    is?: TPhoneWhereInput | null
    isNot?: TPhoneWhereInput | null
    isSet?: boolean
  }

  export type TPhoneObjectEqualityInput = {
    code: string
    number: number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type HistoriListRelationFilter = {
    every?: HistoriWhereInput
    some?: HistoriWhereInput
    none?: HistoriWhereInput
  }

  export type AddressOrderByInput = {
    provinsi?: SortOrder
    kabupaten?: SortOrder
    kecamatan?: SortOrder
    kelurahan?: SortOrder
    kodepos?: SortOrder
    jalan?: SortOrder
    coordinate?: CoordinateOrderByInput
  }

  export type TPhoneOrderByInput = {
    code?: SortOrder
    number?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HistoriOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    name?: SortOrder
    limit?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    limit?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    name?: SortOrder
    limit?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    gid?: SortOrder
    name?: SortOrder
    limit?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    limit?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type EnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    role?: SortOrder
    active?: SortOrder
    companyId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    role?: SortOrder
    active?: SortOrder
    companyId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    passhash?: SortOrder
    role?: SortOrder
    active?: SortOrder
    companyId?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type TemplateFieldListRelationFilter = {
    every?: TemplateFieldWhereInput
    some?: TemplateFieldWhereInput
    none?: TemplateFieldWhereInput
  }

  export type TemplateFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumOptionTypeFilter = {
    equals?: OptionType
    in?: Enumerable<OptionType>
    notIn?: Enumerable<OptionType>
    not?: NestedEnumOptionTypeFilter | OptionType
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type WorkListRelationFilter = {
    every?: WorkWhereInput
    some?: WorkWhereInput
    none?: WorkWhereInput
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OptionTypeNameCompoundUniqueInput = {
    type: OptionType
    name: string
  }

  export type OptionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type OptionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type OptionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type EnumOptionTypeWithAggregatesFilter = {
    equals?: OptionType
    in?: Enumerable<OptionType>
    notIn?: Enumerable<OptionType>
    not?: NestedEnumOptionTypeWithAggregatesFilter | OptionType
    _count?: NestedIntFilter
    _min?: NestedEnumOptionTypeFilter
    _max?: NestedEnumOptionTypeFilter
  }

  export type WorkItemsListRelationFilter = {
    every?: WorkItemsWhereInput
    some?: WorkItemsWhereInput
    none?: WorkItemsWhereInput
  }

  export type TemplateWorkItemListRelationFilter = {
    every?: TemplateWorkItemWhereInput
    some?: TemplateWorkItemWhereInput
    none?: TemplateWorkItemWhereInput
  }

  export type WorkItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateWorkItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EnumItemModelFilter = {
    equals?: ItemModel
    in?: Enumerable<ItemModel>
    notIn?: Enumerable<ItemModel>
    not?: NestedEnumItemModelFilter | ItemModel
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    categoryId?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    trim?: SortOrder
    active?: SortOrder
    introIds?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    categoryId?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    trim?: SortOrder
    active?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    categoryId?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
    code?: SortOrder
    name?: SortOrder
    price?: SortOrder
    trim?: SortOrder
    active?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumItemModelWithAggregatesFilter = {
    equals?: ItemModel
    in?: Enumerable<ItemModel>
    notIn?: Enumerable<ItemModel>
    not?: NestedEnumItemModelWithAggregatesFilter | ItemModel
    _count?: NestedIntFilter
    _min?: NestedEnumItemModelFilter
    _max?: NestedEnumItemModelFilter
  }

  export type EnumWorkModelFilter = {
    equals?: WorkModel
    in?: Enumerable<WorkModel>
    notIn?: Enumerable<WorkModel>
    not?: NestedEnumWorkModelFilter | WorkModel
  }

  export type TemplateWorkListRelationFilter = {
    every?: TemplateWorkWhereInput
    some?: TemplateWorkWhereInput
    none?: TemplateWorkWhereInput
  }

  export type TemplateWorkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkCountOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
  }

  export type WorkMaxOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
  }

  export type WorkMinOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    code?: SortOrder
    name?: SortOrder
    active?: SortOrder
    typeId?: SortOrder
    unitId?: SortOrder
  }

  export type EnumWorkModelWithAggregatesFilter = {
    equals?: WorkModel
    in?: Enumerable<WorkModel>
    notIn?: Enumerable<WorkModel>
    not?: NestedEnumWorkModelWithAggregatesFilter | WorkModel
    _count?: NestedIntFilter
    _min?: NestedEnumWorkModelFilter
    _max?: NestedEnumWorkModelFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type WorkItemsCountOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    workId?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
  }

  export type WorkItemsAvgOrderByAggregateInput = {
    coefficient?: SortOrder
  }

  export type WorkItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    workId?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
  }

  export type WorkItemsMinOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    workId?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
  }

  export type WorkItemsSumOrderByAggregateInput = {
    coefficient?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type TemplateDataRelationFilter = {
    is?: TemplateDataWhereInput | null
    isNot?: TemplateDataWhereInput | null
  }

  export type TemplateDataListRelationFilter = {
    every?: TemplateDataWhereInput
    some?: TemplateDataWhereInput
    none?: TemplateDataWhereInput
  }

  export type TemplateDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    activeId?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    activeId?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    activeId?: SortOrder
  }

  export type TemplateWorkRelationFilter = {
    is?: TemplateWorkWhereInput
    isNot?: TemplateWorkWhereInput
  }

  export type TemplateWorkItemParentIdItemIdCompoundUniqueInput = {
    parentId: string
    itemId: string
  }

  export type TemplateWorkItemCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    parentId?: SortOrder
  }

  export type TemplateWorkItemAvgOrderByAggregateInput = {
    coefficient?: SortOrder
  }

  export type TemplateWorkItemMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    parentId?: SortOrder
  }

  export type TemplateWorkItemMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    coefficient?: SortOrder
    unitId?: SortOrder
    parentId?: SortOrder
  }

  export type TemplateWorkItemSumOrderByAggregateInput = {
    coefficient?: SortOrder
  }

  export type StageListRelationFilter = {
    every?: StageWhereInput
    some?: StageWhereInput
    none?: StageWhereInput
  }

  export type StageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateWorkCountOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    workId?: SortOrder
  }

  export type TemplateWorkMaxOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    workId?: SortOrder
  }

  export type TemplateWorkMinOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    workId?: SortOrder
  }

  export type TAroundNullableCompositeFilter = {
    equals?: TAroundObjectEqualityInput | null
    is?: TAroundWhereInput | null
    isNot?: TAroundWhereInput | null
    isSet?: boolean
  }

  export type TAroundObjectEqualityInput = {
    long?: string | null
    width?: string | null
    height?: string | null
  }

  export type TPropertyCompositeFilter = {
    equals?: TPropertyObjectEqualityInput
    is?: TPropertyWhereInput
    isNot?: TPropertyWhereInput
  }

  export type TPropertyObjectEqualityInput = {
    images?: string | null
    intros?: Enumerable<TPropertyIntroObjectEqualityInput>
    prices?: Enumerable<TPropertyPriceObjectEqualityInput>
    pph: boolean
    ppn: boolean
    pphVal: number
    ppnVal: number
  }

  export type SpaceListRelationFilter = {
    every?: SpaceWhereInput
    some?: SpaceWhereInput
    none?: SpaceWhereInput
  }

  export type TemplateDEDListRelationFilter = {
    every?: TemplateDEDWhereInput
    some?: TemplateDEDWhereInput
    none?: TemplateDEDWhereInput
  }

  export type TAroundOrderByInput = {
    long?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type TPropertyOrderByInput = {
    images?: SortOrder
    intros?: TPropertyIntroOrderByCompositeAggregateInput
    prices?: TPropertyPriceOrderByCompositeAggregateInput
    pph?: SortOrder
    ppn?: SortOrder
    pphVal?: SortOrder
    ppnVal?: SortOrder
  }

  export type SpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateDEDOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateDataCountOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    publish?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateDataAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type TemplateDataMaxOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    publish?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateDataMinOrderByAggregateInput = {
    id?: SortOrder
    step?: SortOrder
    publish?: SortOrder
    templateId?: SortOrder
  }

  export type TemplateDataSumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type TFieldListCompositeListFilter = {
    equals?: Enumerable<TFieldListObjectEqualityInput>
    every?: TFieldListWhereInput
    some?: TFieldListWhereInput
    none?: TFieldListWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TFieldListObjectEqualityInput = {
    id: string
    name: string
    type: EFieldType
  }

  export type TFieldListOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateFieldCountOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    imageId?: SortOrder
    imageUrl?: SortOrder
  }

  export type TemplateFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    imageId?: SortOrder
    imageUrl?: SortOrder
  }

  export type TemplateFieldMinOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
    imageId?: SortOrder
    imageUrl?: SortOrder
  }

  export type TDeDListCompositeListFilter = {
    equals?: Enumerable<TDeDListObjectEqualityInput>
    every?: TDeDListWhereInput
    some?: TDeDListWhereInput
    none?: TDeDListWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TDeDListObjectEqualityInput = {
    id: string
    filename: string
    name: string
    url: string
    size: number
    width: number
    height: number
    top: number
    left: number
    type: string
  }

  export type TDeDListOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateDEDCountOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
  }

  export type TemplateDEDMaxOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
  }

  export type TemplateDEDMinOrderByAggregateInput = {
    id?: SortOrder
    dataId?: SortOrder
    name?: SortOrder
  }

  export type SpaceValueCompositeFilter = {
    equals?: SpaceValueObjectEqualityInput
    is?: SpaceValueWhereInput
    isNot?: SpaceValueWhereInput
  }

  export type SpaceValueObjectEqualityInput = {
    fixed: boolean
    value: number
    min: number
    max: number
  }

  export type TValuesCompositeFilter = {
    equals?: TValuesObjectEqualityInput
    is?: TValuesWhereInput
    isNot?: TValuesWhereInput
  }

  export type TValuesObjectEqualityInput = {
    around: number
    broad: number
    volume: number
  }

  export type SpaceValueOrderByInput = {
    fixed?: SortOrder
    value?: SortOrder
    min?: SortOrder
    max?: SortOrder
  }

  export type TValuesOrderByInput = {
    around?: SortOrder
    broad?: SortOrder
    volume?: SortOrder
  }

  export type SpaceCountOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
  }

  export type SpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
  }

  export type SpaceMinOrderByAggregateInput = {
    id?: SortOrder
    refId?: SortOrder
    name?: SortOrder
  }

  export type EnumStageTypeFilter = {
    equals?: StageType
    in?: Enumerable<StageType>
    notIn?: Enumerable<StageType>
    not?: NestedEnumStageTypeFilter | StageType
  }

  export type EnumStageOprFilter = {
    equals?: StageOpr
    in?: Enumerable<StageOpr>
    notIn?: Enumerable<StageOpr>
    not?: NestedEnumStageOprFilter | StageOpr
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type StageValueCompositeFilter = {
    equals?: StageValueObjectEqualityInput
    is?: StageValueWhereInput
    isNot?: StageValueWhereInput
  }

  export type StageValueObjectEqualityInput = {
    ref?: string | null
    refal?: number | null
    value: number
  }

  export type StageValueOrderByInput = {
    ref?: SortOrder
    refal?: SortOrder
    value?: SortOrder
  }

  export type StageCountOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    type?: SortOrder
    operation?: SortOrder
    parentId?: SortOrder
    refs?: SortOrder
    refParent?: SortOrder
    name?: SortOrder
  }

  export type StageMaxOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    type?: SortOrder
    operation?: SortOrder
    parentId?: SortOrder
    refs?: SortOrder
    refParent?: SortOrder
    name?: SortOrder
  }

  export type StageMinOrderByAggregateInput = {
    id?: SortOrder
    workId?: SortOrder
    type?: SortOrder
    operation?: SortOrder
    parentId?: SortOrder
    refs?: SortOrder
    refParent?: SortOrder
    name?: SortOrder
  }

  export type EnumStageTypeWithAggregatesFilter = {
    equals?: StageType
    in?: Enumerable<StageType>
    notIn?: Enumerable<StageType>
    not?: NestedEnumStageTypeWithAggregatesFilter | StageType
    _count?: NestedIntFilter
    _min?: NestedEnumStageTypeFilter
    _max?: NestedEnumStageTypeFilter
  }

  export type EnumStageOprWithAggregatesFilter = {
    equals?: StageOpr
    in?: Enumerable<StageOpr>
    notIn?: Enumerable<StageOpr>
    not?: NestedEnumStageOprWithAggregatesFilter | StageOpr
    _count?: NestedIntFilter
    _min?: NestedEnumStageOprFilter
    _max?: NestedEnumStageOprFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type UserCreateNestedOneWithoutTrackersInput = {
    create?: XOR<UserCreateWithoutTrackersInput, UserUncheckedCreateWithoutTrackersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHistorisInput = {
    create?: XOR<UserCreateWithoutHistorisInput, UserUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistorisInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutHistorisInput = {
    create?: XOR<CompanyCreateWithoutHistorisInput, CompanyUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutHistorisInput
    connect?: CompanyWhereUniqueInput
  }

  export type OptionCreateNestedOneWithoutHistorisInput = {
    create?: XOR<OptionCreateWithoutHistorisInput, OptionUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: OptionCreateOrConnectWithoutHistorisInput
    connect?: OptionWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutHistorisInput = {
    create?: XOR<UnitCreateWithoutHistorisInput, UnitUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: UnitCreateOrConnectWithoutHistorisInput
    connect?: UnitWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutHistorisInput = {
    create?: XOR<ItemCreateWithoutHistorisInput, ItemUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: ItemCreateOrConnectWithoutHistorisInput
    connect?: ItemWhereUniqueInput
  }

  export type WorkCreateNestedOneWithoutHistorisInput = {
    create?: XOR<WorkCreateWithoutHistorisInput, WorkUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: WorkCreateOrConnectWithoutHistorisInput
    connect?: WorkWhereUniqueInput
  }

  export type WorkItemsCreateNestedOneWithoutHistorisInput = {
    create?: XOR<WorkItemsCreateWithoutHistorisInput, WorkItemsUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: WorkItemsCreateOrConnectWithoutHistorisInput
    connect?: WorkItemsWhereUniqueInput
  }

  export type TemplateCreateNestedOneWithoutHistorisInput = {
    create?: XOR<TemplateCreateWithoutHistorisInput, TemplateUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutHistorisInput
    connect?: TemplateWhereUniqueInput
  }

  export type ImageCreateNestedOneWithoutHistorisInput = {
    create?: XOR<ImageCreateWithoutHistorisInput, ImageUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: ImageCreateOrConnectWithoutHistorisInput
    connect?: ImageWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutHistorisInput = {
    create?: XOR<FileCreateWithoutHistorisInput, FileUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: FileCreateOrConnectWithoutHistorisInput
    connect?: FileWhereUniqueInput
  }

  export type EnumHistoriTypeFieldUpdateOperationsInput = {
    set?: HistoriType
  }

  export type EnumHistoriModelFieldUpdateOperationsInput = {
    set?: HistoriModel
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutTrackersNestedInput = {
    create?: XOR<UserCreateWithoutTrackersInput, UserUncheckedCreateWithoutTrackersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTrackersInput
    upsert?: UserUpsertWithoutTrackersInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTrackersInput, UserUncheckedUpdateWithoutTrackersInput>
  }

  export type UserUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<UserCreateWithoutHistorisInput, UserUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: UserCreateOrConnectWithoutHistorisInput
    upsert?: UserUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutHistorisInput, UserUncheckedUpdateWithoutHistorisInput>
  }

  export type CompanyUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<CompanyCreateWithoutHistorisInput, CompanyUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutHistorisInput
    upsert?: CompanyUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutHistorisInput, CompanyUncheckedUpdateWithoutHistorisInput>
  }

  export type OptionUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<OptionCreateWithoutHistorisInput, OptionUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: OptionCreateOrConnectWithoutHistorisInput
    upsert?: OptionUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: OptionWhereUniqueInput
    update?: XOR<OptionUpdateWithoutHistorisInput, OptionUncheckedUpdateWithoutHistorisInput>
  }

  export type UnitUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<UnitCreateWithoutHistorisInput, UnitUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: UnitCreateOrConnectWithoutHistorisInput
    upsert?: UnitUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<UnitUpdateWithoutHistorisInput, UnitUncheckedUpdateWithoutHistorisInput>
  }

  export type ItemUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<ItemCreateWithoutHistorisInput, ItemUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: ItemCreateOrConnectWithoutHistorisInput
    upsert?: ItemUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutHistorisInput, ItemUncheckedUpdateWithoutHistorisInput>
  }

  export type WorkUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<WorkCreateWithoutHistorisInput, WorkUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: WorkCreateOrConnectWithoutHistorisInput
    upsert?: WorkUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: WorkWhereUniqueInput
    update?: XOR<WorkUpdateWithoutHistorisInput, WorkUncheckedUpdateWithoutHistorisInput>
  }

  export type WorkItemsUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<WorkItemsCreateWithoutHistorisInput, WorkItemsUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: WorkItemsCreateOrConnectWithoutHistorisInput
    upsert?: WorkItemsUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: WorkItemsWhereUniqueInput
    update?: XOR<WorkItemsUpdateWithoutHistorisInput, WorkItemsUncheckedUpdateWithoutHistorisInput>
  }

  export type TemplateUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<TemplateCreateWithoutHistorisInput, TemplateUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutHistorisInput
    upsert?: TemplateUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: TemplateWhereUniqueInput
    update?: XOR<TemplateUpdateWithoutHistorisInput, TemplateUncheckedUpdateWithoutHistorisInput>
  }

  export type ImageUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<ImageCreateWithoutHistorisInput, ImageUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: ImageCreateOrConnectWithoutHistorisInput
    upsert?: ImageUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: ImageWhereUniqueInput
    update?: XOR<ImageUpdateWithoutHistorisInput, ImageUncheckedUpdateWithoutHistorisInput>
  }

  export type FileUpdateOneWithoutHistorisNestedInput = {
    create?: XOR<FileCreateWithoutHistorisInput, FileUncheckedCreateWithoutHistorisInput>
    connectOrCreate?: FileCreateOrConnectWithoutHistorisInput
    upsert?: FileUpsertWithoutHistorisInput
    disconnect?: boolean
    delete?: boolean
    connect?: FileWhereUniqueInput
    update?: XOR<FileUpdateWithoutHistorisInput, FileUncheckedUpdateWithoutHistorisInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type AddressCreateEnvelopeInput = {
    set?: AddressCreateInput
  }

  export type AddressCreateInput = {
    provinsi: string
    kabupaten: string
    kecamatan: string
    kelurahan: string
    kodepos: string
    jalan: string
    coordinate?: CoordinateCreateInput | null
  }

  export type TPhoneNullableCreateEnvelopeInput = {
    set?: TPhoneCreateInput | null
  }

  export type TPhoneCreateInput = {
    code: string
    number: number
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutCompanyInput>, Enumerable<HistoriUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutCompanyInput>
    createMany?: HistoriCreateManyCompanyInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutCompanyInput>, Enumerable<HistoriUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutCompanyInput>
    createMany?: HistoriCreateManyCompanyInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type AddressUpdateEnvelopeInput = {
    set?: AddressCreateInput
    update?: AddressUpdateInput
  }

  export type TPhoneNullableUpdateEnvelopeInput = {
    set?: TPhoneCreateInput | null
    upsert?: TPhoneUpsertInput
    unset?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutCompanyInput>, Enumerable<HistoriUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: HistoriCreateManyCompanyInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutCompanyInput>, Enumerable<UserUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutCompanyInput>, Enumerable<HistoriUncheckedCreateWithoutCompanyInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutCompanyInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutCompanyInput>
    createMany?: HistoriCreateManyCompanyInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutCompanyInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutCompanyInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type HistoriCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutRefInput>, Enumerable<HistoriUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutRefInput>
    createMany?: HistoriCreateManyRefInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUserInput>, Enumerable<HistoriUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUserInput>
    createMany?: HistoriCreateManyUserInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type DeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DeviceCreateWithoutUserInput>, Enumerable<DeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceCreateOrConnectWithoutUserInput>
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: Enumerable<DeviceWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutRefInput>, Enumerable<HistoriUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutRefInput>
    createMany?: HistoriCreateManyRefInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUserInput>, Enumerable<HistoriUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUserInput>
    createMany?: HistoriCreateManyUserInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type DeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DeviceCreateWithoutUserInput>, Enumerable<DeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceCreateOrConnectWithoutUserInput>
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: Enumerable<DeviceWhereUniqueInput>
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type CompanyUpdateOneWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    disconnect?: boolean
    delete?: boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type HistoriUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutRefInput>, Enumerable<HistoriUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutRefInput>
    createMany?: HistoriCreateManyRefInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUserInput>, Enumerable<HistoriUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HistoriCreateManyUserInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type DeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DeviceCreateWithoutUserInput>, Enumerable<DeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DeviceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: Enumerable<DeviceWhereUniqueInput>
    disconnect?: Enumerable<DeviceWhereUniqueInput>
    delete?: Enumerable<DeviceWhereUniqueInput>
    connect?: Enumerable<DeviceWhereUniqueInput>
    update?: Enumerable<DeviceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DeviceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DeviceScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutRefInput>, Enumerable<HistoriUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutRefInput>
    createMany?: HistoriCreateManyRefInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUserInput>, Enumerable<HistoriUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutUserInput>
    createMany?: HistoriCreateManyUserInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type DeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DeviceCreateWithoutUserInput>, Enumerable<DeviceUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DeviceCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DeviceUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: Enumerable<DeviceWhereUniqueInput>
    disconnect?: Enumerable<DeviceWhereUniqueInput>
    delete?: Enumerable<DeviceWhereUniqueInput>
    connect?: Enumerable<DeviceWhereUniqueInput>
    update?: Enumerable<DeviceUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DeviceUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DeviceScalarWhereInput>
  }

  export type ImageCreateNestedOneWithoutFilesInput = {
    create?: XOR<ImageCreateWithoutFilesInput, ImageUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutFilesInput
    connect?: ImageWhereUniqueInput
  }

  export type HistoriCreateNestedManyWithoutFileInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutFileInput>, Enumerable<HistoriUncheckedCreateWithoutFileInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutFileInput>
    createMany?: HistoriCreateManyFileInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateFieldCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutImageInput>, Enumerable<TemplateFieldUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutImageInput>
    createMany?: TemplateFieldCreateManyImageInputEnvelope
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutFileInput>, Enumerable<HistoriUncheckedCreateWithoutFileInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutFileInput>
    createMany?: HistoriCreateManyFileInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateFieldUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutImageInput>, Enumerable<TemplateFieldUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutImageInput>
    createMany?: TemplateFieldCreateManyImageInputEnvelope
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
  }

  export type ImageUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<ImageCreateWithoutFilesInput, ImageUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ImageCreateOrConnectWithoutFilesInput
    upsert?: ImageUpsertWithoutFilesInput
    connect?: ImageWhereUniqueInput
    update?: XOR<ImageUpdateWithoutFilesInput, ImageUncheckedUpdateWithoutFilesInput>
  }

  export type HistoriUpdateManyWithoutFileNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutFileInput>, Enumerable<HistoriUncheckedCreateWithoutFileInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutFileInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutFileInput>
    createMany?: HistoriCreateManyFileInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutFileInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutFileInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateFieldUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutImageInput>, Enumerable<TemplateFieldUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<TemplateFieldUpsertWithWhereUniqueWithoutImageInput>
    createMany?: TemplateFieldCreateManyImageInputEnvelope
    set?: Enumerable<TemplateFieldWhereUniqueInput>
    disconnect?: Enumerable<TemplateFieldWhereUniqueInput>
    delete?: Enumerable<TemplateFieldWhereUniqueInput>
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
    update?: Enumerable<TemplateFieldUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<TemplateFieldUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<TemplateFieldScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutFileInput>, Enumerable<HistoriUncheckedCreateWithoutFileInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutFileInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutFileInput>
    createMany?: HistoriCreateManyFileInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutFileInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutFileInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateFieldUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutImageInput>, Enumerable<TemplateFieldUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<TemplateFieldUpsertWithWhereUniqueWithoutImageInput>
    createMany?: TemplateFieldCreateManyImageInputEnvelope
    set?: Enumerable<TemplateFieldWhereUniqueInput>
    disconnect?: Enumerable<TemplateFieldWhereUniqueInput>
    delete?: Enumerable<TemplateFieldWhereUniqueInput>
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
    update?: Enumerable<TemplateFieldUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<TemplateFieldUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<TemplateFieldScalarWhereInput>
  }

  export type FileCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FileCreateWithoutGroupInput>, Enumerable<FileUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutGroupInput>
    createMany?: FileCreateManyGroupInputEnvelope
    connect?: Enumerable<FileWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutImageInput>, Enumerable<HistoriUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutImageInput>
    createMany?: HistoriCreateManyImageInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type FileUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<Enumerable<FileCreateWithoutGroupInput>, Enumerable<FileUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutGroupInput>
    createMany?: FileCreateManyGroupInputEnvelope
    connect?: Enumerable<FileWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutImageInput>, Enumerable<HistoriUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutImageInput>
    createMany?: HistoriCreateManyImageInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type FileUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FileCreateWithoutGroupInput>, Enumerable<FileUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FileUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FileCreateManyGroupInputEnvelope
    set?: Enumerable<FileWhereUniqueInput>
    disconnect?: Enumerable<FileWhereUniqueInput>
    delete?: Enumerable<FileWhereUniqueInput>
    connect?: Enumerable<FileWhereUniqueInput>
    update?: Enumerable<FileUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FileUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FileScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutImageInput>, Enumerable<HistoriUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutImageInput>
    createMany?: HistoriCreateManyImageInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type FileUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<Enumerable<FileCreateWithoutGroupInput>, Enumerable<FileUncheckedCreateWithoutGroupInput>>
    connectOrCreate?: Enumerable<FileCreateOrConnectWithoutGroupInput>
    upsert?: Enumerable<FileUpsertWithWhereUniqueWithoutGroupInput>
    createMany?: FileCreateManyGroupInputEnvelope
    set?: Enumerable<FileWhereUniqueInput>
    disconnect?: Enumerable<FileWhereUniqueInput>
    delete?: Enumerable<FileWhereUniqueInput>
    connect?: Enumerable<FileWhereUniqueInput>
    update?: Enumerable<FileUpdateWithWhereUniqueWithoutGroupInput>
    updateMany?: Enumerable<FileUpdateManyWithWhereWithoutGroupInput>
    deleteMany?: Enumerable<FileScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutImageInput>, Enumerable<HistoriUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutImageInput>
    createMany?: HistoriCreateManyImageInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type ItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type WorkCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<WorkCreateWithoutTypeInput>, Enumerable<WorkUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutTypeInput>
    createMany?: WorkCreateManyTypeInputEnvelope
    connect?: Enumerable<WorkWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutOptionInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutOptionInput>, Enumerable<HistoriUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutOptionInput>
    createMany?: HistoriCreateManyOptionInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type WorkUncheckedCreateNestedManyWithoutTypeInput = {
    create?: XOR<Enumerable<WorkCreateWithoutTypeInput>, Enumerable<WorkUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutTypeInput>
    createMany?: WorkCreateManyTypeInputEnvelope
    connect?: Enumerable<WorkWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutOptionInput>, Enumerable<HistoriUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutOptionInput>
    createMany?: HistoriCreateManyOptionInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type EnumOptionTypeFieldUpdateOperationsInput = {
    set?: OptionType
  }

  export type ItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type WorkUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<WorkCreateWithoutTypeInput>, Enumerable<WorkUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<WorkUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: WorkCreateManyTypeInputEnvelope
    set?: Enumerable<WorkWhereUniqueInput>
    disconnect?: Enumerable<WorkWhereUniqueInput>
    delete?: Enumerable<WorkWhereUniqueInput>
    connect?: Enumerable<WorkWhereUniqueInput>
    update?: Enumerable<WorkUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<WorkUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<WorkScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutOptionNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutOptionInput>, Enumerable<HistoriUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutOptionInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutOptionInput>
    createMany?: HistoriCreateManyOptionInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutOptionInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutOptionInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutCategoryInput>, Enumerable<ItemUncheckedCreateWithoutCategoryInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutCategoryInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutCategoryInput>
    createMany?: ItemCreateManyCategoryInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutCategoryInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutCategoryInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutTypeInput>, Enumerable<ItemUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: ItemCreateManyTypeInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type WorkUncheckedUpdateManyWithoutTypeNestedInput = {
    create?: XOR<Enumerable<WorkCreateWithoutTypeInput>, Enumerable<WorkUncheckedCreateWithoutTypeInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutTypeInput>
    upsert?: Enumerable<WorkUpsertWithWhereUniqueWithoutTypeInput>
    createMany?: WorkCreateManyTypeInputEnvelope
    set?: Enumerable<WorkWhereUniqueInput>
    disconnect?: Enumerable<WorkWhereUniqueInput>
    delete?: Enumerable<WorkWhereUniqueInput>
    connect?: Enumerable<WorkWhereUniqueInput>
    update?: Enumerable<WorkUpdateWithWhereUniqueWithoutTypeInput>
    updateMany?: Enumerable<WorkUpdateManyWithWhereWithoutTypeInput>
    deleteMany?: Enumerable<WorkScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutOptionInput>, Enumerable<HistoriUncheckedCreateWithoutOptionInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutOptionInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutOptionInput>
    createMany?: HistoriCreateManyOptionInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutOptionInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutOptionInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type ItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUnitInput>, Enumerable<ItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUnitInput>
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type WorkCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<WorkCreateWithoutUnitInput>, Enumerable<WorkUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutUnitInput>
    createMany?: WorkCreateManyUnitInputEnvelope
    connect?: Enumerable<WorkWhereUniqueInput>
  }

  export type WorkItemsCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutUnitInput>, Enumerable<WorkItemsUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutUnitInput>
    createMany?: WorkItemsCreateManyUnitInputEnvelope
    connect?: Enumerable<WorkItemsWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUnitInput>, Enumerable<HistoriUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUnitInput>
    createMany?: HistoriCreateManyUnitInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateWorkItemCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutUnitInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutUnitInput>
    createMany?: TemplateWorkItemCreateManyUnitInputEnvelope
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
  }

  export type ItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUnitInput>, Enumerable<ItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUnitInput>
    createMany?: ItemCreateManyUnitInputEnvelope
    connect?: Enumerable<ItemWhereUniqueInput>
  }

  export type WorkUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<WorkCreateWithoutUnitInput>, Enumerable<WorkUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutUnitInput>
    createMany?: WorkCreateManyUnitInputEnvelope
    connect?: Enumerable<WorkWhereUniqueInput>
  }

  export type WorkItemsUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutUnitInput>, Enumerable<WorkItemsUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutUnitInput>
    createMany?: WorkItemsCreateManyUnitInputEnvelope
    connect?: Enumerable<WorkItemsWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUnitInput>, Enumerable<HistoriUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUnitInput>
    createMany?: HistoriCreateManyUnitInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateWorkItemUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutUnitInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutUnitInput>
    createMany?: TemplateWorkItemCreateManyUnitInputEnvelope
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
  }

  export type ItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUnitInput>, Enumerable<ItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type WorkUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<WorkCreateWithoutUnitInput>, Enumerable<WorkUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<WorkUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: WorkCreateManyUnitInputEnvelope
    set?: Enumerable<WorkWhereUniqueInput>
    disconnect?: Enumerable<WorkWhereUniqueInput>
    delete?: Enumerable<WorkWhereUniqueInput>
    connect?: Enumerable<WorkWhereUniqueInput>
    update?: Enumerable<WorkUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<WorkUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<WorkScalarWhereInput>
  }

  export type WorkItemsUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutUnitInput>, Enumerable<WorkItemsUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<WorkItemsUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: WorkItemsCreateManyUnitInputEnvelope
    set?: Enumerable<WorkItemsWhereUniqueInput>
    disconnect?: Enumerable<WorkItemsWhereUniqueInput>
    delete?: Enumerable<WorkItemsWhereUniqueInput>
    connect?: Enumerable<WorkItemsWhereUniqueInput>
    update?: Enumerable<WorkItemsUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<WorkItemsUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<WorkItemsScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUnitInput>, Enumerable<HistoriUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: HistoriCreateManyUnitInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateWorkItemUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutUnitInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<TemplateWorkItemUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: TemplateWorkItemCreateManyUnitInputEnvelope
    set?: Enumerable<TemplateWorkItemWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    delete?: Enumerable<TemplateWorkItemWhereUniqueInput>
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    update?: Enumerable<TemplateWorkItemUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<TemplateWorkItemUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<TemplateWorkItemScalarWhereInput>
  }

  export type ItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<ItemCreateWithoutUnitInput>, Enumerable<ItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<ItemCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<ItemUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: ItemCreateManyUnitInputEnvelope
    set?: Enumerable<ItemWhereUniqueInput>
    disconnect?: Enumerable<ItemWhereUniqueInput>
    delete?: Enumerable<ItemWhereUniqueInput>
    connect?: Enumerable<ItemWhereUniqueInput>
    update?: Enumerable<ItemUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<ItemUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<ItemScalarWhereInput>
  }

  export type WorkUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<WorkCreateWithoutUnitInput>, Enumerable<WorkUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<WorkUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: WorkCreateManyUnitInputEnvelope
    set?: Enumerable<WorkWhereUniqueInput>
    disconnect?: Enumerable<WorkWhereUniqueInput>
    delete?: Enumerable<WorkWhereUniqueInput>
    connect?: Enumerable<WorkWhereUniqueInput>
    update?: Enumerable<WorkUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<WorkUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<WorkScalarWhereInput>
  }

  export type WorkItemsUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutUnitInput>, Enumerable<WorkItemsUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<WorkItemsUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: WorkItemsCreateManyUnitInputEnvelope
    set?: Enumerable<WorkItemsWhereUniqueInput>
    disconnect?: Enumerable<WorkItemsWhereUniqueInput>
    delete?: Enumerable<WorkItemsWhereUniqueInput>
    connect?: Enumerable<WorkItemsWhereUniqueInput>
    update?: Enumerable<WorkItemsUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<WorkItemsUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<WorkItemsScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutUnitInput>, Enumerable<HistoriUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: HistoriCreateManyUnitInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateWorkItemUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutUnitInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<TemplateWorkItemUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: TemplateWorkItemCreateManyUnitInputEnvelope
    set?: Enumerable<TemplateWorkItemWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    delete?: Enumerable<TemplateWorkItemWhereUniqueInput>
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    update?: Enumerable<TemplateWorkItemUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<TemplateWorkItemUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<TemplateWorkItemScalarWhereInput>
  }

  export type ItemCreateintroIdsInput = {
    set: Enumerable<string>
  }

  export type OptionCreateNestedOneWithoutItemCategorysInput = {
    create?: XOR<OptionCreateWithoutItemCategorysInput, OptionUncheckedCreateWithoutItemCategorysInput>
    connectOrCreate?: OptionCreateOrConnectWithoutItemCategorysInput
    connect?: OptionWhereUniqueInput
  }

  export type OptionCreateNestedOneWithoutItemTypesInput = {
    create?: XOR<OptionCreateWithoutItemTypesInput, OptionUncheckedCreateWithoutItemTypesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutItemTypesInput
    connect?: OptionWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutItemsInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type WorkItemsCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutItemInput>, Enumerable<WorkItemsUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutItemInput>
    createMany?: WorkItemsCreateManyItemInputEnvelope
    connect?: Enumerable<WorkItemsWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutItemInput>, Enumerable<HistoriUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutItemInput>
    createMany?: HistoriCreateManyItemInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateWorkItemCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutItemInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutItemInput>
    createMany?: TemplateWorkItemCreateManyItemInputEnvelope
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
  }

  export type WorkItemsUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutItemInput>, Enumerable<WorkItemsUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutItemInput>
    createMany?: WorkItemsCreateManyItemInputEnvelope
    connect?: Enumerable<WorkItemsWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutItemInput>, Enumerable<HistoriUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutItemInput>
    createMany?: HistoriCreateManyItemInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutItemInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutItemInput>
    createMany?: TemplateWorkItemCreateManyItemInputEnvelope
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
  }

  export type EnumItemModelFieldUpdateOperationsInput = {
    set?: ItemModel
  }

  export type ItemUpdateintroIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type OptionUpdateOneRequiredWithoutItemCategorysNestedInput = {
    create?: XOR<OptionCreateWithoutItemCategorysInput, OptionUncheckedCreateWithoutItemCategorysInput>
    connectOrCreate?: OptionCreateOrConnectWithoutItemCategorysInput
    upsert?: OptionUpsertWithoutItemCategorysInput
    connect?: OptionWhereUniqueInput
    update?: XOR<OptionUpdateWithoutItemCategorysInput, OptionUncheckedUpdateWithoutItemCategorysInput>
  }

  export type OptionUpdateOneWithoutItemTypesNestedInput = {
    create?: XOR<OptionCreateWithoutItemTypesInput, OptionUncheckedCreateWithoutItemTypesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutItemTypesInput
    upsert?: OptionUpsertWithoutItemTypesInput
    disconnect?: boolean
    delete?: boolean
    connect?: OptionWhereUniqueInput
    update?: XOR<OptionUpdateWithoutItemTypesInput, OptionUncheckedUpdateWithoutItemTypesInput>
  }

  export type UnitUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutItemsInput
    upsert?: UnitUpsertWithoutItemsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
  }

  export type WorkItemsUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutItemInput>, Enumerable<WorkItemsUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<WorkItemsUpsertWithWhereUniqueWithoutItemInput>
    createMany?: WorkItemsCreateManyItemInputEnvelope
    set?: Enumerable<WorkItemsWhereUniqueInput>
    disconnect?: Enumerable<WorkItemsWhereUniqueInput>
    delete?: Enumerable<WorkItemsWhereUniqueInput>
    connect?: Enumerable<WorkItemsWhereUniqueInput>
    update?: Enumerable<WorkItemsUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<WorkItemsUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<WorkItemsScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutItemInput>, Enumerable<HistoriUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutItemInput>
    createMany?: HistoriCreateManyItemInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateWorkItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutItemInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<TemplateWorkItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: TemplateWorkItemCreateManyItemInputEnvelope
    set?: Enumerable<TemplateWorkItemWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    delete?: Enumerable<TemplateWorkItemWhereUniqueInput>
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    update?: Enumerable<TemplateWorkItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<TemplateWorkItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<TemplateWorkItemScalarWhereInput>
  }

  export type WorkItemsUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutItemInput>, Enumerable<WorkItemsUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<WorkItemsUpsertWithWhereUniqueWithoutItemInput>
    createMany?: WorkItemsCreateManyItemInputEnvelope
    set?: Enumerable<WorkItemsWhereUniqueInput>
    disconnect?: Enumerable<WorkItemsWhereUniqueInput>
    delete?: Enumerable<WorkItemsWhereUniqueInput>
    connect?: Enumerable<WorkItemsWhereUniqueInput>
    update?: Enumerable<WorkItemsUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<WorkItemsUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<WorkItemsScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutItemInput>, Enumerable<HistoriUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutItemInput>
    createMany?: HistoriCreateManyItemInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutItemInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutItemInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutItemInput>
    upsert?: Enumerable<TemplateWorkItemUpsertWithWhereUniqueWithoutItemInput>
    createMany?: TemplateWorkItemCreateManyItemInputEnvelope
    set?: Enumerable<TemplateWorkItemWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    delete?: Enumerable<TemplateWorkItemWhereUniqueInput>
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    update?: Enumerable<TemplateWorkItemUpdateWithWhereUniqueWithoutItemInput>
    updateMany?: Enumerable<TemplateWorkItemUpdateManyWithWhereWithoutItemInput>
    deleteMany?: Enumerable<TemplateWorkItemScalarWhereInput>
  }

  export type OptionCreateNestedOneWithoutWorkTypesInput = {
    create?: XOR<OptionCreateWithoutWorkTypesInput, OptionUncheckedCreateWithoutWorkTypesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutWorkTypesInput
    connect?: OptionWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutWorksInput = {
    create?: XOR<UnitCreateWithoutWorksInput, UnitUncheckedCreateWithoutWorksInput>
    connectOrCreate?: UnitCreateOrConnectWithoutWorksInput
    connect?: UnitWhereUniqueInput
  }

  export type WorkItemsCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutWorkInput>, Enumerable<WorkItemsUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutWorkInput>
    createMany?: WorkItemsCreateManyWorkInputEnvelope
    connect?: Enumerable<WorkItemsWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkInput>, Enumerable<HistoriUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkInput>
    createMany?: HistoriCreateManyWorkInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateWorkCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutWorkInput>, Enumerable<TemplateWorkUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutWorkInput>
    createMany?: TemplateWorkCreateManyWorkInputEnvelope
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
  }

  export type WorkItemsUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutWorkInput>, Enumerable<WorkItemsUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutWorkInput>
    createMany?: WorkItemsCreateManyWorkInputEnvelope
    connect?: Enumerable<WorkItemsWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkInput>, Enumerable<HistoriUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkInput>
    createMany?: HistoriCreateManyWorkInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateWorkUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutWorkInput>, Enumerable<TemplateWorkUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutWorkInput>
    createMany?: TemplateWorkCreateManyWorkInputEnvelope
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
  }

  export type EnumWorkModelFieldUpdateOperationsInput = {
    set?: WorkModel
  }

  export type OptionUpdateOneRequiredWithoutWorkTypesNestedInput = {
    create?: XOR<OptionCreateWithoutWorkTypesInput, OptionUncheckedCreateWithoutWorkTypesInput>
    connectOrCreate?: OptionCreateOrConnectWithoutWorkTypesInput
    upsert?: OptionUpsertWithoutWorkTypesInput
    connect?: OptionWhereUniqueInput
    update?: XOR<OptionUpdateWithoutWorkTypesInput, OptionUncheckedUpdateWithoutWorkTypesInput>
  }

  export type UnitUpdateOneRequiredWithoutWorksNestedInput = {
    create?: XOR<UnitCreateWithoutWorksInput, UnitUncheckedCreateWithoutWorksInput>
    connectOrCreate?: UnitCreateOrConnectWithoutWorksInput
    upsert?: UnitUpsertWithoutWorksInput
    connect?: UnitWhereUniqueInput
    update?: XOR<UnitUpdateWithoutWorksInput, UnitUncheckedUpdateWithoutWorksInput>
  }

  export type WorkItemsUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutWorkInput>, Enumerable<WorkItemsUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<WorkItemsUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: WorkItemsCreateManyWorkInputEnvelope
    set?: Enumerable<WorkItemsWhereUniqueInput>
    disconnect?: Enumerable<WorkItemsWhereUniqueInput>
    delete?: Enumerable<WorkItemsWhereUniqueInput>
    connect?: Enumerable<WorkItemsWhereUniqueInput>
    update?: Enumerable<WorkItemsUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<WorkItemsUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<WorkItemsScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkInput>, Enumerable<HistoriUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: HistoriCreateManyWorkInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateWorkUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutWorkInput>, Enumerable<TemplateWorkUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<TemplateWorkUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: TemplateWorkCreateManyWorkInputEnvelope
    set?: Enumerable<TemplateWorkWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkWhereUniqueInput>
    delete?: Enumerable<TemplateWorkWhereUniqueInput>
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
    update?: Enumerable<TemplateWorkUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<TemplateWorkUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<TemplateWorkScalarWhereInput>
  }

  export type WorkItemsUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<WorkItemsCreateWithoutWorkInput>, Enumerable<WorkItemsUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<WorkItemsCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<WorkItemsUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: WorkItemsCreateManyWorkInputEnvelope
    set?: Enumerable<WorkItemsWhereUniqueInput>
    disconnect?: Enumerable<WorkItemsWhereUniqueInput>
    delete?: Enumerable<WorkItemsWhereUniqueInput>
    connect?: Enumerable<WorkItemsWhereUniqueInput>
    update?: Enumerable<WorkItemsUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<WorkItemsUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<WorkItemsScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkInput>, Enumerable<HistoriUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: HistoriCreateManyWorkInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateWorkUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutWorkInput>, Enumerable<TemplateWorkUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<TemplateWorkUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: TemplateWorkCreateManyWorkInputEnvelope
    set?: Enumerable<TemplateWorkWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkWhereUniqueInput>
    delete?: Enumerable<TemplateWorkWhereUniqueInput>
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
    update?: Enumerable<TemplateWorkUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<TemplateWorkUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<TemplateWorkScalarWhereInput>
  }

  export type WorkCreateNestedOneWithoutItemsInput = {
    create?: XOR<WorkCreateWithoutItemsInput, WorkUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutItemsInput
    connect?: WorkWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutWorksInput = {
    create?: XOR<ItemCreateWithoutWorksInput, ItemUncheckedCreateWithoutWorksInput>
    connectOrCreate?: ItemCreateOrConnectWithoutWorksInput
    connect?: ItemWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutWorkItemsInput = {
    create?: XOR<UnitCreateWithoutWorkItemsInput, UnitUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutWorkItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type HistoriCreateNestedManyWithoutWorkItemsInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkItemsInput>, Enumerable<HistoriUncheckedCreateWithoutWorkItemsInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkItemsInput>
    createMany?: HistoriCreateManyWorkItemsInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutWorkItemsInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkItemsInput>, Enumerable<HistoriUncheckedCreateWithoutWorkItemsInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkItemsInput>
    createMany?: HistoriCreateManyWorkItemsInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<WorkCreateWithoutItemsInput, WorkUncheckedCreateWithoutItemsInput>
    connectOrCreate?: WorkCreateOrConnectWithoutItemsInput
    upsert?: WorkUpsertWithoutItemsInput
    connect?: WorkWhereUniqueInput
    update?: XOR<WorkUpdateWithoutItemsInput, WorkUncheckedUpdateWithoutItemsInput>
  }

  export type ItemUpdateOneRequiredWithoutWorksNestedInput = {
    create?: XOR<ItemCreateWithoutWorksInput, ItemUncheckedCreateWithoutWorksInput>
    connectOrCreate?: ItemCreateOrConnectWithoutWorksInput
    upsert?: ItemUpsertWithoutWorksInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutWorksInput, ItemUncheckedUpdateWithoutWorksInput>
  }

  export type UnitUpdateOneWithoutWorkItemsNestedInput = {
    create?: XOR<UnitCreateWithoutWorkItemsInput, UnitUncheckedCreateWithoutWorkItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutWorkItemsInput
    upsert?: UnitUpsertWithoutWorkItemsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<UnitUpdateWithoutWorkItemsInput, UnitUncheckedUpdateWithoutWorkItemsInput>
  }

  export type HistoriUpdateManyWithoutWorkItemsNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkItemsInput>, Enumerable<HistoriUncheckedCreateWithoutWorkItemsInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkItemsInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutWorkItemsInput>
    createMany?: HistoriCreateManyWorkItemsInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutWorkItemsInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutWorkItemsInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutWorkItemsNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutWorkItemsInput>, Enumerable<HistoriUncheckedCreateWithoutWorkItemsInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutWorkItemsInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutWorkItemsInput>
    createMany?: HistoriCreateManyWorkItemsInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutWorkItemsInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutWorkItemsInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateDataCreateNestedOneWithoutActiveInput = {
    create?: XOR<TemplateDataCreateWithoutActiveInput, TemplateDataUncheckedCreateWithoutActiveInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutActiveInput
    connect?: TemplateDataWhereUniqueInput
  }

  export type TemplateDataCreateNestedManyWithoutTemplateInput = {
    create?: XOR<Enumerable<TemplateDataCreateWithoutTemplateInput>, Enumerable<TemplateDataUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<TemplateDataCreateOrConnectWithoutTemplateInput>
    createMany?: TemplateDataCreateManyTemplateInputEnvelope
    connect?: Enumerable<TemplateDataWhereUniqueInput>
  }

  export type HistoriCreateNestedManyWithoutTemplateInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutTemplateInput>, Enumerable<HistoriUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutTemplateInput>
    createMany?: HistoriCreateManyTemplateInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateDataUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<Enumerable<TemplateDataCreateWithoutTemplateInput>, Enumerable<TemplateDataUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<TemplateDataCreateOrConnectWithoutTemplateInput>
    createMany?: TemplateDataCreateManyTemplateInputEnvelope
    connect?: Enumerable<TemplateDataWhereUniqueInput>
  }

  export type HistoriUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutTemplateInput>, Enumerable<HistoriUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutTemplateInput>
    createMany?: HistoriCreateManyTemplateInputEnvelope
    connect?: Enumerable<HistoriWhereUniqueInput>
  }

  export type TemplateDataUpdateOneWithoutActiveNestedInput = {
    create?: XOR<TemplateDataCreateWithoutActiveInput, TemplateDataUncheckedCreateWithoutActiveInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutActiveInput
    upsert?: TemplateDataUpsertWithoutActiveInput
    disconnect?: boolean
    delete?: boolean
    connect?: TemplateDataWhereUniqueInput
    update?: XOR<TemplateDataUpdateWithoutActiveInput, TemplateDataUncheckedUpdateWithoutActiveInput>
  }

  export type TemplateDataUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<Enumerable<TemplateDataCreateWithoutTemplateInput>, Enumerable<TemplateDataUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<TemplateDataCreateOrConnectWithoutTemplateInput>
    upsert?: Enumerable<TemplateDataUpsertWithWhereUniqueWithoutTemplateInput>
    createMany?: TemplateDataCreateManyTemplateInputEnvelope
    set?: Enumerable<TemplateDataWhereUniqueInput>
    disconnect?: Enumerable<TemplateDataWhereUniqueInput>
    delete?: Enumerable<TemplateDataWhereUniqueInput>
    connect?: Enumerable<TemplateDataWhereUniqueInput>
    update?: Enumerable<TemplateDataUpdateWithWhereUniqueWithoutTemplateInput>
    updateMany?: Enumerable<TemplateDataUpdateManyWithWhereWithoutTemplateInput>
    deleteMany?: Enumerable<TemplateDataScalarWhereInput>
  }

  export type HistoriUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutTemplateInput>, Enumerable<HistoriUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutTemplateInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutTemplateInput>
    createMany?: HistoriCreateManyTemplateInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutTemplateInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutTemplateInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type TemplateDataUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<Enumerable<TemplateDataCreateWithoutTemplateInput>, Enumerable<TemplateDataUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<TemplateDataCreateOrConnectWithoutTemplateInput>
    upsert?: Enumerable<TemplateDataUpsertWithWhereUniqueWithoutTemplateInput>
    createMany?: TemplateDataCreateManyTemplateInputEnvelope
    set?: Enumerable<TemplateDataWhereUniqueInput>
    disconnect?: Enumerable<TemplateDataWhereUniqueInput>
    delete?: Enumerable<TemplateDataWhereUniqueInput>
    connect?: Enumerable<TemplateDataWhereUniqueInput>
    update?: Enumerable<TemplateDataUpdateWithWhereUniqueWithoutTemplateInput>
    updateMany?: Enumerable<TemplateDataUpdateManyWithWhereWithoutTemplateInput>
    deleteMany?: Enumerable<TemplateDataScalarWhereInput>
  }

  export type HistoriUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<Enumerable<HistoriCreateWithoutTemplateInput>, Enumerable<HistoriUncheckedCreateWithoutTemplateInput>>
    connectOrCreate?: Enumerable<HistoriCreateOrConnectWithoutTemplateInput>
    upsert?: Enumerable<HistoriUpsertWithWhereUniqueWithoutTemplateInput>
    createMany?: HistoriCreateManyTemplateInputEnvelope
    set?: Enumerable<HistoriWhereUniqueInput>
    disconnect?: Enumerable<HistoriWhereUniqueInput>
    delete?: Enumerable<HistoriWhereUniqueInput>
    connect?: Enumerable<HistoriWhereUniqueInput>
    update?: Enumerable<HistoriUpdateWithWhereUniqueWithoutTemplateInput>
    updateMany?: Enumerable<HistoriUpdateManyWithWhereWithoutTemplateInput>
    deleteMany?: Enumerable<HistoriScalarWhereInput>
  }

  export type ItemCreateNestedOneWithoutTWorksInput = {
    create?: XOR<ItemCreateWithoutTWorksInput, ItemUncheckedCreateWithoutTWorksInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTWorksInput
    connect?: ItemWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutTWorkItemsInput = {
    create?: XOR<UnitCreateWithoutTWorkItemsInput, UnitUncheckedCreateWithoutTWorkItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutTWorkItemsInput
    connect?: UnitWhereUniqueInput
  }

  export type TemplateWorkCreateNestedOneWithoutItemsInput = {
    create?: XOR<TemplateWorkCreateWithoutItemsInput, TemplateWorkUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TemplateWorkCreateOrConnectWithoutItemsInput
    connect?: TemplateWorkWhereUniqueInput
  }

  export type ItemUpdateOneRequiredWithoutTWorksNestedInput = {
    create?: XOR<ItemCreateWithoutTWorksInput, ItemUncheckedCreateWithoutTWorksInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTWorksInput
    upsert?: ItemUpsertWithoutTWorksInput
    connect?: ItemWhereUniqueInput
    update?: XOR<ItemUpdateWithoutTWorksInput, ItemUncheckedUpdateWithoutTWorksInput>
  }

  export type UnitUpdateOneRequiredWithoutTWorkItemsNestedInput = {
    create?: XOR<UnitCreateWithoutTWorkItemsInput, UnitUncheckedCreateWithoutTWorkItemsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutTWorkItemsInput
    upsert?: UnitUpsertWithoutTWorkItemsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<UnitUpdateWithoutTWorkItemsInput, UnitUncheckedUpdateWithoutTWorkItemsInput>
  }

  export type TemplateWorkUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TemplateWorkCreateWithoutItemsInput, TemplateWorkUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TemplateWorkCreateOrConnectWithoutItemsInput
    upsert?: TemplateWorkUpsertWithoutItemsInput
    connect?: TemplateWorkWhereUniqueInput
    update?: XOR<TemplateWorkUpdateWithoutItemsInput, TemplateWorkUncheckedUpdateWithoutItemsInput>
  }

  export type TemplateDataCreateNestedOneWithoutWorksInput = {
    create?: XOR<TemplateDataCreateWithoutWorksInput, TemplateDataUncheckedCreateWithoutWorksInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutWorksInput
    connect?: TemplateDataWhereUniqueInput
  }

  export type WorkCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<WorkCreateWithoutTemplatesInput, WorkUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: WorkCreateOrConnectWithoutTemplatesInput
    connect?: WorkWhereUniqueInput
  }

  export type TemplateWorkItemCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutParentInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutParentInput>
    createMany?: TemplateWorkItemCreateManyParentInputEnvelope
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
  }

  export type StageCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<StageCreateWithoutWorkInput>, Enumerable<StageUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<StageCreateOrConnectWithoutWorkInput>
    createMany?: StageCreateManyWorkInputEnvelope
    connect?: Enumerable<StageWhereUniqueInput>
  }

  export type TemplateWorkItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutParentInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutParentInput>
    createMany?: TemplateWorkItemCreateManyParentInputEnvelope
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
  }

  export type StageUncheckedCreateNestedManyWithoutWorkInput = {
    create?: XOR<Enumerable<StageCreateWithoutWorkInput>, Enumerable<StageUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<StageCreateOrConnectWithoutWorkInput>
    createMany?: StageCreateManyWorkInputEnvelope
    connect?: Enumerable<StageWhereUniqueInput>
  }

  export type TemplateDataUpdateOneRequiredWithoutWorksNestedInput = {
    create?: XOR<TemplateDataCreateWithoutWorksInput, TemplateDataUncheckedCreateWithoutWorksInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutWorksInput
    upsert?: TemplateDataUpsertWithoutWorksInput
    connect?: TemplateDataWhereUniqueInput
    update?: XOR<TemplateDataUpdateWithoutWorksInput, TemplateDataUncheckedUpdateWithoutWorksInput>
  }

  export type WorkUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<WorkCreateWithoutTemplatesInput, WorkUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: WorkCreateOrConnectWithoutTemplatesInput
    upsert?: WorkUpsertWithoutTemplatesInput
    connect?: WorkWhereUniqueInput
    update?: XOR<WorkUpdateWithoutTemplatesInput, WorkUncheckedUpdateWithoutTemplatesInput>
  }

  export type TemplateWorkItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutParentInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<TemplateWorkItemUpsertWithWhereUniqueWithoutParentInput>
    createMany?: TemplateWorkItemCreateManyParentInputEnvelope
    set?: Enumerable<TemplateWorkItemWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    delete?: Enumerable<TemplateWorkItemWhereUniqueInput>
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    update?: Enumerable<TemplateWorkItemUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<TemplateWorkItemUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<TemplateWorkItemScalarWhereInput>
  }

  export type StageUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<StageCreateWithoutWorkInput>, Enumerable<StageUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<StageCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<StageUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: StageCreateManyWorkInputEnvelope
    set?: Enumerable<StageWhereUniqueInput>
    disconnect?: Enumerable<StageWhereUniqueInput>
    delete?: Enumerable<StageWhereUniqueInput>
    connect?: Enumerable<StageWhereUniqueInput>
    update?: Enumerable<StageUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<StageUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<StageScalarWhereInput>
  }

  export type TemplateWorkItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<Enumerable<TemplateWorkItemCreateWithoutParentInput>, Enumerable<TemplateWorkItemUncheckedCreateWithoutParentInput>>
    connectOrCreate?: Enumerable<TemplateWorkItemCreateOrConnectWithoutParentInput>
    upsert?: Enumerable<TemplateWorkItemUpsertWithWhereUniqueWithoutParentInput>
    createMany?: TemplateWorkItemCreateManyParentInputEnvelope
    set?: Enumerable<TemplateWorkItemWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    delete?: Enumerable<TemplateWorkItemWhereUniqueInput>
    connect?: Enumerable<TemplateWorkItemWhereUniqueInput>
    update?: Enumerable<TemplateWorkItemUpdateWithWhereUniqueWithoutParentInput>
    updateMany?: Enumerable<TemplateWorkItemUpdateManyWithWhereWithoutParentInput>
    deleteMany?: Enumerable<TemplateWorkItemScalarWhereInput>
  }

  export type StageUncheckedUpdateManyWithoutWorkNestedInput = {
    create?: XOR<Enumerable<StageCreateWithoutWorkInput>, Enumerable<StageUncheckedCreateWithoutWorkInput>>
    connectOrCreate?: Enumerable<StageCreateOrConnectWithoutWorkInput>
    upsert?: Enumerable<StageUpsertWithWhereUniqueWithoutWorkInput>
    createMany?: StageCreateManyWorkInputEnvelope
    set?: Enumerable<StageWhereUniqueInput>
    disconnect?: Enumerable<StageWhereUniqueInput>
    delete?: Enumerable<StageWhereUniqueInput>
    connect?: Enumerable<StageWhereUniqueInput>
    update?: Enumerable<StageUpdateWithWhereUniqueWithoutWorkInput>
    updateMany?: Enumerable<StageUpdateManyWithWhereWithoutWorkInput>
    deleteMany?: Enumerable<StageScalarWhereInput>
  }

  export type TAroundNullableCreateEnvelopeInput = {
    set?: TAroundCreateInput | null
  }

  export type TAroundCreateInput = {
    long?: string | null
    width?: string | null
    height?: string | null
  }

  export type TPropertyCreateEnvelopeInput = {
    set?: TPropertyCreateInput
  }

  export type TPropertyCreateInput = {
    images?: string | null
    intros?: Enumerable<TPropertyIntroCreateInput>
    prices?: Enumerable<TPropertyPriceCreateInput>
    pph?: boolean
    ppn?: boolean
    pphVal?: number
    ppnVal?: number
  }

  export type TemplateCreateNestedOneWithoutActiveInput = {
    create?: XOR<TemplateCreateWithoutActiveInput, TemplateUncheckedCreateWithoutActiveInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutActiveInput
    connect?: TemplateWhereUniqueInput
  }

  export type TemplateCreateNestedOneWithoutRecordsInput = {
    create?: XOR<TemplateCreateWithoutRecordsInput, TemplateUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutRecordsInput
    connect?: TemplateWhereUniqueInput
  }

  export type SpaceCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<SpaceCreateWithoutRefInput>, Enumerable<SpaceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<SpaceCreateOrConnectWithoutRefInput>
    createMany?: SpaceCreateManyRefInputEnvelope
    connect?: Enumerable<SpaceWhereUniqueInput>
  }

  export type TemplateWorkCreateNestedManyWithoutDataInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutDataInput>, Enumerable<TemplateWorkUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutDataInput>
    createMany?: TemplateWorkCreateManyDataInputEnvelope
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
  }

  export type TemplateDEDCreateNestedManyWithoutDataInput = {
    create?: XOR<Enumerable<TemplateDEDCreateWithoutDataInput>, Enumerable<TemplateDEDUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateDEDCreateOrConnectWithoutDataInput>
    createMany?: TemplateDEDCreateManyDataInputEnvelope
    connect?: Enumerable<TemplateDEDWhereUniqueInput>
  }

  export type TemplateFieldCreateNestedManyWithoutDataInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutDataInput>, Enumerable<TemplateFieldUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutDataInput>
    createMany?: TemplateFieldCreateManyDataInputEnvelope
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
  }

  export type TemplateUncheckedCreateNestedOneWithoutActiveInput = {
    create?: XOR<TemplateCreateWithoutActiveInput, TemplateUncheckedCreateWithoutActiveInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutActiveInput
    connect?: TemplateWhereUniqueInput
  }

  export type SpaceUncheckedCreateNestedManyWithoutRefInput = {
    create?: XOR<Enumerable<SpaceCreateWithoutRefInput>, Enumerable<SpaceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<SpaceCreateOrConnectWithoutRefInput>
    createMany?: SpaceCreateManyRefInputEnvelope
    connect?: Enumerable<SpaceWhereUniqueInput>
  }

  export type TemplateWorkUncheckedCreateNestedManyWithoutDataInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutDataInput>, Enumerable<TemplateWorkUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutDataInput>
    createMany?: TemplateWorkCreateManyDataInputEnvelope
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
  }

  export type TemplateDEDUncheckedCreateNestedManyWithoutDataInput = {
    create?: XOR<Enumerable<TemplateDEDCreateWithoutDataInput>, Enumerable<TemplateDEDUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateDEDCreateOrConnectWithoutDataInput>
    createMany?: TemplateDEDCreateManyDataInputEnvelope
    connect?: Enumerable<TemplateDEDWhereUniqueInput>
  }

  export type TemplateFieldUncheckedCreateNestedManyWithoutDataInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutDataInput>, Enumerable<TemplateFieldUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutDataInput>
    createMany?: TemplateFieldCreateManyDataInputEnvelope
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
  }

  export type TAroundNullableUpdateEnvelopeInput = {
    set?: TAroundCreateInput | null
    upsert?: TAroundUpsertInput
    unset?: boolean
  }

  export type TPropertyUpdateEnvelopeInput = {
    set?: TPropertyCreateInput
    update?: TPropertyUpdateInput
  }

  export type TemplateUpdateOneWithoutActiveNestedInput = {
    create?: XOR<TemplateCreateWithoutActiveInput, TemplateUncheckedCreateWithoutActiveInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutActiveInput
    upsert?: TemplateUpsertWithoutActiveInput
    disconnect?: boolean
    delete?: boolean
    connect?: TemplateWhereUniqueInput
    update?: XOR<TemplateUpdateWithoutActiveInput, TemplateUncheckedUpdateWithoutActiveInput>
  }

  export type TemplateUpdateOneRequiredWithoutRecordsNestedInput = {
    create?: XOR<TemplateCreateWithoutRecordsInput, TemplateUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutRecordsInput
    upsert?: TemplateUpsertWithoutRecordsInput
    connect?: TemplateWhereUniqueInput
    update?: XOR<TemplateUpdateWithoutRecordsInput, TemplateUncheckedUpdateWithoutRecordsInput>
  }

  export type SpaceUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<SpaceCreateWithoutRefInput>, Enumerable<SpaceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<SpaceCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<SpaceUpsertWithWhereUniqueWithoutRefInput>
    createMany?: SpaceCreateManyRefInputEnvelope
    set?: Enumerable<SpaceWhereUniqueInput>
    disconnect?: Enumerable<SpaceWhereUniqueInput>
    delete?: Enumerable<SpaceWhereUniqueInput>
    connect?: Enumerable<SpaceWhereUniqueInput>
    update?: Enumerable<SpaceUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<SpaceUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<SpaceScalarWhereInput>
  }

  export type TemplateWorkUpdateManyWithoutDataNestedInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutDataInput>, Enumerable<TemplateWorkUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutDataInput>
    upsert?: Enumerable<TemplateWorkUpsertWithWhereUniqueWithoutDataInput>
    createMany?: TemplateWorkCreateManyDataInputEnvelope
    set?: Enumerable<TemplateWorkWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkWhereUniqueInput>
    delete?: Enumerable<TemplateWorkWhereUniqueInput>
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
    update?: Enumerable<TemplateWorkUpdateWithWhereUniqueWithoutDataInput>
    updateMany?: Enumerable<TemplateWorkUpdateManyWithWhereWithoutDataInput>
    deleteMany?: Enumerable<TemplateWorkScalarWhereInput>
  }

  export type TemplateDEDUpdateManyWithoutDataNestedInput = {
    create?: XOR<Enumerable<TemplateDEDCreateWithoutDataInput>, Enumerable<TemplateDEDUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateDEDCreateOrConnectWithoutDataInput>
    upsert?: Enumerable<TemplateDEDUpsertWithWhereUniqueWithoutDataInput>
    createMany?: TemplateDEDCreateManyDataInputEnvelope
    set?: Enumerable<TemplateDEDWhereUniqueInput>
    disconnect?: Enumerable<TemplateDEDWhereUniqueInput>
    delete?: Enumerable<TemplateDEDWhereUniqueInput>
    connect?: Enumerable<TemplateDEDWhereUniqueInput>
    update?: Enumerable<TemplateDEDUpdateWithWhereUniqueWithoutDataInput>
    updateMany?: Enumerable<TemplateDEDUpdateManyWithWhereWithoutDataInput>
    deleteMany?: Enumerable<TemplateDEDScalarWhereInput>
  }

  export type TemplateFieldUpdateManyWithoutDataNestedInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutDataInput>, Enumerable<TemplateFieldUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutDataInput>
    upsert?: Enumerable<TemplateFieldUpsertWithWhereUniqueWithoutDataInput>
    createMany?: TemplateFieldCreateManyDataInputEnvelope
    set?: Enumerable<TemplateFieldWhereUniqueInput>
    disconnect?: Enumerable<TemplateFieldWhereUniqueInput>
    delete?: Enumerable<TemplateFieldWhereUniqueInput>
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
    update?: Enumerable<TemplateFieldUpdateWithWhereUniqueWithoutDataInput>
    updateMany?: Enumerable<TemplateFieldUpdateManyWithWhereWithoutDataInput>
    deleteMany?: Enumerable<TemplateFieldScalarWhereInput>
  }

  export type TemplateUncheckedUpdateOneWithoutActiveNestedInput = {
    create?: XOR<TemplateCreateWithoutActiveInput, TemplateUncheckedCreateWithoutActiveInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutActiveInput
    upsert?: TemplateUpsertWithoutActiveInput
    disconnect?: boolean
    delete?: boolean
    connect?: TemplateWhereUniqueInput
    update?: XOR<TemplateUpdateWithoutActiveInput, TemplateUncheckedUpdateWithoutActiveInput>
  }

  export type SpaceUncheckedUpdateManyWithoutRefNestedInput = {
    create?: XOR<Enumerable<SpaceCreateWithoutRefInput>, Enumerable<SpaceUncheckedCreateWithoutRefInput>>
    connectOrCreate?: Enumerable<SpaceCreateOrConnectWithoutRefInput>
    upsert?: Enumerable<SpaceUpsertWithWhereUniqueWithoutRefInput>
    createMany?: SpaceCreateManyRefInputEnvelope
    set?: Enumerable<SpaceWhereUniqueInput>
    disconnect?: Enumerable<SpaceWhereUniqueInput>
    delete?: Enumerable<SpaceWhereUniqueInput>
    connect?: Enumerable<SpaceWhereUniqueInput>
    update?: Enumerable<SpaceUpdateWithWhereUniqueWithoutRefInput>
    updateMany?: Enumerable<SpaceUpdateManyWithWhereWithoutRefInput>
    deleteMany?: Enumerable<SpaceScalarWhereInput>
  }

  export type TemplateWorkUncheckedUpdateManyWithoutDataNestedInput = {
    create?: XOR<Enumerable<TemplateWorkCreateWithoutDataInput>, Enumerable<TemplateWorkUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateWorkCreateOrConnectWithoutDataInput>
    upsert?: Enumerable<TemplateWorkUpsertWithWhereUniqueWithoutDataInput>
    createMany?: TemplateWorkCreateManyDataInputEnvelope
    set?: Enumerable<TemplateWorkWhereUniqueInput>
    disconnect?: Enumerable<TemplateWorkWhereUniqueInput>
    delete?: Enumerable<TemplateWorkWhereUniqueInput>
    connect?: Enumerable<TemplateWorkWhereUniqueInput>
    update?: Enumerable<TemplateWorkUpdateWithWhereUniqueWithoutDataInput>
    updateMany?: Enumerable<TemplateWorkUpdateManyWithWhereWithoutDataInput>
    deleteMany?: Enumerable<TemplateWorkScalarWhereInput>
  }

  export type TemplateDEDUncheckedUpdateManyWithoutDataNestedInput = {
    create?: XOR<Enumerable<TemplateDEDCreateWithoutDataInput>, Enumerable<TemplateDEDUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateDEDCreateOrConnectWithoutDataInput>
    upsert?: Enumerable<TemplateDEDUpsertWithWhereUniqueWithoutDataInput>
    createMany?: TemplateDEDCreateManyDataInputEnvelope
    set?: Enumerable<TemplateDEDWhereUniqueInput>
    disconnect?: Enumerable<TemplateDEDWhereUniqueInput>
    delete?: Enumerable<TemplateDEDWhereUniqueInput>
    connect?: Enumerable<TemplateDEDWhereUniqueInput>
    update?: Enumerable<TemplateDEDUpdateWithWhereUniqueWithoutDataInput>
    updateMany?: Enumerable<TemplateDEDUpdateManyWithWhereWithoutDataInput>
    deleteMany?: Enumerable<TemplateDEDScalarWhereInput>
  }

  export type TemplateFieldUncheckedUpdateManyWithoutDataNestedInput = {
    create?: XOR<Enumerable<TemplateFieldCreateWithoutDataInput>, Enumerable<TemplateFieldUncheckedCreateWithoutDataInput>>
    connectOrCreate?: Enumerable<TemplateFieldCreateOrConnectWithoutDataInput>
    upsert?: Enumerable<TemplateFieldUpsertWithWhereUniqueWithoutDataInput>
    createMany?: TemplateFieldCreateManyDataInputEnvelope
    set?: Enumerable<TemplateFieldWhereUniqueInput>
    disconnect?: Enumerable<TemplateFieldWhereUniqueInput>
    delete?: Enumerable<TemplateFieldWhereUniqueInput>
    connect?: Enumerable<TemplateFieldWhereUniqueInput>
    update?: Enumerable<TemplateFieldUpdateWithWhereUniqueWithoutDataInput>
    updateMany?: Enumerable<TemplateFieldUpdateManyWithWhereWithoutDataInput>
    deleteMany?: Enumerable<TemplateFieldScalarWhereInput>
  }

  export type TFieldListListCreateEnvelopeInput = {
    set?: Enumerable<TFieldListCreateInput>
  }

  export type TFieldListCreateInput = {
    id: string
    name: string
    type: EFieldType
  }

  export type TemplateDataCreateNestedOneWithoutFieldsInput = {
    create?: XOR<TemplateDataCreateWithoutFieldsInput, TemplateDataUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutFieldsInput
    connect?: TemplateDataWhereUniqueInput
  }

  export type FileCreateNestedOneWithoutFieldsInput = {
    create?: XOR<FileCreateWithoutFieldsInput, FileUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: FileCreateOrConnectWithoutFieldsInput
    connect?: FileWhereUniqueInput
  }

  export type TFieldListListUpdateEnvelopeInput = {
    set?: Enumerable<TFieldListCreateInput>
    push?: Enumerable<TFieldListCreateInput>
    updateMany?: TFieldListUpdateManyInput
    deleteMany?: TFieldListDeleteManyInput
  }

  export type TemplateDataUpdateOneRequiredWithoutFieldsNestedInput = {
    create?: XOR<TemplateDataCreateWithoutFieldsInput, TemplateDataUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutFieldsInput
    upsert?: TemplateDataUpsertWithoutFieldsInput
    connect?: TemplateDataWhereUniqueInput
    update?: XOR<TemplateDataUpdateWithoutFieldsInput, TemplateDataUncheckedUpdateWithoutFieldsInput>
  }

  export type FileUpdateOneWithoutFieldsNestedInput = {
    create?: XOR<FileCreateWithoutFieldsInput, FileUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: FileCreateOrConnectWithoutFieldsInput
    upsert?: FileUpsertWithoutFieldsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FileWhereUniqueInput
    update?: XOR<FileUpdateWithoutFieldsInput, FileUncheckedUpdateWithoutFieldsInput>
  }

  export type TDeDListListCreateEnvelopeInput = {
    set?: Enumerable<TDeDListCreateInput>
  }

  export type TDeDListCreateInput = {
    id: string
    filename: string
    name: string
    url: string
    size: number
    width: number
    height: number
    top: number
    left: number
    type: string
  }

  export type TemplateDataCreateNestedOneWithoutDedsInput = {
    create?: XOR<TemplateDataCreateWithoutDedsInput, TemplateDataUncheckedCreateWithoutDedsInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutDedsInput
    connect?: TemplateDataWhereUniqueInput
  }

  export type TDeDListListUpdateEnvelopeInput = {
    set?: Enumerable<TDeDListCreateInput>
    push?: Enumerable<TDeDListCreateInput>
    updateMany?: TDeDListUpdateManyInput
    deleteMany?: TDeDListDeleteManyInput
  }

  export type TemplateDataUpdateOneRequiredWithoutDedsNestedInput = {
    create?: XOR<TemplateDataCreateWithoutDedsInput, TemplateDataUncheckedCreateWithoutDedsInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutDedsInput
    upsert?: TemplateDataUpsertWithoutDedsInput
    connect?: TemplateDataWhereUniqueInput
    update?: XOR<TemplateDataUpdateWithoutDedsInput, TemplateDataUncheckedUpdateWithoutDedsInput>
  }

  export type SpaceValueCreateEnvelopeInput = {
    set?: SpaceValueCreateInput
  }

  export type SpaceValueCreateInput = {
    fixed: boolean
    value: number
    min: number
    max: number
  }

  export type TValuesCreateEnvelopeInput = {
    set?: TValuesCreateInput
  }

  export type TValuesCreateInput = {
    around: number
    broad: number
    volume: number
  }

  export type TemplateDataCreateNestedOneWithoutSpacesInput = {
    create?: XOR<TemplateDataCreateWithoutSpacesInput, TemplateDataUncheckedCreateWithoutSpacesInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutSpacesInput
    connect?: TemplateDataWhereUniqueInput
  }

  export type SpaceValueUpdateEnvelopeInput = {
    set?: SpaceValueCreateInput
    update?: SpaceValueUpdateInput
  }

  export type TValuesUpdateEnvelopeInput = {
    set?: TValuesCreateInput
    update?: TValuesUpdateInput
  }

  export type TemplateDataUpdateOneRequiredWithoutSpacesNestedInput = {
    create?: XOR<TemplateDataCreateWithoutSpacesInput, TemplateDataUncheckedCreateWithoutSpacesInput>
    connectOrCreate?: TemplateDataCreateOrConnectWithoutSpacesInput
    upsert?: TemplateDataUpsertWithoutSpacesInput
    connect?: TemplateDataWhereUniqueInput
    update?: XOR<TemplateDataUpdateWithoutSpacesInput, TemplateDataUncheckedUpdateWithoutSpacesInput>
  }

  export type StageValueCreateEnvelopeInput = {
    set?: StageValueCreateInput
  }

  export type StageValueCreateInput = {
    ref?: string | null
    refal?: number | null
    value: number
  }

  export type TemplateWorkCreateNestedOneWithoutStagesInput = {
    create?: XOR<TemplateWorkCreateWithoutStagesInput, TemplateWorkUncheckedCreateWithoutStagesInput>
    connectOrCreate?: TemplateWorkCreateOrConnectWithoutStagesInput
    connect?: TemplateWorkWhereUniqueInput
  }

  export type EnumStageTypeFieldUpdateOperationsInput = {
    set?: StageType
  }

  export type EnumStageOprFieldUpdateOperationsInput = {
    set?: StageOpr
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type StageValueUpdateEnvelopeInput = {
    set?: StageValueCreateInput
    update?: StageValueUpdateInput
  }

  export type TemplateWorkUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<TemplateWorkCreateWithoutStagesInput, TemplateWorkUncheckedCreateWithoutStagesInput>
    connectOrCreate?: TemplateWorkCreateOrConnectWithoutStagesInput
    upsert?: TemplateWorkUpsertWithoutStagesInput
    connect?: TemplateWorkWhereUniqueInput
    update?: XOR<TemplateWorkUpdateWithoutStagesInput, TemplateWorkUncheckedUpdateWithoutStagesInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedEnumHistoriTypeFilter = {
    equals?: HistoriType
    in?: Enumerable<HistoriType>
    notIn?: Enumerable<HistoriType>
    not?: NestedEnumHistoriTypeFilter | HistoriType
  }

  export type NestedEnumHistoriModelFilter = {
    equals?: HistoriModel
    in?: Enumerable<HistoriModel>
    notIn?: Enumerable<HistoriModel>
    not?: NestedEnumHistoriModelFilter | HistoriModel
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedEnumHistoriTypeWithAggregatesFilter = {
    equals?: HistoriType
    in?: Enumerable<HistoriType>
    notIn?: Enumerable<HistoriType>
    not?: NestedEnumHistoriTypeWithAggregatesFilter | HistoriType
    _count?: NestedIntFilter
    _min?: NestedEnumHistoriTypeFilter
    _max?: NestedEnumHistoriTypeFilter
  }

  export type NestedEnumHistoriModelWithAggregatesFilter = {
    equals?: HistoriModel
    in?: Enumerable<HistoriModel>
    notIn?: Enumerable<HistoriModel>
    not?: NestedEnumHistoriModelWithAggregatesFilter | HistoriModel
    _count?: NestedIntFilter
    _min?: NestedEnumHistoriModelFilter
    _max?: NestedEnumHistoriModelFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
    isSet?: boolean
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    provinsi?: StringFilter | string
    kabupaten?: StringFilter | string
    kecamatan?: StringFilter | string
    kelurahan?: StringFilter | string
    kodepos?: StringFilter | string
    jalan?: StringFilter | string
    coordinate?: XOR<CoordinateNullableCompositeFilter, CoordinateObjectEqualityInput> | null
  }

  export type CoordinateObjectEqualityInput = {
    longitude: number
    latitude: number
  }

  export type TPhoneWhereInput = {
    AND?: Enumerable<TPhoneWhereInput>
    OR?: Enumerable<TPhoneWhereInput>
    NOT?: Enumerable<TPhoneWhereInput>
    code?: StringFilter | string
    number?: IntFilter | number
  }

  export type CoordinateOrderByInput = {
    longitude?: SortOrder
    latitude?: SortOrder
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedEnumUserRoleFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleFilter | UserRole
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter = {
    equals?: UserRole
    in?: Enumerable<UserRole>
    notIn?: Enumerable<UserRole>
    not?: NestedEnumUserRoleWithAggregatesFilter | UserRole
    _count?: NestedIntFilter
    _min?: NestedEnumUserRoleFilter
    _max?: NestedEnumUserRoleFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumOptionTypeFilter = {
    equals?: OptionType
    in?: Enumerable<OptionType>
    notIn?: Enumerable<OptionType>
    not?: NestedEnumOptionTypeFilter | OptionType
  }

  export type NestedEnumOptionTypeWithAggregatesFilter = {
    equals?: OptionType
    in?: Enumerable<OptionType>
    notIn?: Enumerable<OptionType>
    not?: NestedEnumOptionTypeWithAggregatesFilter | OptionType
    _count?: NestedIntFilter
    _min?: NestedEnumOptionTypeFilter
    _max?: NestedEnumOptionTypeFilter
  }

  export type NestedEnumItemModelFilter = {
    equals?: ItemModel
    in?: Enumerable<ItemModel>
    notIn?: Enumerable<ItemModel>
    not?: NestedEnumItemModelFilter | ItemModel
  }

  export type NestedEnumItemModelWithAggregatesFilter = {
    equals?: ItemModel
    in?: Enumerable<ItemModel>
    notIn?: Enumerable<ItemModel>
    not?: NestedEnumItemModelWithAggregatesFilter | ItemModel
    _count?: NestedIntFilter
    _min?: NestedEnumItemModelFilter
    _max?: NestedEnumItemModelFilter
  }

  export type NestedEnumWorkModelFilter = {
    equals?: WorkModel
    in?: Enumerable<WorkModel>
    notIn?: Enumerable<WorkModel>
    not?: NestedEnumWorkModelFilter | WorkModel
  }

  export type NestedEnumWorkModelWithAggregatesFilter = {
    equals?: WorkModel
    in?: Enumerable<WorkModel>
    notIn?: Enumerable<WorkModel>
    not?: NestedEnumWorkModelWithAggregatesFilter | WorkModel
    _count?: NestedIntFilter
    _min?: NestedEnumWorkModelFilter
    _max?: NestedEnumWorkModelFilter
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type TAroundWhereInput = {
    AND?: Enumerable<TAroundWhereInput>
    OR?: Enumerable<TAroundWhereInput>
    NOT?: Enumerable<TAroundWhereInput>
    long?: StringNullableFilter | string | null
    width?: StringNullableFilter | string | null
    height?: StringNullableFilter | string | null
  }

  export type TPropertyWhereInput = {
    AND?: Enumerable<TPropertyWhereInput>
    OR?: Enumerable<TPropertyWhereInput>
    NOT?: Enumerable<TPropertyWhereInput>
    images?: StringNullableFilter | string | null
    intros?: XOR<TPropertyIntroCompositeListFilter, Enumerable<TPropertyIntroObjectEqualityInput>>
    prices?: XOR<TPropertyPriceCompositeListFilter, Enumerable<TPropertyPriceObjectEqualityInput>>
    pph?: BoolFilter | boolean
    ppn?: BoolFilter | boolean
    pphVal?: IntFilter | number
    ppnVal?: IntFilter | number
  }

  export type TPropertyIntroObjectEqualityInput = {
    itemId: string
    qty: number
  }

  export type TPropertyPriceObjectEqualityInput = {
    type: ItemModel
    itemId: string
    workIds?: Enumerable<string>
    coefficient: number
    rounding: number
    price: number
    pph: boolean
    ppn: boolean
  }

  export type TPropertyIntroOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TPropertyPriceOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type TFieldListWhereInput = {
    AND?: Enumerable<TFieldListWhereInput>
    OR?: Enumerable<TFieldListWhereInput>
    NOT?: Enumerable<TFieldListWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    type?: EnumEFieldTypeFilter | EFieldType
  }

  export type TDeDListWhereInput = {
    AND?: Enumerable<TDeDListWhereInput>
    OR?: Enumerable<TDeDListWhereInput>
    NOT?: Enumerable<TDeDListWhereInput>
    id?: StringFilter | string
    filename?: StringFilter | string
    name?: StringFilter | string
    url?: StringFilter | string
    size?: IntFilter | number
    width?: IntFilter | number
    height?: IntFilter | number
    top?: IntFilter | number
    left?: IntFilter | number
    type?: StringFilter | string
  }

  export type SpaceValueWhereInput = {
    AND?: Enumerable<SpaceValueWhereInput>
    OR?: Enumerable<SpaceValueWhereInput>
    NOT?: Enumerable<SpaceValueWhereInput>
    fixed?: BoolFilter | boolean
    value?: FloatFilter | number
    min?: FloatFilter | number
    max?: FloatFilter | number
  }

  export type TValuesWhereInput = {
    AND?: Enumerable<TValuesWhereInput>
    OR?: Enumerable<TValuesWhereInput>
    NOT?: Enumerable<TValuesWhereInput>
    around?: FloatFilter | number
    broad?: FloatFilter | number
    volume?: FloatFilter | number
  }

  export type NestedEnumStageTypeFilter = {
    equals?: StageType
    in?: Enumerable<StageType>
    notIn?: Enumerable<StageType>
    not?: NestedEnumStageTypeFilter | StageType
  }

  export type NestedEnumStageOprFilter = {
    equals?: StageOpr
    in?: Enumerable<StageOpr>
    notIn?: Enumerable<StageOpr>
    not?: NestedEnumStageOprFilter | StageOpr
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
    isSet?: boolean
  }

  export type StageValueWhereInput = {
    AND?: Enumerable<StageValueWhereInput>
    OR?: Enumerable<StageValueWhereInput>
    NOT?: Enumerable<StageValueWhereInput>
    ref?: StringNullableFilter | string | null
    refal?: FloatNullableFilter | number | null
    value?: FloatFilter | number
  }

  export type NestedEnumStageTypeWithAggregatesFilter = {
    equals?: StageType
    in?: Enumerable<StageType>
    notIn?: Enumerable<StageType>
    not?: NestedEnumStageTypeWithAggregatesFilter | StageType
    _count?: NestedIntFilter
    _min?: NestedEnumStageTypeFilter
    _max?: NestedEnumStageTypeFilter
  }

  export type NestedEnumStageOprWithAggregatesFilter = {
    equals?: StageOpr
    in?: Enumerable<StageOpr>
    notIn?: Enumerable<StageOpr>
    not?: NestedEnumStageOprWithAggregatesFilter | StageOpr
    _count?: NestedIntFilter
    _min?: NestedEnumStageOprFilter
    _max?: NestedEnumStageOprFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
    isSet?: boolean
  }

  export type UserCreateWithoutTrackersInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    company?: CompanyCreateNestedOneWithoutUsersInput
    historis?: HistoriCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTrackersInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    companyId?: string | null
    historis?: HistoriUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTrackersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTrackersInput, UserUncheckedCreateWithoutTrackersInput>
  }

  export type UserCreateWithoutHistorisInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    company?: CompanyCreateNestedOneWithoutUsersInput
    trackers?: HistoriCreateNestedManyWithoutRefInput
    devices?: DeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHistorisInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    companyId?: string | null
    trackers?: HistoriUncheckedCreateNestedManyWithoutRefInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHistorisInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHistorisInput, UserUncheckedCreateWithoutHistorisInput>
  }

  export type CompanyCreateWithoutHistorisInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
    users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutHistorisInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
    users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutHistorisInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutHistorisInput, CompanyUncheckedCreateWithoutHistorisInput>
  }

  export type OptionCreateWithoutHistorisInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemCreateNestedManyWithoutCategoryInput
    itemTypes?: ItemCreateNestedManyWithoutTypeInput
    workTypes?: WorkCreateNestedManyWithoutTypeInput
  }

  export type OptionUncheckedCreateWithoutHistorisInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    itemTypes?: ItemUncheckedCreateNestedManyWithoutTypeInput
    workTypes?: WorkUncheckedCreateNestedManyWithoutTypeInput
  }

  export type OptionCreateOrConnectWithoutHistorisInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutHistorisInput, OptionUncheckedCreateWithoutHistorisInput>
  }

  export type UnitCreateWithoutHistorisInput = {
    id?: string
    name: string
    items?: ItemCreateNestedManyWithoutUnitInput
    works?: WorkCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutHistorisInput = {
    id?: string
    name: string
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
    works?: WorkUncheckedCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsUncheckedCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutHistorisInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutHistorisInput, UnitUncheckedCreateWithoutHistorisInput>
  }

  export type ItemCreateWithoutHistorisInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    category: OptionCreateNestedOneWithoutItemCategorysInput
    type?: OptionCreateNestedOneWithoutItemTypesInput
    unit: UnitCreateNestedOneWithoutItemsInput
    works?: WorkItemsCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutHistorisInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutHistorisInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutHistorisInput, ItemUncheckedCreateWithoutHistorisInput>
  }

  export type WorkCreateWithoutHistorisInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    type: OptionCreateNestedOneWithoutWorkTypesInput
    unit: UnitCreateNestedOneWithoutWorksInput
    items?: WorkItemsCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutHistorisInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    unitId: string
    items?: WorkItemsUncheckedCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutHistorisInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutHistorisInput, WorkUncheckedCreateWithoutHistorisInput>
  }

  export type WorkItemsCreateWithoutHistorisInput = {
    id?: string
    model: WorkModel
    coefficient: number
    work: WorkCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutWorksInput
    unit?: UnitCreateNestedOneWithoutWorkItemsInput
  }

  export type WorkItemsUncheckedCreateWithoutHistorisInput = {
    id?: string
    model: WorkModel
    workId: string
    itemId: string
    coefficient: number
    unitId?: string | null
  }

  export type WorkItemsCreateOrConnectWithoutHistorisInput = {
    where: WorkItemsWhereUniqueInput
    create: XOR<WorkItemsCreateWithoutHistorisInput, WorkItemsUncheckedCreateWithoutHistorisInput>
  }

  export type TemplateCreateWithoutHistorisInput = {
    id?: string
    name: string
    active?: TemplateDataCreateNestedOneWithoutActiveInput
    records?: TemplateDataCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutHistorisInput = {
    id?: string
    name: string
    activeId?: string | null
    records?: TemplateDataUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutHistorisInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutHistorisInput, TemplateUncheckedCreateWithoutHistorisInput>
  }

  export type ImageCreateWithoutHistorisInput = {
    id?: string
    name: string
    files?: FileCreateNestedManyWithoutGroupInput
  }

  export type ImageUncheckedCreateWithoutHistorisInput = {
    id?: string
    name: string
    files?: FileUncheckedCreateNestedManyWithoutGroupInput
  }

  export type ImageCreateOrConnectWithoutHistorisInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutHistorisInput, ImageUncheckedCreateWithoutHistorisInput>
  }

  export type FileCreateWithoutHistorisInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    group: ImageCreateNestedOneWithoutFilesInput
    fields?: TemplateFieldCreateNestedManyWithoutImageInput
  }

  export type FileUncheckedCreateWithoutHistorisInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    groupId: string
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutImageInput
  }

  export type FileCreateOrConnectWithoutHistorisInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutHistorisInput, FileUncheckedCreateWithoutHistorisInput>
  }

  export type UserUpsertWithoutTrackersInput = {
    update: XOR<UserUpdateWithoutTrackersInput, UserUncheckedUpdateWithoutTrackersInput>
    create: XOR<UserCreateWithoutTrackersInput, UserUncheckedCreateWithoutTrackersInput>
  }

  export type UserUpdateWithoutTrackersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneWithoutUsersNestedInput
    historis?: HistoriUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTrackersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    historis?: HistoriUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutHistorisInput = {
    update: XOR<UserUpdateWithoutHistorisInput, UserUncheckedUpdateWithoutHistorisInput>
    create: XOR<UserCreateWithoutHistorisInput, UserUncheckedCreateWithoutHistorisInput>
  }

  export type UserUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneWithoutUsersNestedInput
    trackers?: HistoriUpdateManyWithoutRefNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    trackers?: HistoriUncheckedUpdateManyWithoutRefNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutHistorisInput = {
    update: XOR<CompanyUpdateWithoutHistorisInput, CompanyUncheckedUpdateWithoutHistorisInput>
    create: XOR<CompanyCreateWithoutHistorisInput, CompanyUncheckedCreateWithoutHistorisInput>
  }

  export type CompanyUpdateWithoutHistorisInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutHistorisInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type OptionUpsertWithoutHistorisInput = {
    update: XOR<OptionUpdateWithoutHistorisInput, OptionUncheckedUpdateWithoutHistorisInput>
    create: XOR<OptionCreateWithoutHistorisInput, OptionUncheckedCreateWithoutHistorisInput>
  }

  export type OptionUpdateWithoutHistorisInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUpdateManyWithoutCategoryNestedInput
    itemTypes?: ItemUpdateManyWithoutTypeNestedInput
    workTypes?: WorkUpdateManyWithoutTypeNestedInput
  }

  export type OptionUncheckedUpdateWithoutHistorisInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    itemTypes?: ItemUncheckedUpdateManyWithoutTypeNestedInput
    workTypes?: WorkUncheckedUpdateManyWithoutTypeNestedInput
  }

  export type UnitUpsertWithoutHistorisInput = {
    update: XOR<UnitUpdateWithoutHistorisInput, UnitUncheckedUpdateWithoutHistorisInput>
    create: XOR<UnitCreateWithoutHistorisInput, UnitUncheckedCreateWithoutHistorisInput>
  }

  export type UnitUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutUnitNestedInput
    works?: WorkUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
    works?: WorkUncheckedUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUncheckedUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type ItemUpsertWithoutHistorisInput = {
    update: XOR<ItemUpdateWithoutHistorisInput, ItemUncheckedUpdateWithoutHistorisInput>
    create: XOR<ItemCreateWithoutHistorisInput, ItemUncheckedCreateWithoutHistorisInput>
  }

  export type ItemUpdateWithoutHistorisInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    category?: OptionUpdateOneRequiredWithoutItemCategorysNestedInput
    type?: OptionUpdateOneWithoutItemTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    works?: WorkItemsUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutHistorisInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type WorkUpsertWithoutHistorisInput = {
    update: XOR<WorkUpdateWithoutHistorisInput, WorkUncheckedUpdateWithoutHistorisInput>
    create: XOR<WorkCreateWithoutHistorisInput, WorkUncheckedCreateWithoutHistorisInput>
  }

  export type WorkUpdateWithoutHistorisInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: OptionUpdateOneRequiredWithoutWorkTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutWorksNestedInput
    items?: WorkItemsUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutHistorisInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    items?: WorkItemsUncheckedUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkItemsUpsertWithoutHistorisInput = {
    update: XOR<WorkItemsUpdateWithoutHistorisInput, WorkItemsUncheckedUpdateWithoutHistorisInput>
    create: XOR<WorkItemsCreateWithoutHistorisInput, WorkItemsUncheckedCreateWithoutHistorisInput>
  }

  export type WorkItemsUpdateWithoutHistorisInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    work?: WorkUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutWorksNestedInput
    unit?: UnitUpdateOneWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateWithoutHistorisInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateUpsertWithoutHistorisInput = {
    update: XOR<TemplateUpdateWithoutHistorisInput, TemplateUncheckedUpdateWithoutHistorisInput>
    create: XOR<TemplateCreateWithoutHistorisInput, TemplateUncheckedCreateWithoutHistorisInput>
  }

  export type TemplateUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: TemplateDataUpdateOneWithoutActiveNestedInput
    records?: TemplateDataUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    activeId?: NullableStringFieldUpdateOperationsInput | string | null
    records?: TemplateDataUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ImageUpsertWithoutHistorisInput = {
    update: XOR<ImageUpdateWithoutHistorisInput, ImageUncheckedUpdateWithoutHistorisInput>
    create: XOR<ImageCreateWithoutHistorisInput, ImageUncheckedCreateWithoutHistorisInput>
  }

  export type ImageUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    files?: FileUpdateManyWithoutGroupNestedInput
  }

  export type ImageUncheckedUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    files?: FileUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type FileUpsertWithoutHistorisInput = {
    update: XOR<FileUpdateWithoutHistorisInput, FileUncheckedUpdateWithoutHistorisInput>
    create: XOR<FileCreateWithoutHistorisInput, FileUncheckedCreateWithoutHistorisInput>
  }

  export type FileUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    group?: ImageUpdateOneRequiredWithoutFilesNestedInput
    fields?: TemplateFieldUpdateManyWithoutImageNestedInput
  }

  export type FileUncheckedUpdateWithoutHistorisInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    fields?: TemplateFieldUncheckedUpdateManyWithoutImageNestedInput
  }

  export type UserCreateWithoutDevicesInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    company?: CompanyCreateNestedOneWithoutUsersInput
    trackers?: HistoriCreateNestedManyWithoutRefInput
    historis?: HistoriCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    companyId?: string | null
    trackers?: HistoriUncheckedCreateNestedManyWithoutRefInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    company?: CompanyUpdateOneWithoutUsersNestedInput
    trackers?: HistoriUpdateManyWithoutRefNestedInput
    historis?: HistoriUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    trackers?: HistoriUncheckedUpdateManyWithoutRefNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CoordinateCreateInput = {
    longitude: number
    latitude: number
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    trackers?: HistoriCreateNestedManyWithoutRefInput
    historis?: HistoriCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
    trackers?: HistoriUncheckedCreateNestedManyWithoutRefInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: Enumerable<UserCreateManyCompanyInput>
  }

  export type HistoriCreateWithoutCompanyInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutCompanyInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutCompanyInput, HistoriUncheckedCreateWithoutCompanyInput>
  }

  export type HistoriCreateManyCompanyInputEnvelope = {
    data: Enumerable<HistoriCreateManyCompanyInput>
  }

  export type AddressUpdateInput = {
    provinsi?: StringFieldUpdateOperationsInput | string
    kabupaten?: StringFieldUpdateOperationsInput | string
    kecamatan?: StringFieldUpdateOperationsInput | string
    kelurahan?: StringFieldUpdateOperationsInput | string
    kodepos?: StringFieldUpdateOperationsInput | string
    jalan?: StringFieldUpdateOperationsInput | string
    coordinate?: XOR<CoordinateNullableUpdateEnvelopeInput, CoordinateCreateInput> | null
  }

  export type TPhoneUpsertInput = {
    set: TPhoneCreateInput | null
    update: TPhoneUpdateInput
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    username?: StringFilter | string
    password?: StringFilter | string
    passhash?: StringFilter | string
    role?: EnumUserRoleFilter | UserRole
    active?: BoolFilter | boolean
    companyId?: StringNullableFilter | string | null
  }

  export type HistoriUpsertWithWhereUniqueWithoutCompanyInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutCompanyInput, HistoriUncheckedUpdateWithoutCompanyInput>
    create: XOR<HistoriCreateWithoutCompanyInput, HistoriUncheckedCreateWithoutCompanyInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutCompanyInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutCompanyInput, HistoriUncheckedUpdateWithoutCompanyInput>
  }

  export type HistoriUpdateManyWithWhereWithoutCompanyInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type HistoriScalarWhereInput = {
    AND?: Enumerable<HistoriScalarWhereInput>
    OR?: Enumerable<HistoriScalarWhereInput>
    NOT?: Enumerable<HistoriScalarWhereInput>
    id?: StringFilter | string
    type?: EnumHistoriTypeFilter | HistoriType
    model?: EnumHistoriModelFilter | HistoriModel
    step?: IntNullableFilter | number | null
    message?: StringNullableFilter | string | null
    refId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    userId?: StringNullableFilter | string | null
    companyId?: StringNullableFilter | string | null
    optionId?: StringNullableFilter | string | null
    unitId?: StringNullableFilter | string | null
    itemId?: StringNullableFilter | string | null
    workId?: StringNullableFilter | string | null
    workItemsId?: StringNullableFilter | string | null
    templateId?: StringNullableFilter | string | null
    imageId?: StringNullableFilter | string | null
    fileId?: StringNullableFilter | string | null
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
    historis?: HistoriCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    gid?: string | null
    name: string
    address: XOR<AddressCreateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableCreateEnvelopeInput, TPhoneCreateInput> | null
    limit?: number
    historis?: HistoriUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type HistoriCreateWithoutRefInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutRefInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutRefInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutRefInput, HistoriUncheckedCreateWithoutRefInput>
  }

  export type HistoriCreateManyRefInputEnvelope = {
    data: Enumerable<HistoriCreateManyRefInput>
  }

  export type HistoriCreateWithoutUserInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutUserInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutUserInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutUserInput, HistoriUncheckedCreateWithoutUserInput>
  }

  export type HistoriCreateManyUserInputEnvelope = {
    data: Enumerable<HistoriCreateManyUserInput>
  }

  export type DeviceCreateWithoutUserInput = {
    id?: string
    uuid: string
    model: string
    manufacturer: string
  }

  export type DeviceUncheckedCreateWithoutUserInput = {
    id?: string
    uuid: string
    model: string
    manufacturer: string
  }

  export type DeviceCreateOrConnectWithoutUserInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceCreateManyUserInputEnvelope = {
    data: Enumerable<DeviceCreateManyUserInput>
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
    historis?: HistoriUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    gid?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    address?: XOR<AddressUpdateEnvelopeInput, AddressCreateInput>
    phone?: XOR<TPhoneNullableUpdateEnvelopeInput, TPhoneCreateInput> | null
    limit?: IntFieldUpdateOperationsInput | number
    historis?: HistoriUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type HistoriUpsertWithWhereUniqueWithoutRefInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutRefInput, HistoriUncheckedUpdateWithoutRefInput>
    create: XOR<HistoriCreateWithoutRefInput, HistoriUncheckedCreateWithoutRefInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutRefInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutRefInput, HistoriUncheckedUpdateWithoutRefInput>
  }

  export type HistoriUpdateManyWithWhereWithoutRefInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutTrackersInput>
  }

  export type HistoriUpsertWithWhereUniqueWithoutUserInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutUserInput, HistoriUncheckedUpdateWithoutUserInput>
    create: XOR<HistoriCreateWithoutUserInput, HistoriUncheckedCreateWithoutUserInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutUserInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutUserInput, HistoriUncheckedUpdateWithoutUserInput>
  }

  export type HistoriUpdateManyWithWhereWithoutUserInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type DeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUpdateManyWithWhereWithoutUserInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutDevicesInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: Enumerable<DeviceScalarWhereInput>
    OR?: Enumerable<DeviceScalarWhereInput>
    NOT?: Enumerable<DeviceScalarWhereInput>
    id?: StringFilter | string
    uuid?: StringFilter | string
    model?: StringFilter | string
    manufacturer?: StringFilter | string
    userId?: StringFilter | string
  }

  export type ImageCreateWithoutFilesInput = {
    id?: string
    name: string
    historis?: HistoriCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    historis?: HistoriUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutFilesInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutFilesInput, ImageUncheckedCreateWithoutFilesInput>
  }

  export type HistoriCreateWithoutFileInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutFileInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
  }

  export type HistoriCreateOrConnectWithoutFileInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutFileInput, HistoriUncheckedCreateWithoutFileInput>
  }

  export type HistoriCreateManyFileInputEnvelope = {
    data: Enumerable<HistoriCreateManyFileInput>
  }

  export type TemplateFieldCreateWithoutImageInput = {
    id?: string
    name: string
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
    data: TemplateDataCreateNestedOneWithoutFieldsInput
  }

  export type TemplateFieldUncheckedCreateWithoutImageInput = {
    id?: string
    dataId: string
    name: string
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldCreateOrConnectWithoutImageInput = {
    where: TemplateFieldWhereUniqueInput
    create: XOR<TemplateFieldCreateWithoutImageInput, TemplateFieldUncheckedCreateWithoutImageInput>
  }

  export type TemplateFieldCreateManyImageInputEnvelope = {
    data: Enumerable<TemplateFieldCreateManyImageInput>
  }

  export type ImageUpsertWithoutFilesInput = {
    update: XOR<ImageUpdateWithoutFilesInput, ImageUncheckedUpdateWithoutFilesInput>
    create: XOR<ImageCreateWithoutFilesInput, ImageUncheckedCreateWithoutFilesInput>
  }

  export type ImageUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUncheckedUpdateManyWithoutImageNestedInput
  }

  export type HistoriUpsertWithWhereUniqueWithoutFileInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutFileInput, HistoriUncheckedUpdateWithoutFileInput>
    create: XOR<HistoriCreateWithoutFileInput, HistoriUncheckedCreateWithoutFileInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutFileInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutFileInput, HistoriUncheckedUpdateWithoutFileInput>
  }

  export type HistoriUpdateManyWithWhereWithoutFileInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type TemplateFieldUpsertWithWhereUniqueWithoutImageInput = {
    where: TemplateFieldWhereUniqueInput
    update: XOR<TemplateFieldUpdateWithoutImageInput, TemplateFieldUncheckedUpdateWithoutImageInput>
    create: XOR<TemplateFieldCreateWithoutImageInput, TemplateFieldUncheckedCreateWithoutImageInput>
  }

  export type TemplateFieldUpdateWithWhereUniqueWithoutImageInput = {
    where: TemplateFieldWhereUniqueInput
    data: XOR<TemplateFieldUpdateWithoutImageInput, TemplateFieldUncheckedUpdateWithoutImageInput>
  }

  export type TemplateFieldUpdateManyWithWhereWithoutImageInput = {
    where: TemplateFieldScalarWhereInput
    data: XOR<TemplateFieldUpdateManyMutationInput, TemplateFieldUncheckedUpdateManyWithoutFieldsInput>
  }

  export type TemplateFieldScalarWhereInput = {
    AND?: Enumerable<TemplateFieldScalarWhereInput>
    OR?: Enumerable<TemplateFieldScalarWhereInput>
    NOT?: Enumerable<TemplateFieldScalarWhereInput>
    id?: StringFilter | string
    dataId?: StringFilter | string
    name?: StringFilter | string
    imageId?: StringNullableFilter | string | null
    imageUrl?: StringNullableFilter | string | null
  }

  export type FileCreateWithoutGroupInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    historis?: HistoriCreateNestedManyWithoutFileInput
    fields?: TemplateFieldCreateNestedManyWithoutImageInput
  }

  export type FileUncheckedCreateWithoutGroupInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    historis?: HistoriUncheckedCreateNestedManyWithoutFileInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutImageInput
  }

  export type FileCreateOrConnectWithoutGroupInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutGroupInput, FileUncheckedCreateWithoutGroupInput>
  }

  export type FileCreateManyGroupInputEnvelope = {
    data: Enumerable<FileCreateManyGroupInput>
  }

  export type HistoriCreateWithoutImageInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutImageInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutImageInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutImageInput, HistoriUncheckedCreateWithoutImageInput>
  }

  export type HistoriCreateManyImageInputEnvelope = {
    data: Enumerable<HistoriCreateManyImageInput>
  }

  export type FileUpsertWithWhereUniqueWithoutGroupInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutGroupInput, FileUncheckedUpdateWithoutGroupInput>
    create: XOR<FileCreateWithoutGroupInput, FileUncheckedCreateWithoutGroupInput>
  }

  export type FileUpdateWithWhereUniqueWithoutGroupInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutGroupInput, FileUncheckedUpdateWithoutGroupInput>
  }

  export type FileUpdateManyWithWhereWithoutGroupInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutFilesInput>
  }

  export type FileScalarWhereInput = {
    AND?: Enumerable<FileScalarWhereInput>
    OR?: Enumerable<FileScalarWhereInput>
    NOT?: Enumerable<FileScalarWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    url?: StringFilter | string
    size?: IntFilter | number
    width?: IntFilter | number
    height?: IntFilter | number
    type?: StringFilter | string
    groupId?: StringFilter | string
  }

  export type HistoriUpsertWithWhereUniqueWithoutImageInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutImageInput, HistoriUncheckedUpdateWithoutImageInput>
    create: XOR<HistoriCreateWithoutImageInput, HistoriUncheckedCreateWithoutImageInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutImageInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutImageInput, HistoriUncheckedUpdateWithoutImageInput>
  }

  export type HistoriUpdateManyWithWhereWithoutImageInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type ItemCreateWithoutCategoryInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    type?: OptionCreateNestedOneWithoutItemTypesInput
    unit: UnitCreateNestedOneWithoutItemsInput
    works?: WorkItemsCreateNestedManyWithoutItemInput
    historis?: HistoriCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutCategoryInput = {
    id?: string
    model: ItemModel
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedCreateNestedManyWithoutItemInput
    historis?: HistoriUncheckedCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemCreateManyCategoryInputEnvelope = {
    data: Enumerable<ItemCreateManyCategoryInput>
  }

  export type ItemCreateWithoutTypeInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    category: OptionCreateNestedOneWithoutItemCategorysInput
    unit: UnitCreateNestedOneWithoutItemsInput
    works?: WorkItemsCreateNestedManyWithoutItemInput
    historis?: HistoriCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutTypeInput = {
    id?: string
    model: ItemModel
    categoryId: string
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedCreateNestedManyWithoutItemInput
    historis?: HistoriUncheckedCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutTypeInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTypeInput, ItemUncheckedCreateWithoutTypeInput>
  }

  export type ItemCreateManyTypeInputEnvelope = {
    data: Enumerable<ItemCreateManyTypeInput>
  }

  export type WorkCreateWithoutTypeInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    unit: UnitCreateNestedOneWithoutWorksInput
    items?: WorkItemsCreateNestedManyWithoutWorkInput
    historis?: HistoriCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutTypeInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    unitId: string
    items?: WorkItemsUncheckedCreateNestedManyWithoutWorkInput
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutTypeInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutTypeInput, WorkUncheckedCreateWithoutTypeInput>
  }

  export type WorkCreateManyTypeInputEnvelope = {
    data: Enumerable<WorkCreateManyTypeInput>
  }

  export type HistoriCreateWithoutOptionInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutOptionInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutOptionInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutOptionInput, HistoriUncheckedCreateWithoutOptionInput>
  }

  export type HistoriCreateManyOptionInputEnvelope = {
    data: Enumerable<HistoriCreateManyOptionInput>
  }

  export type ItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<ItemCreateWithoutCategoryInput, ItemUncheckedCreateWithoutCategoryInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutCategoryInput, ItemUncheckedUpdateWithoutCategoryInput>
  }

  export type ItemUpdateManyWithWhereWithoutCategoryInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemCategorysInput>
  }

  export type ItemScalarWhereInput = {
    AND?: Enumerable<ItemScalarWhereInput>
    OR?: Enumerable<ItemScalarWhereInput>
    NOT?: Enumerable<ItemScalarWhereInput>
    id?: StringFilter | string
    model?: EnumItemModelFilter | ItemModel
    categoryId?: StringFilter | string
    typeId?: StringNullableFilter | string | null
    unitId?: StringFilter | string
    code?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    price?: IntFilter | number
    trim?: BoolFilter | boolean
    active?: BoolFilter | boolean
    introIds?: StringNullableListFilter
  }

  export type ItemUpsertWithWhereUniqueWithoutTypeInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutTypeInput, ItemUncheckedUpdateWithoutTypeInput>
    create: XOR<ItemCreateWithoutTypeInput, ItemUncheckedCreateWithoutTypeInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutTypeInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutTypeInput, ItemUncheckedUpdateWithoutTypeInput>
  }

  export type ItemUpdateManyWithWhereWithoutTypeInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemTypesInput>
  }

  export type WorkUpsertWithWhereUniqueWithoutTypeInput = {
    where: WorkWhereUniqueInput
    update: XOR<WorkUpdateWithoutTypeInput, WorkUncheckedUpdateWithoutTypeInput>
    create: XOR<WorkCreateWithoutTypeInput, WorkUncheckedCreateWithoutTypeInput>
  }

  export type WorkUpdateWithWhereUniqueWithoutTypeInput = {
    where: WorkWhereUniqueInput
    data: XOR<WorkUpdateWithoutTypeInput, WorkUncheckedUpdateWithoutTypeInput>
  }

  export type WorkUpdateManyWithWhereWithoutTypeInput = {
    where: WorkScalarWhereInput
    data: XOR<WorkUpdateManyMutationInput, WorkUncheckedUpdateManyWithoutWorkTypesInput>
  }

  export type WorkScalarWhereInput = {
    AND?: Enumerable<WorkScalarWhereInput>
    OR?: Enumerable<WorkScalarWhereInput>
    NOT?: Enumerable<WorkScalarWhereInput>
    id?: StringFilter | string
    model?: EnumWorkModelFilter | WorkModel
    code?: StringFilter | string
    name?: StringFilter | string
    active?: BoolFilter | boolean
    typeId?: StringFilter | string
    unitId?: StringFilter | string
  }

  export type HistoriUpsertWithWhereUniqueWithoutOptionInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutOptionInput, HistoriUncheckedUpdateWithoutOptionInput>
    create: XOR<HistoriCreateWithoutOptionInput, HistoriUncheckedCreateWithoutOptionInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutOptionInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutOptionInput, HistoriUncheckedUpdateWithoutOptionInput>
  }

  export type HistoriUpdateManyWithWhereWithoutOptionInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type ItemCreateWithoutUnitInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    category: OptionCreateNestedOneWithoutItemCategorysInput
    type?: OptionCreateNestedOneWithoutItemTypesInput
    works?: WorkItemsCreateNestedManyWithoutItemInput
    historis?: HistoriCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutUnitInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedCreateNestedManyWithoutItemInput
    historis?: HistoriUncheckedCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutUnitInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemCreateManyUnitInputEnvelope = {
    data: Enumerable<ItemCreateManyUnitInput>
  }

  export type WorkCreateWithoutUnitInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    type: OptionCreateNestedOneWithoutWorkTypesInput
    items?: WorkItemsCreateNestedManyWithoutWorkInput
    historis?: HistoriCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutUnitInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    items?: WorkItemsUncheckedCreateNestedManyWithoutWorkInput
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutUnitInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutUnitInput, WorkUncheckedCreateWithoutUnitInput>
  }

  export type WorkCreateManyUnitInputEnvelope = {
    data: Enumerable<WorkCreateManyUnitInput>
  }

  export type WorkItemsCreateWithoutUnitInput = {
    id?: string
    model: WorkModel
    coefficient: number
    work: WorkCreateNestedOneWithoutItemsInput
    item: ItemCreateNestedOneWithoutWorksInput
    historis?: HistoriCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsUncheckedCreateWithoutUnitInput = {
    id?: string
    model: WorkModel
    workId: string
    itemId: string
    coefficient: number
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsCreateOrConnectWithoutUnitInput = {
    where: WorkItemsWhereUniqueInput
    create: XOR<WorkItemsCreateWithoutUnitInput, WorkItemsUncheckedCreateWithoutUnitInput>
  }

  export type WorkItemsCreateManyUnitInputEnvelope = {
    data: Enumerable<WorkItemsCreateManyUnitInput>
  }

  export type HistoriCreateWithoutUnitInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutUnitInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutUnitInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutUnitInput, HistoriUncheckedCreateWithoutUnitInput>
  }

  export type HistoriCreateManyUnitInputEnvelope = {
    data: Enumerable<HistoriCreateManyUnitInput>
  }

  export type TemplateWorkItemCreateWithoutUnitInput = {
    id?: string
    type: ItemModel
    coefficient: number
    item: ItemCreateNestedOneWithoutTWorksInput
    parent: TemplateWorkCreateNestedOneWithoutItemsInput
  }

  export type TemplateWorkItemUncheckedCreateWithoutUnitInput = {
    id?: string
    type: ItemModel
    itemId: string
    coefficient: number
    parentId: string
  }

  export type TemplateWorkItemCreateOrConnectWithoutUnitInput = {
    where: TemplateWorkItemWhereUniqueInput
    create: XOR<TemplateWorkItemCreateWithoutUnitInput, TemplateWorkItemUncheckedCreateWithoutUnitInput>
  }

  export type TemplateWorkItemCreateManyUnitInputEnvelope = {
    data: Enumerable<TemplateWorkItemCreateManyUnitInput>
  }

  export type ItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
    create: XOR<ItemCreateWithoutUnitInput, ItemUncheckedCreateWithoutUnitInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutUnitInput, ItemUncheckedUpdateWithoutUnitInput>
  }

  export type ItemUpdateManyWithWhereWithoutUnitInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type WorkUpsertWithWhereUniqueWithoutUnitInput = {
    where: WorkWhereUniqueInput
    update: XOR<WorkUpdateWithoutUnitInput, WorkUncheckedUpdateWithoutUnitInput>
    create: XOR<WorkCreateWithoutUnitInput, WorkUncheckedCreateWithoutUnitInput>
  }

  export type WorkUpdateWithWhereUniqueWithoutUnitInput = {
    where: WorkWhereUniqueInput
    data: XOR<WorkUpdateWithoutUnitInput, WorkUncheckedUpdateWithoutUnitInput>
  }

  export type WorkUpdateManyWithWhereWithoutUnitInput = {
    where: WorkScalarWhereInput
    data: XOR<WorkUpdateManyMutationInput, WorkUncheckedUpdateManyWithoutWorksInput>
  }

  export type WorkItemsUpsertWithWhereUniqueWithoutUnitInput = {
    where: WorkItemsWhereUniqueInput
    update: XOR<WorkItemsUpdateWithoutUnitInput, WorkItemsUncheckedUpdateWithoutUnitInput>
    create: XOR<WorkItemsCreateWithoutUnitInput, WorkItemsUncheckedCreateWithoutUnitInput>
  }

  export type WorkItemsUpdateWithWhereUniqueWithoutUnitInput = {
    where: WorkItemsWhereUniqueInput
    data: XOR<WorkItemsUpdateWithoutUnitInput, WorkItemsUncheckedUpdateWithoutUnitInput>
  }

  export type WorkItemsUpdateManyWithWhereWithoutUnitInput = {
    where: WorkItemsScalarWhereInput
    data: XOR<WorkItemsUpdateManyMutationInput, WorkItemsUncheckedUpdateManyWithoutWorkItemsInput>
  }

  export type WorkItemsScalarWhereInput = {
    AND?: Enumerable<WorkItemsScalarWhereInput>
    OR?: Enumerable<WorkItemsScalarWhereInput>
    NOT?: Enumerable<WorkItemsScalarWhereInput>
    id?: StringFilter | string
    model?: EnumWorkModelFilter | WorkModel
    workId?: StringFilter | string
    itemId?: StringFilter | string
    coefficient?: FloatFilter | number
    unitId?: StringNullableFilter | string | null
  }

  export type HistoriUpsertWithWhereUniqueWithoutUnitInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutUnitInput, HistoriUncheckedUpdateWithoutUnitInput>
    create: XOR<HistoriCreateWithoutUnitInput, HistoriUncheckedCreateWithoutUnitInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutUnitInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutUnitInput, HistoriUncheckedUpdateWithoutUnitInput>
  }

  export type HistoriUpdateManyWithWhereWithoutUnitInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type TemplateWorkItemUpsertWithWhereUniqueWithoutUnitInput = {
    where: TemplateWorkItemWhereUniqueInput
    update: XOR<TemplateWorkItemUpdateWithoutUnitInput, TemplateWorkItemUncheckedUpdateWithoutUnitInput>
    create: XOR<TemplateWorkItemCreateWithoutUnitInput, TemplateWorkItemUncheckedCreateWithoutUnitInput>
  }

  export type TemplateWorkItemUpdateWithWhereUniqueWithoutUnitInput = {
    where: TemplateWorkItemWhereUniqueInput
    data: XOR<TemplateWorkItemUpdateWithoutUnitInput, TemplateWorkItemUncheckedUpdateWithoutUnitInput>
  }

  export type TemplateWorkItemUpdateManyWithWhereWithoutUnitInput = {
    where: TemplateWorkItemScalarWhereInput
    data: XOR<TemplateWorkItemUpdateManyMutationInput, TemplateWorkItemUncheckedUpdateManyWithoutTWorkItemsInput>
  }

  export type TemplateWorkItemScalarWhereInput = {
    AND?: Enumerable<TemplateWorkItemScalarWhereInput>
    OR?: Enumerable<TemplateWorkItemScalarWhereInput>
    NOT?: Enumerable<TemplateWorkItemScalarWhereInput>
    id?: StringFilter | string
    type?: EnumItemModelFilter | ItemModel
    itemId?: StringFilter | string
    coefficient?: FloatFilter | number
    unitId?: StringFilter | string
    parentId?: StringFilter | string
  }

  export type OptionCreateWithoutItemCategorysInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemTypes?: ItemCreateNestedManyWithoutTypeInput
    workTypes?: WorkCreateNestedManyWithoutTypeInput
    historis?: HistoriCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutItemCategorysInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemTypes?: ItemUncheckedCreateNestedManyWithoutTypeInput
    workTypes?: WorkUncheckedCreateNestedManyWithoutTypeInput
    historis?: HistoriUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutItemCategorysInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutItemCategorysInput, OptionUncheckedCreateWithoutItemCategorysInput>
  }

  export type OptionCreateWithoutItemTypesInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemCreateNestedManyWithoutCategoryInput
    workTypes?: WorkCreateNestedManyWithoutTypeInput
    historis?: HistoriCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutItemTypesInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    workTypes?: WorkUncheckedCreateNestedManyWithoutTypeInput
    historis?: HistoriUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutItemTypesInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutItemTypesInput, OptionUncheckedCreateWithoutItemTypesInput>
  }

  export type UnitCreateWithoutItemsInput = {
    id?: string
    name: string
    works?: WorkCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsCreateNestedManyWithoutUnitInput
    historis?: HistoriCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutItemsInput = {
    id?: string
    name: string
    works?: WorkUncheckedCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsUncheckedCreateNestedManyWithoutUnitInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
  }

  export type WorkItemsCreateWithoutItemInput = {
    id?: string
    model: WorkModel
    coefficient: number
    work: WorkCreateNestedOneWithoutItemsInput
    unit?: UnitCreateNestedOneWithoutWorkItemsInput
    historis?: HistoriCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsUncheckedCreateWithoutItemInput = {
    id?: string
    model: WorkModel
    workId: string
    coefficient: number
    unitId?: string | null
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsCreateOrConnectWithoutItemInput = {
    where: WorkItemsWhereUniqueInput
    create: XOR<WorkItemsCreateWithoutItemInput, WorkItemsUncheckedCreateWithoutItemInput>
  }

  export type WorkItemsCreateManyItemInputEnvelope = {
    data: Enumerable<WorkItemsCreateManyItemInput>
  }

  export type HistoriCreateWithoutItemInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutItemInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutItemInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutItemInput, HistoriUncheckedCreateWithoutItemInput>
  }

  export type HistoriCreateManyItemInputEnvelope = {
    data: Enumerable<HistoriCreateManyItemInput>
  }

  export type TemplateWorkItemCreateWithoutItemInput = {
    id?: string
    type: ItemModel
    coefficient: number
    unit: UnitCreateNestedOneWithoutTWorkItemsInput
    parent: TemplateWorkCreateNestedOneWithoutItemsInput
  }

  export type TemplateWorkItemUncheckedCreateWithoutItemInput = {
    id?: string
    type: ItemModel
    coefficient: number
    unitId: string
    parentId: string
  }

  export type TemplateWorkItemCreateOrConnectWithoutItemInput = {
    where: TemplateWorkItemWhereUniqueInput
    create: XOR<TemplateWorkItemCreateWithoutItemInput, TemplateWorkItemUncheckedCreateWithoutItemInput>
  }

  export type TemplateWorkItemCreateManyItemInputEnvelope = {
    data: Enumerable<TemplateWorkItemCreateManyItemInput>
  }

  export type OptionUpsertWithoutItemCategorysInput = {
    update: XOR<OptionUpdateWithoutItemCategorysInput, OptionUncheckedUpdateWithoutItemCategorysInput>
    create: XOR<OptionCreateWithoutItemCategorysInput, OptionUncheckedCreateWithoutItemCategorysInput>
  }

  export type OptionUpdateWithoutItemCategorysInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemTypes?: ItemUpdateManyWithoutTypeNestedInput
    workTypes?: WorkUpdateManyWithoutTypeNestedInput
    historis?: HistoriUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutItemCategorysInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemTypes?: ItemUncheckedUpdateManyWithoutTypeNestedInput
    workTypes?: WorkUncheckedUpdateManyWithoutTypeNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type OptionUpsertWithoutItemTypesInput = {
    update: XOR<OptionUpdateWithoutItemTypesInput, OptionUncheckedUpdateWithoutItemTypesInput>
    create: XOR<OptionCreateWithoutItemTypesInput, OptionUncheckedCreateWithoutItemTypesInput>
  }

  export type OptionUpdateWithoutItemTypesInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUpdateManyWithoutCategoryNestedInput
    workTypes?: WorkUpdateManyWithoutTypeNestedInput
    historis?: HistoriUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutItemTypesInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    workTypes?: WorkUncheckedUpdateManyWithoutTypeNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type UnitUpsertWithoutItemsInput = {
    update: XOR<UnitUpdateWithoutItemsInput, UnitUncheckedUpdateWithoutItemsInput>
    create: XOR<UnitCreateWithoutItemsInput, UnitUncheckedCreateWithoutItemsInput>
  }

  export type UnitUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    works?: WorkUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUpdateManyWithoutUnitNestedInput
    historis?: HistoriUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    works?: WorkUncheckedUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUncheckedUpdateManyWithoutUnitNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type WorkItemsUpsertWithWhereUniqueWithoutItemInput = {
    where: WorkItemsWhereUniqueInput
    update: XOR<WorkItemsUpdateWithoutItemInput, WorkItemsUncheckedUpdateWithoutItemInput>
    create: XOR<WorkItemsCreateWithoutItemInput, WorkItemsUncheckedCreateWithoutItemInput>
  }

  export type WorkItemsUpdateWithWhereUniqueWithoutItemInput = {
    where: WorkItemsWhereUniqueInput
    data: XOR<WorkItemsUpdateWithoutItemInput, WorkItemsUncheckedUpdateWithoutItemInput>
  }

  export type WorkItemsUpdateManyWithWhereWithoutItemInput = {
    where: WorkItemsScalarWhereInput
    data: XOR<WorkItemsUpdateManyMutationInput, WorkItemsUncheckedUpdateManyWithoutWorksInput>
  }

  export type HistoriUpsertWithWhereUniqueWithoutItemInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutItemInput, HistoriUncheckedUpdateWithoutItemInput>
    create: XOR<HistoriCreateWithoutItemInput, HistoriUncheckedCreateWithoutItemInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutItemInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutItemInput, HistoriUncheckedUpdateWithoutItemInput>
  }

  export type HistoriUpdateManyWithWhereWithoutItemInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type TemplateWorkItemUpsertWithWhereUniqueWithoutItemInput = {
    where: TemplateWorkItemWhereUniqueInput
    update: XOR<TemplateWorkItemUpdateWithoutItemInput, TemplateWorkItemUncheckedUpdateWithoutItemInput>
    create: XOR<TemplateWorkItemCreateWithoutItemInput, TemplateWorkItemUncheckedCreateWithoutItemInput>
  }

  export type TemplateWorkItemUpdateWithWhereUniqueWithoutItemInput = {
    where: TemplateWorkItemWhereUniqueInput
    data: XOR<TemplateWorkItemUpdateWithoutItemInput, TemplateWorkItemUncheckedUpdateWithoutItemInput>
  }

  export type TemplateWorkItemUpdateManyWithWhereWithoutItemInput = {
    where: TemplateWorkItemScalarWhereInput
    data: XOR<TemplateWorkItemUpdateManyMutationInput, TemplateWorkItemUncheckedUpdateManyWithoutTWorksInput>
  }

  export type OptionCreateWithoutWorkTypesInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemCreateNestedManyWithoutCategoryInput
    itemTypes?: ItemCreateNestedManyWithoutTypeInput
    historis?: HistoriCreateNestedManyWithoutOptionInput
  }

  export type OptionUncheckedCreateWithoutWorkTypesInput = {
    id?: string
    type: OptionType
    code?: string | null
    name: string
    itemCategorys?: ItemUncheckedCreateNestedManyWithoutCategoryInput
    itemTypes?: ItemUncheckedCreateNestedManyWithoutTypeInput
    historis?: HistoriUncheckedCreateNestedManyWithoutOptionInput
  }

  export type OptionCreateOrConnectWithoutWorkTypesInput = {
    where: OptionWhereUniqueInput
    create: XOR<OptionCreateWithoutWorkTypesInput, OptionUncheckedCreateWithoutWorkTypesInput>
  }

  export type UnitCreateWithoutWorksInput = {
    id?: string
    name: string
    items?: ItemCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsCreateNestedManyWithoutUnitInput
    historis?: HistoriCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutWorksInput = {
    id?: string
    name: string
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsUncheckedCreateNestedManyWithoutUnitInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutWorksInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutWorksInput, UnitUncheckedCreateWithoutWorksInput>
  }

  export type WorkItemsCreateWithoutWorkInput = {
    id?: string
    model: WorkModel
    coefficient: number
    item: ItemCreateNestedOneWithoutWorksInput
    unit?: UnitCreateNestedOneWithoutWorkItemsInput
    historis?: HistoriCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsUncheckedCreateWithoutWorkInput = {
    id?: string
    model: WorkModel
    itemId: string
    coefficient: number
    unitId?: string | null
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkItemsInput
  }

  export type WorkItemsCreateOrConnectWithoutWorkInput = {
    where: WorkItemsWhereUniqueInput
    create: XOR<WorkItemsCreateWithoutWorkInput, WorkItemsUncheckedCreateWithoutWorkInput>
  }

  export type WorkItemsCreateManyWorkInputEnvelope = {
    data: Enumerable<WorkItemsCreateManyWorkInput>
  }

  export type HistoriCreateWithoutWorkInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutWorkInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutWorkInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutWorkInput, HistoriUncheckedCreateWithoutWorkInput>
  }

  export type HistoriCreateManyWorkInputEnvelope = {
    data: Enumerable<HistoriCreateManyWorkInput>
  }

  export type TemplateWorkCreateWithoutWorkInput = {
    id?: string
    data: TemplateDataCreateNestedOneWithoutWorksInput
    items?: TemplateWorkItemCreateNestedManyWithoutParentInput
    stages?: StageCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkUncheckedCreateWithoutWorkInput = {
    id?: string
    dataId: string
    items?: TemplateWorkItemUncheckedCreateNestedManyWithoutParentInput
    stages?: StageUncheckedCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkCreateOrConnectWithoutWorkInput = {
    where: TemplateWorkWhereUniqueInput
    create: XOR<TemplateWorkCreateWithoutWorkInput, TemplateWorkUncheckedCreateWithoutWorkInput>
  }

  export type TemplateWorkCreateManyWorkInputEnvelope = {
    data: Enumerable<TemplateWorkCreateManyWorkInput>
  }

  export type OptionUpsertWithoutWorkTypesInput = {
    update: XOR<OptionUpdateWithoutWorkTypesInput, OptionUncheckedUpdateWithoutWorkTypesInput>
    create: XOR<OptionCreateWithoutWorkTypesInput, OptionUncheckedCreateWithoutWorkTypesInput>
  }

  export type OptionUpdateWithoutWorkTypesInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUpdateManyWithoutCategoryNestedInput
    itemTypes?: ItemUpdateManyWithoutTypeNestedInput
    historis?: HistoriUpdateManyWithoutOptionNestedInput
  }

  export type OptionUncheckedUpdateWithoutWorkTypesInput = {
    type?: EnumOptionTypeFieldUpdateOperationsInput | OptionType
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    itemCategorys?: ItemUncheckedUpdateManyWithoutCategoryNestedInput
    itemTypes?: ItemUncheckedUpdateManyWithoutTypeNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type UnitUpsertWithoutWorksInput = {
    update: XOR<UnitUpdateWithoutWorksInput, UnitUncheckedUpdateWithoutWorksInput>
    create: XOR<UnitCreateWithoutWorksInput, UnitUncheckedCreateWithoutWorksInput>
  }

  export type UnitUpdateWithoutWorksInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUpdateManyWithoutUnitNestedInput
    historis?: HistoriUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutWorksInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUncheckedUpdateManyWithoutUnitNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type WorkItemsUpsertWithWhereUniqueWithoutWorkInput = {
    where: WorkItemsWhereUniqueInput
    update: XOR<WorkItemsUpdateWithoutWorkInput, WorkItemsUncheckedUpdateWithoutWorkInput>
    create: XOR<WorkItemsCreateWithoutWorkInput, WorkItemsUncheckedCreateWithoutWorkInput>
  }

  export type WorkItemsUpdateWithWhereUniqueWithoutWorkInput = {
    where: WorkItemsWhereUniqueInput
    data: XOR<WorkItemsUpdateWithoutWorkInput, WorkItemsUncheckedUpdateWithoutWorkInput>
  }

  export type WorkItemsUpdateManyWithWhereWithoutWorkInput = {
    where: WorkItemsScalarWhereInput
    data: XOR<WorkItemsUpdateManyMutationInput, WorkItemsUncheckedUpdateManyWithoutItemsInput>
  }

  export type HistoriUpsertWithWhereUniqueWithoutWorkInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutWorkInput, HistoriUncheckedUpdateWithoutWorkInput>
    create: XOR<HistoriCreateWithoutWorkInput, HistoriUncheckedCreateWithoutWorkInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutWorkInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutWorkInput, HistoriUncheckedUpdateWithoutWorkInput>
  }

  export type HistoriUpdateManyWithWhereWithoutWorkInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type TemplateWorkUpsertWithWhereUniqueWithoutWorkInput = {
    where: TemplateWorkWhereUniqueInput
    update: XOR<TemplateWorkUpdateWithoutWorkInput, TemplateWorkUncheckedUpdateWithoutWorkInput>
    create: XOR<TemplateWorkCreateWithoutWorkInput, TemplateWorkUncheckedCreateWithoutWorkInput>
  }

  export type TemplateWorkUpdateWithWhereUniqueWithoutWorkInput = {
    where: TemplateWorkWhereUniqueInput
    data: XOR<TemplateWorkUpdateWithoutWorkInput, TemplateWorkUncheckedUpdateWithoutWorkInput>
  }

  export type TemplateWorkUpdateManyWithWhereWithoutWorkInput = {
    where: TemplateWorkScalarWhereInput
    data: XOR<TemplateWorkUpdateManyMutationInput, TemplateWorkUncheckedUpdateManyWithoutTemplatesInput>
  }

  export type TemplateWorkScalarWhereInput = {
    AND?: Enumerable<TemplateWorkScalarWhereInput>
    OR?: Enumerable<TemplateWorkScalarWhereInput>
    NOT?: Enumerable<TemplateWorkScalarWhereInput>
    id?: StringFilter | string
    dataId?: StringFilter | string
    workId?: StringFilter | string
  }

  export type WorkCreateWithoutItemsInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    type: OptionCreateNestedOneWithoutWorkTypesInput
    unit: UnitCreateNestedOneWithoutWorksInput
    historis?: HistoriCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutItemsInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    unitId: string
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkInput
    templates?: TemplateWorkUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutItemsInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutItemsInput, WorkUncheckedCreateWithoutItemsInput>
  }

  export type ItemCreateWithoutWorksInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    category: OptionCreateNestedOneWithoutItemCategorysInput
    type?: OptionCreateNestedOneWithoutItemTypesInput
    unit: UnitCreateNestedOneWithoutItemsInput
    historis?: HistoriCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutWorksInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    historis?: HistoriUncheckedCreateNestedManyWithoutItemInput
    tWorks?: TemplateWorkItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutWorksInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutWorksInput, ItemUncheckedCreateWithoutWorksInput>
  }

  export type UnitCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    items?: ItemCreateNestedManyWithoutUnitInput
    works?: WorkCreateNestedManyWithoutUnitInput
    historis?: HistoriCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    name: string
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
    works?: WorkUncheckedCreateNestedManyWithoutUnitInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUnitInput
    tWorkItems?: TemplateWorkItemUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutWorkItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutWorkItemsInput, UnitUncheckedCreateWithoutWorkItemsInput>
  }

  export type HistoriCreateWithoutWorkItemsInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    template?: TemplateCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutWorkItemsInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutWorkItemsInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutWorkItemsInput, HistoriUncheckedCreateWithoutWorkItemsInput>
  }

  export type HistoriCreateManyWorkItemsInputEnvelope = {
    data: Enumerable<HistoriCreateManyWorkItemsInput>
  }

  export type WorkUpsertWithoutItemsInput = {
    update: XOR<WorkUpdateWithoutItemsInput, WorkUncheckedUpdateWithoutItemsInput>
    create: XOR<WorkCreateWithoutItemsInput, WorkUncheckedCreateWithoutItemsInput>
  }

  export type WorkUpdateWithoutItemsInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: OptionUpdateOneRequiredWithoutWorkTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutWorksNestedInput
    historis?: HistoriUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutItemsInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUncheckedUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type ItemUpsertWithoutWorksInput = {
    update: XOR<ItemUpdateWithoutWorksInput, ItemUncheckedUpdateWithoutWorksInput>
    create: XOR<ItemCreateWithoutWorksInput, ItemUncheckedCreateWithoutWorksInput>
  }

  export type ItemUpdateWithoutWorksInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    category?: OptionUpdateOneRequiredWithoutItemCategorysNestedInput
    type?: OptionUpdateOneWithoutItemTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    historis?: HistoriUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutWorksInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    historis?: HistoriUncheckedUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UnitUpsertWithoutWorkItemsInput = {
    update: XOR<UnitUpdateWithoutWorkItemsInput, UnitUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<UnitCreateWithoutWorkItemsInput, UnitUncheckedCreateWithoutWorkItemsInput>
  }

  export type UnitUpdateWithoutWorkItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutUnitNestedInput
    works?: WorkUpdateManyWithoutUnitNestedInput
    historis?: HistoriUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutWorkItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
    works?: WorkUncheckedUpdateManyWithoutUnitNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUnitNestedInput
    tWorkItems?: TemplateWorkItemUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type HistoriUpsertWithWhereUniqueWithoutWorkItemsInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutWorkItemsInput, HistoriUncheckedUpdateWithoutWorkItemsInput>
    create: XOR<HistoriCreateWithoutWorkItemsInput, HistoriUncheckedCreateWithoutWorkItemsInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutWorkItemsInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutWorkItemsInput, HistoriUncheckedUpdateWithoutWorkItemsInput>
  }

  export type HistoriUpdateManyWithWhereWithoutWorkItemsInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type TemplateDataCreateWithoutActiveInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    template: TemplateCreateNestedOneWithoutRecordsInput
    spaces?: SpaceCreateNestedManyWithoutRefInput
    works?: TemplateWorkCreateNestedManyWithoutDataInput
    deds?: TemplateDEDCreateNestedManyWithoutDataInput
    fields?: TemplateFieldCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateWithoutActiveInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    spaces?: SpaceUncheckedCreateNestedManyWithoutRefInput
    works?: TemplateWorkUncheckedCreateNestedManyWithoutDataInput
    deds?: TemplateDEDUncheckedCreateNestedManyWithoutDataInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataCreateOrConnectWithoutActiveInput = {
    where: TemplateDataWhereUniqueInput
    create: XOR<TemplateDataCreateWithoutActiveInput, TemplateDataUncheckedCreateWithoutActiveInput>
  }

  export type TemplateDataCreateWithoutTemplateInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateCreateNestedOneWithoutActiveInput
    spaces?: SpaceCreateNestedManyWithoutRefInput
    works?: TemplateWorkCreateNestedManyWithoutDataInput
    deds?: TemplateDEDCreateNestedManyWithoutDataInput
    fields?: TemplateFieldCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateWithoutTemplateInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedCreateNestedOneWithoutActiveInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutRefInput
    works?: TemplateWorkUncheckedCreateNestedManyWithoutDataInput
    deds?: TemplateDEDUncheckedCreateNestedManyWithoutDataInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataCreateOrConnectWithoutTemplateInput = {
    where: TemplateDataWhereUniqueInput
    create: XOR<TemplateDataCreateWithoutTemplateInput, TemplateDataUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateDataCreateManyTemplateInputEnvelope = {
    data: Enumerable<TemplateDataCreateManyTemplateInput>
  }

  export type HistoriCreateWithoutTemplateInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    ref: UserCreateNestedOneWithoutTrackersInput
    user?: UserCreateNestedOneWithoutHistorisInput
    company?: CompanyCreateNestedOneWithoutHistorisInput
    option?: OptionCreateNestedOneWithoutHistorisInput
    unit?: UnitCreateNestedOneWithoutHistorisInput
    item?: ItemCreateNestedOneWithoutHistorisInput
    work?: WorkCreateNestedOneWithoutHistorisInput
    workItems?: WorkItemsCreateNestedOneWithoutHistorisInput
    image?: ImageCreateNestedOneWithoutHistorisInput
    file?: FileCreateNestedOneWithoutHistorisInput
  }

  export type HistoriUncheckedCreateWithoutTemplateInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateOrConnectWithoutTemplateInput = {
    where: HistoriWhereUniqueInput
    create: XOR<HistoriCreateWithoutTemplateInput, HistoriUncheckedCreateWithoutTemplateInput>
  }

  export type HistoriCreateManyTemplateInputEnvelope = {
    data: Enumerable<HistoriCreateManyTemplateInput>
  }

  export type TemplateDataUpsertWithoutActiveInput = {
    update: XOR<TemplateDataUpdateWithoutActiveInput, TemplateDataUncheckedUpdateWithoutActiveInput>
    create: XOR<TemplateDataCreateWithoutActiveInput, TemplateDataUncheckedCreateWithoutActiveInput>
  }

  export type TemplateDataUpdateWithoutActiveInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    template?: TemplateUpdateOneRequiredWithoutRecordsNestedInput
    spaces?: SpaceUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateWithoutActiveInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    spaces?: SpaceUncheckedUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUncheckedUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUncheckedUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUpsertWithWhereUniqueWithoutTemplateInput = {
    where: TemplateDataWhereUniqueInput
    update: XOR<TemplateDataUpdateWithoutTemplateInput, TemplateDataUncheckedUpdateWithoutTemplateInput>
    create: XOR<TemplateDataCreateWithoutTemplateInput, TemplateDataUncheckedCreateWithoutTemplateInput>
  }

  export type TemplateDataUpdateWithWhereUniqueWithoutTemplateInput = {
    where: TemplateDataWhereUniqueInput
    data: XOR<TemplateDataUpdateWithoutTemplateInput, TemplateDataUncheckedUpdateWithoutTemplateInput>
  }

  export type TemplateDataUpdateManyWithWhereWithoutTemplateInput = {
    where: TemplateDataScalarWhereInput
    data: XOR<TemplateDataUpdateManyMutationInput, TemplateDataUncheckedUpdateManyWithoutRecordsInput>
  }

  export type TemplateDataScalarWhereInput = {
    AND?: Enumerable<TemplateDataScalarWhereInput>
    OR?: Enumerable<TemplateDataScalarWhereInput>
    NOT?: Enumerable<TemplateDataScalarWhereInput>
    id?: StringFilter | string
    step?: IntFilter | number
    publish?: BoolFilter | boolean
    templateId?: StringFilter | string
  }

  export type HistoriUpsertWithWhereUniqueWithoutTemplateInput = {
    where: HistoriWhereUniqueInput
    update: XOR<HistoriUpdateWithoutTemplateInput, HistoriUncheckedUpdateWithoutTemplateInput>
    create: XOR<HistoriCreateWithoutTemplateInput, HistoriUncheckedCreateWithoutTemplateInput>
  }

  export type HistoriUpdateWithWhereUniqueWithoutTemplateInput = {
    where: HistoriWhereUniqueInput
    data: XOR<HistoriUpdateWithoutTemplateInput, HistoriUncheckedUpdateWithoutTemplateInput>
  }

  export type HistoriUpdateManyWithWhereWithoutTemplateInput = {
    where: HistoriScalarWhereInput
    data: XOR<HistoriUpdateManyMutationInput, HistoriUncheckedUpdateManyWithoutHistorisInput>
  }

  export type ItemCreateWithoutTWorksInput = {
    id?: string
    model: ItemModel
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    category: OptionCreateNestedOneWithoutItemCategorysInput
    type?: OptionCreateNestedOneWithoutItemTypesInput
    unit: UnitCreateNestedOneWithoutItemsInput
    works?: WorkItemsCreateNestedManyWithoutItemInput
    historis?: HistoriCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutTWorksInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedCreateNestedManyWithoutItemInput
    historis?: HistoriUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutTWorksInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTWorksInput, ItemUncheckedCreateWithoutTWorksInput>
  }

  export type UnitCreateWithoutTWorkItemsInput = {
    id?: string
    name: string
    items?: ItemCreateNestedManyWithoutUnitInput
    works?: WorkCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsCreateNestedManyWithoutUnitInput
    historis?: HistoriCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutTWorkItemsInput = {
    id?: string
    name: string
    items?: ItemUncheckedCreateNestedManyWithoutUnitInput
    works?: WorkUncheckedCreateNestedManyWithoutUnitInput
    workItems?: WorkItemsUncheckedCreateNestedManyWithoutUnitInput
    historis?: HistoriUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutTWorkItemsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutTWorkItemsInput, UnitUncheckedCreateWithoutTWorkItemsInput>
  }

  export type TemplateWorkCreateWithoutItemsInput = {
    id?: string
    data: TemplateDataCreateNestedOneWithoutWorksInput
    work: WorkCreateNestedOneWithoutTemplatesInput
    stages?: StageCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkUncheckedCreateWithoutItemsInput = {
    id?: string
    dataId: string
    workId: string
    stages?: StageUncheckedCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkCreateOrConnectWithoutItemsInput = {
    where: TemplateWorkWhereUniqueInput
    create: XOR<TemplateWorkCreateWithoutItemsInput, TemplateWorkUncheckedCreateWithoutItemsInput>
  }

  export type ItemUpsertWithoutTWorksInput = {
    update: XOR<ItemUpdateWithoutTWorksInput, ItemUncheckedUpdateWithoutTWorksInput>
    create: XOR<ItemCreateWithoutTWorksInput, ItemUncheckedCreateWithoutTWorksInput>
  }

  export type ItemUpdateWithoutTWorksInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    category?: OptionUpdateOneRequiredWithoutItemCategorysNestedInput
    type?: OptionUpdateOneWithoutItemTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    works?: WorkItemsUpdateManyWithoutItemNestedInput
    historis?: HistoriUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutTWorksInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedUpdateManyWithoutItemNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutItemNestedInput
  }

  export type UnitUpsertWithoutTWorkItemsInput = {
    update: XOR<UnitUpdateWithoutTWorkItemsInput, UnitUncheckedUpdateWithoutTWorkItemsInput>
    create: XOR<UnitCreateWithoutTWorkItemsInput, UnitUncheckedCreateWithoutTWorkItemsInput>
  }

  export type UnitUpdateWithoutTWorkItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUpdateManyWithoutUnitNestedInput
    works?: WorkUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUpdateManyWithoutUnitNestedInput
    historis?: HistoriUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutTWorkItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    items?: ItemUncheckedUpdateManyWithoutUnitNestedInput
    works?: WorkUncheckedUpdateManyWithoutUnitNestedInput
    workItems?: WorkItemsUncheckedUpdateManyWithoutUnitNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type TemplateWorkUpsertWithoutItemsInput = {
    update: XOR<TemplateWorkUpdateWithoutItemsInput, TemplateWorkUncheckedUpdateWithoutItemsInput>
    create: XOR<TemplateWorkCreateWithoutItemsInput, TemplateWorkUncheckedCreateWithoutItemsInput>
  }

  export type TemplateWorkUpdateWithoutItemsInput = {
    data?: TemplateDataUpdateOneRequiredWithoutWorksNestedInput
    work?: WorkUpdateOneRequiredWithoutTemplatesNestedInput
    stages?: StageUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkUncheckedUpdateWithoutItemsInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    stages?: StageUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type TemplateDataCreateWithoutWorksInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateCreateNestedOneWithoutActiveInput
    template: TemplateCreateNestedOneWithoutRecordsInput
    spaces?: SpaceCreateNestedManyWithoutRefInput
    deds?: TemplateDEDCreateNestedManyWithoutDataInput
    fields?: TemplateFieldCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateWithoutWorksInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedCreateNestedOneWithoutActiveInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutRefInput
    deds?: TemplateDEDUncheckedCreateNestedManyWithoutDataInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataCreateOrConnectWithoutWorksInput = {
    where: TemplateDataWhereUniqueInput
    create: XOR<TemplateDataCreateWithoutWorksInput, TemplateDataUncheckedCreateWithoutWorksInput>
  }

  export type WorkCreateWithoutTemplatesInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    type: OptionCreateNestedOneWithoutWorkTypesInput
    unit: UnitCreateNestedOneWithoutWorksInput
    items?: WorkItemsCreateNestedManyWithoutWorkInput
    historis?: HistoriCreateNestedManyWithoutWorkInput
  }

  export type WorkUncheckedCreateWithoutTemplatesInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
    unitId: string
    items?: WorkItemsUncheckedCreateNestedManyWithoutWorkInput
    historis?: HistoriUncheckedCreateNestedManyWithoutWorkInput
  }

  export type WorkCreateOrConnectWithoutTemplatesInput = {
    where: WorkWhereUniqueInput
    create: XOR<WorkCreateWithoutTemplatesInput, WorkUncheckedCreateWithoutTemplatesInput>
  }

  export type TemplateWorkItemCreateWithoutParentInput = {
    id?: string
    type: ItemModel
    coefficient: number
    item: ItemCreateNestedOneWithoutTWorksInput
    unit: UnitCreateNestedOneWithoutTWorkItemsInput
  }

  export type TemplateWorkItemUncheckedCreateWithoutParentInput = {
    id?: string
    type: ItemModel
    itemId: string
    coefficient: number
    unitId: string
  }

  export type TemplateWorkItemCreateOrConnectWithoutParentInput = {
    where: TemplateWorkItemWhereUniqueInput
    create: XOR<TemplateWorkItemCreateWithoutParentInput, TemplateWorkItemUncheckedCreateWithoutParentInput>
  }

  export type TemplateWorkItemCreateManyParentInputEnvelope = {
    data: Enumerable<TemplateWorkItemCreateManyParentInput>
  }

  export type StageCreateWithoutWorkInput = {
    id?: string
    type: StageType
    operation: StageOpr
    parentId?: string | null
    refs?: string | null
    refParent?: boolean | null
    name?: string | null
    long: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    width: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    height: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    amount: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type StageUncheckedCreateWithoutWorkInput = {
    id?: string
    type: StageType
    operation: StageOpr
    parentId?: string | null
    refs?: string | null
    refParent?: boolean | null
    name?: string | null
    long: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    width: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    height: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    amount: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type StageCreateOrConnectWithoutWorkInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutWorkInput, StageUncheckedCreateWithoutWorkInput>
  }

  export type StageCreateManyWorkInputEnvelope = {
    data: Enumerable<StageCreateManyWorkInput>
  }

  export type TemplateDataUpsertWithoutWorksInput = {
    update: XOR<TemplateDataUpdateWithoutWorksInput, TemplateDataUncheckedUpdateWithoutWorksInput>
    create: XOR<TemplateDataCreateWithoutWorksInput, TemplateDataUncheckedCreateWithoutWorksInput>
  }

  export type TemplateDataUpdateWithoutWorksInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUpdateOneWithoutActiveNestedInput
    template?: TemplateUpdateOneRequiredWithoutRecordsNestedInput
    spaces?: SpaceUpdateManyWithoutRefNestedInput
    deds?: TemplateDEDUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateWithoutWorksInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedUpdateOneWithoutActiveNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutRefNestedInput
    deds?: TemplateDEDUncheckedUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutDataNestedInput
  }

  export type WorkUpsertWithoutTemplatesInput = {
    update: XOR<WorkUpdateWithoutTemplatesInput, WorkUncheckedUpdateWithoutTemplatesInput>
    create: XOR<WorkCreateWithoutTemplatesInput, WorkUncheckedCreateWithoutTemplatesInput>
  }

  export type WorkUpdateWithoutTemplatesInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: OptionUpdateOneRequiredWithoutWorkTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutWorksNestedInput
    items?: WorkItemsUpdateManyWithoutWorkNestedInput
    historis?: HistoriUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutTemplatesInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    items?: WorkItemsUncheckedUpdateManyWithoutWorkNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkItemUpsertWithWhereUniqueWithoutParentInput = {
    where: TemplateWorkItemWhereUniqueInput
    update: XOR<TemplateWorkItemUpdateWithoutParentInput, TemplateWorkItemUncheckedUpdateWithoutParentInput>
    create: XOR<TemplateWorkItemCreateWithoutParentInput, TemplateWorkItemUncheckedCreateWithoutParentInput>
  }

  export type TemplateWorkItemUpdateWithWhereUniqueWithoutParentInput = {
    where: TemplateWorkItemWhereUniqueInput
    data: XOR<TemplateWorkItemUpdateWithoutParentInput, TemplateWorkItemUncheckedUpdateWithoutParentInput>
  }

  export type TemplateWorkItemUpdateManyWithWhereWithoutParentInput = {
    where: TemplateWorkItemScalarWhereInput
    data: XOR<TemplateWorkItemUpdateManyMutationInput, TemplateWorkItemUncheckedUpdateManyWithoutItemsInput>
  }

  export type StageUpsertWithWhereUniqueWithoutWorkInput = {
    where: StageWhereUniqueInput
    update: XOR<StageUpdateWithoutWorkInput, StageUncheckedUpdateWithoutWorkInput>
    create: XOR<StageCreateWithoutWorkInput, StageUncheckedCreateWithoutWorkInput>
  }

  export type StageUpdateWithWhereUniqueWithoutWorkInput = {
    where: StageWhereUniqueInput
    data: XOR<StageUpdateWithoutWorkInput, StageUncheckedUpdateWithoutWorkInput>
  }

  export type StageUpdateManyWithWhereWithoutWorkInput = {
    where: StageScalarWhereInput
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyWithoutStagesInput>
  }

  export type StageScalarWhereInput = {
    AND?: Enumerable<StageScalarWhereInput>
    OR?: Enumerable<StageScalarWhereInput>
    NOT?: Enumerable<StageScalarWhereInput>
    id?: StringFilter | string
    workId?: StringFilter | string
    type?: EnumStageTypeFilter | StageType
    operation?: EnumStageOprFilter | StageOpr
    parentId?: StringNullableFilter | string | null
    refs?: StringNullableFilter | string | null
    refParent?: BoolNullableFilter | boolean | null
    name?: StringNullableFilter | string | null
  }

  export type TPropertyIntroCreateInput = {
    itemId: string
    qty: number
  }

  export type TPropertyPriceCreateInput = {
    type: ItemModel
    itemId: string
    workIds?: TPropertyPriceCreateworkIdsInput | Enumerable<string>
    coefficient: number
    rounding: number
    price: number
    pph: boolean
    ppn: boolean
  }

  export type TemplateCreateWithoutActiveInput = {
    id?: string
    name: string
    records?: TemplateDataCreateNestedManyWithoutTemplateInput
    historis?: HistoriCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutActiveInput = {
    id?: string
    name: string
    records?: TemplateDataUncheckedCreateNestedManyWithoutTemplateInput
    historis?: HistoriUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutActiveInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutActiveInput, TemplateUncheckedCreateWithoutActiveInput>
  }

  export type TemplateCreateWithoutRecordsInput = {
    id?: string
    name: string
    active?: TemplateDataCreateNestedOneWithoutActiveInput
    historis?: HistoriCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateWithoutRecordsInput = {
    id?: string
    name: string
    activeId?: string | null
    historis?: HistoriUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateCreateOrConnectWithoutRecordsInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutRecordsInput, TemplateUncheckedCreateWithoutRecordsInput>
  }

  export type SpaceCreateWithoutRefInput = {
    id?: string
    name: string
    long: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    width: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    height: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    amount: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceUncheckedCreateWithoutRefInput = {
    id?: string
    name: string
    long: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    width: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    height: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    amount: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceCreateOrConnectWithoutRefInput = {
    where: SpaceWhereUniqueInput
    create: XOR<SpaceCreateWithoutRefInput, SpaceUncheckedCreateWithoutRefInput>
  }

  export type SpaceCreateManyRefInputEnvelope = {
    data: Enumerable<SpaceCreateManyRefInput>
  }

  export type TemplateWorkCreateWithoutDataInput = {
    id?: string
    work: WorkCreateNestedOneWithoutTemplatesInput
    items?: TemplateWorkItemCreateNestedManyWithoutParentInput
    stages?: StageCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkUncheckedCreateWithoutDataInput = {
    id?: string
    workId: string
    items?: TemplateWorkItemUncheckedCreateNestedManyWithoutParentInput
    stages?: StageUncheckedCreateNestedManyWithoutWorkInput
  }

  export type TemplateWorkCreateOrConnectWithoutDataInput = {
    where: TemplateWorkWhereUniqueInput
    create: XOR<TemplateWorkCreateWithoutDataInput, TemplateWorkUncheckedCreateWithoutDataInput>
  }

  export type TemplateWorkCreateManyDataInputEnvelope = {
    data: Enumerable<TemplateWorkCreateManyDataInput>
  }

  export type TemplateDEDCreateWithoutDataInput = {
    id?: string
    name: string
    lists?: XOR<TDeDListListCreateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDUncheckedCreateWithoutDataInput = {
    id?: string
    name: string
    lists?: XOR<TDeDListListCreateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDCreateOrConnectWithoutDataInput = {
    where: TemplateDEDWhereUniqueInput
    create: XOR<TemplateDEDCreateWithoutDataInput, TemplateDEDUncheckedCreateWithoutDataInput>
  }

  export type TemplateDEDCreateManyDataInputEnvelope = {
    data: Enumerable<TemplateDEDCreateManyDataInput>
  }

  export type TemplateFieldCreateWithoutDataInput = {
    id?: string
    name: string
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
    image?: FileCreateNestedOneWithoutFieldsInput
  }

  export type TemplateFieldUncheckedCreateWithoutDataInput = {
    id?: string
    name: string
    imageId?: string | null
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldCreateOrConnectWithoutDataInput = {
    where: TemplateFieldWhereUniqueInput
    create: XOR<TemplateFieldCreateWithoutDataInput, TemplateFieldUncheckedCreateWithoutDataInput>
  }

  export type TemplateFieldCreateManyDataInputEnvelope = {
    data: Enumerable<TemplateFieldCreateManyDataInput>
  }

  export type TAroundUpsertInput = {
    set: TAroundCreateInput | null
    update: TAroundUpdateInput
  }

  export type TPropertyUpdateInput = {
    images?: NullableStringFieldUpdateOperationsInput | string | null
    intros?: XOR<TPropertyIntroListUpdateEnvelopeInput, Enumerable<TPropertyIntroCreateInput>>
    prices?: XOR<TPropertyPriceListUpdateEnvelopeInput, Enumerable<TPropertyPriceCreateInput>>
    pph?: BoolFieldUpdateOperationsInput | boolean
    ppn?: BoolFieldUpdateOperationsInput | boolean
    pphVal?: IntFieldUpdateOperationsInput | number
    ppnVal?: IntFieldUpdateOperationsInput | number
  }

  export type TemplateUpsertWithoutActiveInput = {
    update: XOR<TemplateUpdateWithoutActiveInput, TemplateUncheckedUpdateWithoutActiveInput>
    create: XOR<TemplateCreateWithoutActiveInput, TemplateUncheckedCreateWithoutActiveInput>
  }

  export type TemplateUpdateWithoutActiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    records?: TemplateDataUpdateManyWithoutTemplateNestedInput
    historis?: HistoriUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutActiveInput = {
    name?: StringFieldUpdateOperationsInput | string
    records?: TemplateDataUncheckedUpdateManyWithoutTemplateNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUpsertWithoutRecordsInput = {
    update: XOR<TemplateUpdateWithoutRecordsInput, TemplateUncheckedUpdateWithoutRecordsInput>
    create: XOR<TemplateCreateWithoutRecordsInput, TemplateUncheckedCreateWithoutRecordsInput>
  }

  export type TemplateUpdateWithoutRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    active?: TemplateDataUpdateOneWithoutActiveNestedInput
    historis?: HistoriUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateWithoutRecordsInput = {
    name?: StringFieldUpdateOperationsInput | string
    activeId?: NullableStringFieldUpdateOperationsInput | string | null
    historis?: HistoriUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type SpaceUpsertWithWhereUniqueWithoutRefInput = {
    where: SpaceWhereUniqueInput
    update: XOR<SpaceUpdateWithoutRefInput, SpaceUncheckedUpdateWithoutRefInput>
    create: XOR<SpaceCreateWithoutRefInput, SpaceUncheckedCreateWithoutRefInput>
  }

  export type SpaceUpdateWithWhereUniqueWithoutRefInput = {
    where: SpaceWhereUniqueInput
    data: XOR<SpaceUpdateWithoutRefInput, SpaceUncheckedUpdateWithoutRefInput>
  }

  export type SpaceUpdateManyWithWhereWithoutRefInput = {
    where: SpaceScalarWhereInput
    data: XOR<SpaceUpdateManyMutationInput, SpaceUncheckedUpdateManyWithoutSpacesInput>
  }

  export type SpaceScalarWhereInput = {
    AND?: Enumerable<SpaceScalarWhereInput>
    OR?: Enumerable<SpaceScalarWhereInput>
    NOT?: Enumerable<SpaceScalarWhereInput>
    id?: StringFilter | string
    refId?: StringFilter | string
    name?: StringFilter | string
  }

  export type TemplateWorkUpsertWithWhereUniqueWithoutDataInput = {
    where: TemplateWorkWhereUniqueInput
    update: XOR<TemplateWorkUpdateWithoutDataInput, TemplateWorkUncheckedUpdateWithoutDataInput>
    create: XOR<TemplateWorkCreateWithoutDataInput, TemplateWorkUncheckedCreateWithoutDataInput>
  }

  export type TemplateWorkUpdateWithWhereUniqueWithoutDataInput = {
    where: TemplateWorkWhereUniqueInput
    data: XOR<TemplateWorkUpdateWithoutDataInput, TemplateWorkUncheckedUpdateWithoutDataInput>
  }

  export type TemplateWorkUpdateManyWithWhereWithoutDataInput = {
    where: TemplateWorkScalarWhereInput
    data: XOR<TemplateWorkUpdateManyMutationInput, TemplateWorkUncheckedUpdateManyWithoutWorksInput>
  }

  export type TemplateDEDUpsertWithWhereUniqueWithoutDataInput = {
    where: TemplateDEDWhereUniqueInput
    update: XOR<TemplateDEDUpdateWithoutDataInput, TemplateDEDUncheckedUpdateWithoutDataInput>
    create: XOR<TemplateDEDCreateWithoutDataInput, TemplateDEDUncheckedCreateWithoutDataInput>
  }

  export type TemplateDEDUpdateWithWhereUniqueWithoutDataInput = {
    where: TemplateDEDWhereUniqueInput
    data: XOR<TemplateDEDUpdateWithoutDataInput, TemplateDEDUncheckedUpdateWithoutDataInput>
  }

  export type TemplateDEDUpdateManyWithWhereWithoutDataInput = {
    where: TemplateDEDScalarWhereInput
    data: XOR<TemplateDEDUpdateManyMutationInput, TemplateDEDUncheckedUpdateManyWithoutDedsInput>
  }

  export type TemplateDEDScalarWhereInput = {
    AND?: Enumerable<TemplateDEDScalarWhereInput>
    OR?: Enumerable<TemplateDEDScalarWhereInput>
    NOT?: Enumerable<TemplateDEDScalarWhereInput>
    id?: StringFilter | string
    dataId?: StringFilter | string
    name?: StringFilter | string
  }

  export type TemplateFieldUpsertWithWhereUniqueWithoutDataInput = {
    where: TemplateFieldWhereUniqueInput
    update: XOR<TemplateFieldUpdateWithoutDataInput, TemplateFieldUncheckedUpdateWithoutDataInput>
    create: XOR<TemplateFieldCreateWithoutDataInput, TemplateFieldUncheckedCreateWithoutDataInput>
  }

  export type TemplateFieldUpdateWithWhereUniqueWithoutDataInput = {
    where: TemplateFieldWhereUniqueInput
    data: XOR<TemplateFieldUpdateWithoutDataInput, TemplateFieldUncheckedUpdateWithoutDataInput>
  }

  export type TemplateFieldUpdateManyWithWhereWithoutDataInput = {
    where: TemplateFieldScalarWhereInput
    data: XOR<TemplateFieldUpdateManyMutationInput, TemplateFieldUncheckedUpdateManyWithoutFieldsInput>
  }

  export type TemplateDataCreateWithoutFieldsInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateCreateNestedOneWithoutActiveInput
    template: TemplateCreateNestedOneWithoutRecordsInput
    spaces?: SpaceCreateNestedManyWithoutRefInput
    works?: TemplateWorkCreateNestedManyWithoutDataInput
    deds?: TemplateDEDCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateWithoutFieldsInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedCreateNestedOneWithoutActiveInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutRefInput
    works?: TemplateWorkUncheckedCreateNestedManyWithoutDataInput
    deds?: TemplateDEDUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataCreateOrConnectWithoutFieldsInput = {
    where: TemplateDataWhereUniqueInput
    create: XOR<TemplateDataCreateWithoutFieldsInput, TemplateDataUncheckedCreateWithoutFieldsInput>
  }

  export type FileCreateWithoutFieldsInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    group: ImageCreateNestedOneWithoutFilesInput
    historis?: HistoriCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutFieldsInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
    groupId: string
    historis?: HistoriUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutFieldsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutFieldsInput, FileUncheckedCreateWithoutFieldsInput>
  }

  export type TFieldListUpdateManyInput = {
    where: TFieldListWhereInput
    data: TFieldListUpdateInput
  }

  export type TFieldListDeleteManyInput = {
    where: TFieldListWhereInput
  }

  export type TemplateDataUpsertWithoutFieldsInput = {
    update: XOR<TemplateDataUpdateWithoutFieldsInput, TemplateDataUncheckedUpdateWithoutFieldsInput>
    create: XOR<TemplateDataCreateWithoutFieldsInput, TemplateDataUncheckedCreateWithoutFieldsInput>
  }

  export type TemplateDataUpdateWithoutFieldsInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUpdateOneWithoutActiveNestedInput
    template?: TemplateUpdateOneRequiredWithoutRecordsNestedInput
    spaces?: SpaceUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateWithoutFieldsInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedUpdateOneWithoutActiveNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUncheckedUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUncheckedUpdateManyWithoutDataNestedInput
  }

  export type FileUpsertWithoutFieldsInput = {
    update: XOR<FileUpdateWithoutFieldsInput, FileUncheckedUpdateWithoutFieldsInput>
    create: XOR<FileCreateWithoutFieldsInput, FileUncheckedCreateWithoutFieldsInput>
  }

  export type FileUpdateWithoutFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    group?: ImageUpdateOneRequiredWithoutFilesNestedInput
    historis?: HistoriUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUncheckedUpdateManyWithoutFileNestedInput
  }

  export type TemplateDataCreateWithoutDedsInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateCreateNestedOneWithoutActiveInput
    template: TemplateCreateNestedOneWithoutRecordsInput
    spaces?: SpaceCreateNestedManyWithoutRefInput
    works?: TemplateWorkCreateNestedManyWithoutDataInput
    fields?: TemplateFieldCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateWithoutDedsInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedCreateNestedOneWithoutActiveInput
    spaces?: SpaceUncheckedCreateNestedManyWithoutRefInput
    works?: TemplateWorkUncheckedCreateNestedManyWithoutDataInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataCreateOrConnectWithoutDedsInput = {
    where: TemplateDataWhereUniqueInput
    create: XOR<TemplateDataCreateWithoutDedsInput, TemplateDataUncheckedCreateWithoutDedsInput>
  }

  export type TDeDListUpdateManyInput = {
    where: TDeDListWhereInput
    data: TDeDListUpdateInput
  }

  export type TDeDListDeleteManyInput = {
    where: TDeDListWhereInput
  }

  export type TemplateDataUpsertWithoutDedsInput = {
    update: XOR<TemplateDataUpdateWithoutDedsInput, TemplateDataUncheckedUpdateWithoutDedsInput>
    create: XOR<TemplateDataCreateWithoutDedsInput, TemplateDataUncheckedCreateWithoutDedsInput>
  }

  export type TemplateDataUpdateWithoutDedsInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUpdateOneWithoutActiveNestedInput
    template?: TemplateUpdateOneRequiredWithoutRecordsNestedInput
    spaces?: SpaceUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateWithoutDedsInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedUpdateOneWithoutActiveNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUncheckedUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataCreateWithoutSpacesInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateCreateNestedOneWithoutActiveInput
    template: TemplateCreateNestedOneWithoutRecordsInput
    works?: TemplateWorkCreateNestedManyWithoutDataInput
    deds?: TemplateDEDCreateNestedManyWithoutDataInput
    fields?: TemplateFieldCreateNestedManyWithoutDataInput
  }

  export type TemplateDataUncheckedCreateWithoutSpacesInput = {
    id?: string
    step?: number
    publish?: boolean
    templateId: string
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedCreateNestedOneWithoutActiveInput
    works?: TemplateWorkUncheckedCreateNestedManyWithoutDataInput
    deds?: TemplateDEDUncheckedCreateNestedManyWithoutDataInput
    fields?: TemplateFieldUncheckedCreateNestedManyWithoutDataInput
  }

  export type TemplateDataCreateOrConnectWithoutSpacesInput = {
    where: TemplateDataWhereUniqueInput
    create: XOR<TemplateDataCreateWithoutSpacesInput, TemplateDataUncheckedCreateWithoutSpacesInput>
  }

  export type SpaceValueUpdateInput = {
    fixed?: BoolFieldUpdateOperationsInput | boolean
    value?: FloatFieldUpdateOperationsInput | number
    min?: FloatFieldUpdateOperationsInput | number
    max?: FloatFieldUpdateOperationsInput | number
  }

  export type TValuesUpdateInput = {
    around?: FloatFieldUpdateOperationsInput | number
    broad?: FloatFieldUpdateOperationsInput | number
    volume?: FloatFieldUpdateOperationsInput | number
  }

  export type TemplateDataUpsertWithoutSpacesInput = {
    update: XOR<TemplateDataUpdateWithoutSpacesInput, TemplateDataUncheckedUpdateWithoutSpacesInput>
    create: XOR<TemplateDataCreateWithoutSpacesInput, TemplateDataUncheckedCreateWithoutSpacesInput>
  }

  export type TemplateDataUpdateWithoutSpacesInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUpdateOneWithoutActiveNestedInput
    template?: TemplateUpdateOneRequiredWithoutRecordsNestedInput
    works?: TemplateWorkUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateWithoutSpacesInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedUpdateOneWithoutActiveNestedInput
    works?: TemplateWorkUncheckedUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUncheckedUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutDataNestedInput
  }

  export type TemplateWorkCreateWithoutStagesInput = {
    id?: string
    data: TemplateDataCreateNestedOneWithoutWorksInput
    work: WorkCreateNestedOneWithoutTemplatesInput
    items?: TemplateWorkItemCreateNestedManyWithoutParentInput
  }

  export type TemplateWorkUncheckedCreateWithoutStagesInput = {
    id?: string
    dataId: string
    workId: string
    items?: TemplateWorkItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type TemplateWorkCreateOrConnectWithoutStagesInput = {
    where: TemplateWorkWhereUniqueInput
    create: XOR<TemplateWorkCreateWithoutStagesInput, TemplateWorkUncheckedCreateWithoutStagesInput>
  }

  export type StageValueUpdateInput = {
    ref?: NullableStringFieldUpdateOperationsInput | string | null
    refal?: NullableFloatFieldUpdateOperationsInput | number | null
    value?: FloatFieldUpdateOperationsInput | number
  }

  export type TemplateWorkUpsertWithoutStagesInput = {
    update: XOR<TemplateWorkUpdateWithoutStagesInput, TemplateWorkUncheckedUpdateWithoutStagesInput>
    create: XOR<TemplateWorkCreateWithoutStagesInput, TemplateWorkUncheckedCreateWithoutStagesInput>
  }

  export type TemplateWorkUpdateWithoutStagesInput = {
    data?: TemplateDataUpdateOneRequiredWithoutWorksNestedInput
    work?: WorkUpdateOneRequiredWithoutTemplatesNestedInput
    items?: TemplateWorkItemUpdateManyWithoutParentNestedInput
  }

  export type TemplateWorkUncheckedUpdateWithoutStagesInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    workId?: StringFieldUpdateOperationsInput | string
    items?: TemplateWorkItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CoordinateNullableCompositeFilter = {
    equals?: CoordinateObjectEqualityInput | null
    is?: CoordinateWhereInput | null
    isNot?: CoordinateWhereInput | null
    isSet?: boolean
  }

  export type TPropertyIntroCompositeListFilter = {
    equals?: Enumerable<TPropertyIntroObjectEqualityInput>
    every?: TPropertyIntroWhereInput
    some?: TPropertyIntroWhereInput
    none?: TPropertyIntroWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type TPropertyPriceCompositeListFilter = {
    equals?: Enumerable<TPropertyPriceObjectEqualityInput>
    every?: TPropertyPriceWhereInput
    some?: TPropertyPriceWhereInput
    none?: TPropertyPriceWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EnumEFieldTypeFilter = {
    equals?: EFieldType
    in?: Enumerable<EFieldType>
    notIn?: Enumerable<EFieldType>
    not?: NestedEnumEFieldTypeFilter | EFieldType
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    name: string
    email: string
    username: string
    password: string
    passhash: string
    role: UserRole
    active: boolean
  }

  export type HistoriCreateManyCompanyInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type CoordinateNullableUpdateEnvelopeInput = {
    set?: CoordinateCreateInput | null
    upsert?: CoordinateUpsertInput
    unset?: boolean
  }

  export type TPhoneUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    trackers?: HistoriUpdateManyWithoutRefNestedInput
    historis?: HistoriUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
    trackers?: HistoriUncheckedUpdateManyWithoutRefNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    passhash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | UserRole
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HistoriUpdateWithoutCompanyInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutCompanyInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriUncheckedUpdateManyWithoutHistorisInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriCreateManyRefInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriCreateManyUserInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type DeviceCreateManyUserInput = {
    id?: string
    uuid: string
    model: string
    manufacturer: string
  }

  export type HistoriUpdateWithoutRefInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutRefInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriUncheckedUpdateManyWithoutTrackersInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriUpdateWithoutUserInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutUserInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUncheckedUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceUncheckedUpdateManyWithoutDevicesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    manufacturer?: StringFieldUpdateOperationsInput | string
  }

  export type HistoriCreateManyFileInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
  }

  export type TemplateFieldCreateManyImageInput = {
    id?: string
    dataId: string
    name: string
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type HistoriUpdateWithoutFileInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutFileInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateFieldUpdateWithoutImageInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
    data?: TemplateDataUpdateOneRequiredWithoutFieldsNestedInput
  }

  export type TemplateFieldUncheckedUpdateWithoutImageInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TemplateFieldUncheckedUpdateManyWithoutFieldsInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type FileCreateManyGroupInput = {
    id?: string
    name: string
    url: string
    size: number
    width: number
    height: number
    type: string
  }

  export type HistoriCreateManyImageInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    fileId?: string | null
  }

  export type FileUpdateWithoutGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUpdateManyWithoutFileNestedInput
    fields?: TemplateFieldUpdateManyWithoutImageNestedInput
  }

  export type FileUncheckedUpdateWithoutGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    historis?: HistoriUncheckedUpdateManyWithoutFileNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutImageNestedInput
  }

  export type FileUncheckedUpdateManyWithoutFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type HistoriUpdateWithoutImageInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutImageInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateManyCategoryInput = {
    id?: string
    model: ItemModel
    typeId?: string | null
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
  }

  export type ItemCreateManyTypeInput = {
    id?: string
    model: ItemModel
    categoryId: string
    unitId: string
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
  }

  export type WorkCreateManyTypeInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    unitId: string
  }

  export type HistoriCreateManyOptionInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type ItemUpdateWithoutCategoryInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    type?: OptionUpdateOneWithoutItemTypesNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    works?: WorkItemsUpdateManyWithoutItemNestedInput
    historis?: HistoriUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutCategoryInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedUpdateManyWithoutItemNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemCategorysInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
  }

  export type ItemUpdateWithoutTypeInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    category?: OptionUpdateOneRequiredWithoutItemCategorysNestedInput
    unit?: UnitUpdateOneRequiredWithoutItemsNestedInput
    works?: WorkItemsUpdateManyWithoutItemNestedInput
    historis?: HistoriUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutTypeInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedUpdateManyWithoutItemNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemTypesInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    unitId?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
  }

  export type WorkUpdateWithoutTypeInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unit?: UnitUpdateOneRequiredWithoutWorksNestedInput
    items?: WorkItemsUpdateManyWithoutWorkNestedInput
    historis?: HistoriUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutTypeInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
    items?: WorkItemsUncheckedUpdateManyWithoutWorkNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateManyWithoutWorkTypesInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type HistoriUpdateWithoutOptionInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutOptionInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ItemCreateManyUnitInput = {
    id?: string
    model: ItemModel
    categoryId: string
    typeId?: string | null
    code?: string | null
    name?: string | null
    price: number
    trim: boolean
    active: boolean
    introIds?: ItemCreateintroIdsInput | Enumerable<string>
  }

  export type WorkCreateManyUnitInput = {
    id?: string
    model: WorkModel
    code: string
    name: string
    active: boolean
    typeId: string
  }

  export type WorkItemsCreateManyUnitInput = {
    id?: string
    model: WorkModel
    workId: string
    itemId: string
    coefficient: number
  }

  export type HistoriCreateManyUnitInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type TemplateWorkItemCreateManyUnitInput = {
    id?: string
    type: ItemModel
    itemId: string
    coefficient: number
    parentId: string
  }

  export type ItemUpdateWithoutUnitInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    category?: OptionUpdateOneRequiredWithoutItemCategorysNestedInput
    type?: OptionUpdateOneWithoutItemTypesNestedInput
    works?: WorkItemsUpdateManyWithoutItemNestedInput
    historis?: HistoriUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutUnitInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
    works?: WorkItemsUncheckedUpdateManyWithoutItemNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutItemNestedInput
    tWorks?: TemplateWorkItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutItemsInput = {
    model?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    categoryId?: StringFieldUpdateOperationsInput | string
    typeId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    trim?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    introIds?: ItemUpdateintroIdsInput | Enumerable<string>
  }

  export type WorkUpdateWithoutUnitInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    type?: OptionUpdateOneRequiredWithoutWorkTypesNestedInput
    items?: WorkItemsUpdateManyWithoutWorkNestedInput
    historis?: HistoriUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateWithoutUnitInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
    items?: WorkItemsUncheckedUpdateManyWithoutWorkNestedInput
    historis?: HistoriUncheckedUpdateManyWithoutWorkNestedInput
    templates?: TemplateWorkUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type WorkUncheckedUpdateManyWithoutWorksInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    typeId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemsUpdateWithoutUnitInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    work?: WorkUpdateOneRequiredWithoutItemsNestedInput
    item?: ItemUpdateOneRequiredWithoutWorksNestedInput
    historis?: HistoriUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateWithoutUnitInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    historis?: HistoriUncheckedUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateManyWithoutWorkItemsInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
  }

  export type HistoriUpdateWithoutUnitInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutUnitInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateWorkItemUpdateWithoutUnitInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutTWorksNestedInput
    parent?: TemplateWorkUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateWorkItemUncheckedUpdateWithoutUnitInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateWorkItemUncheckedUpdateManyWithoutTWorkItemsInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemsCreateManyItemInput = {
    id?: string
    model: WorkModel
    workId: string
    coefficient: number
    unitId?: string | null
  }

  export type HistoriCreateManyItemInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    workId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type TemplateWorkItemCreateManyItemInput = {
    id?: string
    type: ItemModel
    coefficient: number
    unitId: string
    parentId: string
  }

  export type WorkItemsUpdateWithoutItemInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    work?: WorkUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitUpdateOneWithoutWorkItemsNestedInput
    historis?: HistoriUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateWithoutItemInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    historis?: HistoriUncheckedUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateManyWithoutWorksInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    workId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriUpdateWithoutItemInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutItemInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateWorkItemUpdateWithoutItemInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    unit?: UnitUpdateOneRequiredWithoutTWorkItemsNestedInput
    parent?: TemplateWorkUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateWorkItemUncheckedUpdateWithoutItemInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateWorkItemUncheckedUpdateManyWithoutTWorksInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkItemsCreateManyWorkInput = {
    id?: string
    model: WorkModel
    itemId: string
    coefficient: number
    unitId?: string | null
  }

  export type HistoriCreateManyWorkInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workItemsId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type TemplateWorkCreateManyWorkInput = {
    id?: string
    dataId: string
  }

  export type WorkItemsUpdateWithoutWorkInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutWorksNestedInput
    unit?: UnitUpdateOneWithoutWorkItemsNestedInput
    historis?: HistoriUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateWithoutWorkInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    historis?: HistoriUncheckedUpdateManyWithoutWorkItemsNestedInput
  }

  export type WorkItemsUncheckedUpdateManyWithoutItemsInput = {
    model?: EnumWorkModelFieldUpdateOperationsInput | WorkModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistoriUpdateWithoutWorkInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutWorkInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateWorkUpdateWithoutWorkInput = {
    data?: TemplateDataUpdateOneRequiredWithoutWorksNestedInput
    items?: TemplateWorkItemUpdateManyWithoutParentNestedInput
    stages?: StageUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkUncheckedUpdateWithoutWorkInput = {
    dataId?: StringFieldUpdateOperationsInput | string
    items?: TemplateWorkItemUncheckedUpdateManyWithoutParentNestedInput
    stages?: StageUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkUncheckedUpdateManyWithoutTemplatesInput = {
    dataId?: StringFieldUpdateOperationsInput | string
  }

  export type HistoriCreateManyWorkItemsInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    templateId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type HistoriUpdateWithoutWorkItemsInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    template?: TemplateUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutWorkItemsInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateDataCreateManyTemplateInput = {
    id?: string
    step?: number
    publish?: boolean
    around?: XOR<TAroundNullableCreateEnvelopeInput, TAroundCreateInput> | null
    properties: XOR<TPropertyCreateEnvelopeInput, TPropertyCreateInput>
  }

  export type HistoriCreateManyTemplateInput = {
    id?: string
    type: HistoriType
    model: HistoriModel
    step?: number | null
    message?: string | null
    refId: string
    createdAt?: Date | string
    userId?: string | null
    companyId?: string | null
    optionId?: string | null
    unitId?: string | null
    itemId?: string | null
    workId?: string | null
    workItemsId?: string | null
    imageId?: string | null
    fileId?: string | null
  }

  export type TemplateDataUpdateWithoutTemplateInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUpdateOneWithoutActiveNestedInput
    spaces?: SpaceUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateWithoutTemplateInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
    active?: TemplateUncheckedUpdateOneWithoutActiveNestedInput
    spaces?: SpaceUncheckedUpdateManyWithoutRefNestedInput
    works?: TemplateWorkUncheckedUpdateManyWithoutDataNestedInput
    deds?: TemplateDEDUncheckedUpdateManyWithoutDataNestedInput
    fields?: TemplateFieldUncheckedUpdateManyWithoutDataNestedInput
  }

  export type TemplateDataUncheckedUpdateManyWithoutRecordsInput = {
    step?: IntFieldUpdateOperationsInput | number
    publish?: BoolFieldUpdateOperationsInput | boolean
    around?: XOR<TAroundNullableUpdateEnvelopeInput, TAroundCreateInput> | null
    properties?: XOR<TPropertyUpdateEnvelopeInput, TPropertyCreateInput>
  }

  export type HistoriUpdateWithoutTemplateInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ref?: UserUpdateOneRequiredWithoutTrackersNestedInput
    user?: UserUpdateOneWithoutHistorisNestedInput
    company?: CompanyUpdateOneWithoutHistorisNestedInput
    option?: OptionUpdateOneWithoutHistorisNestedInput
    unit?: UnitUpdateOneWithoutHistorisNestedInput
    item?: ItemUpdateOneWithoutHistorisNestedInput
    work?: WorkUpdateOneWithoutHistorisNestedInput
    workItems?: WorkItemsUpdateOneWithoutHistorisNestedInput
    image?: ImageUpdateOneWithoutHistorisNestedInput
    file?: FileUpdateOneWithoutHistorisNestedInput
  }

  export type HistoriUncheckedUpdateWithoutTemplateInput = {
    type?: EnumHistoriTypeFieldUpdateOperationsInput | HistoriType
    model?: EnumHistoriModelFieldUpdateOperationsInput | HistoriModel
    step?: NullableIntFieldUpdateOperationsInput | number | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    refId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    optionId?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    itemId?: NullableStringFieldUpdateOperationsInput | string | null
    workId?: NullableStringFieldUpdateOperationsInput | string | null
    workItemsId?: NullableStringFieldUpdateOperationsInput | string | null
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TemplateWorkItemCreateManyParentInput = {
    id?: string
    type: ItemModel
    itemId: string
    coefficient: number
    unitId: string
  }

  export type StageCreateManyWorkInput = {
    id?: string
    type: StageType
    operation: StageOpr
    parentId?: string | null
    refs?: string | null
    refParent?: boolean | null
    name?: string | null
    long: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    width: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    height: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    amount: XOR<StageValueCreateEnvelopeInput, StageValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type TemplateWorkItemUpdateWithoutParentInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    coefficient?: FloatFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutTWorksNestedInput
    unit?: UnitUpdateOneRequiredWithoutTWorkItemsNestedInput
  }

  export type TemplateWorkItemUncheckedUpdateWithoutParentInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateWorkItemUncheckedUpdateManyWithoutItemsInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    coefficient?: FloatFieldUpdateOperationsInput | number
    unitId?: StringFieldUpdateOperationsInput | string
  }

  export type StageUpdateWithoutWorkInput = {
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type StageUncheckedUpdateWithoutWorkInput = {
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type StageUncheckedUpdateManyWithoutStagesInput = {
    type?: EnumStageTypeFieldUpdateOperationsInput | StageType
    operation?: EnumStageOprFieldUpdateOperationsInput | StageOpr
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    refs?: NullableStringFieldUpdateOperationsInput | string | null
    refParent?: NullableBoolFieldUpdateOperationsInput | boolean | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    long?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    width?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    height?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    amount?: XOR<StageValueUpdateEnvelopeInput, StageValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type TPropertyPriceCreateworkIdsInput = {
    set: Enumerable<string>
  }

  export type SpaceCreateManyRefInput = {
    id?: string
    name: string
    long: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    width: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    height: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    amount: XOR<SpaceValueCreateEnvelopeInput, SpaceValueCreateInput>
    values: XOR<TValuesCreateEnvelopeInput, TValuesCreateInput>
  }

  export type TemplateWorkCreateManyDataInput = {
    id?: string
    workId: string
  }

  export type TemplateDEDCreateManyDataInput = {
    id?: string
    name: string
    lists?: XOR<TDeDListListCreateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateFieldCreateManyDataInput = {
    id?: string
    name: string
    imageId?: string | null
    imageUrl?: string | null
    lists?: XOR<TFieldListListCreateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TAroundUpdateInput = {
    long?: NullableStringFieldUpdateOperationsInput | string | null
    width?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TPropertyIntroListUpdateEnvelopeInput = {
    set?: Enumerable<TPropertyIntroCreateInput>
    push?: Enumerable<TPropertyIntroCreateInput>
    updateMany?: TPropertyIntroUpdateManyInput
    deleteMany?: TPropertyIntroDeleteManyInput
  }

  export type TPropertyPriceListUpdateEnvelopeInput = {
    set?: Enumerable<TPropertyPriceCreateInput>
    push?: Enumerable<TPropertyPriceCreateInput>
    updateMany?: TPropertyPriceUpdateManyInput
    deleteMany?: TPropertyPriceDeleteManyInput
  }

  export type SpaceUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceUncheckedUpdateWithoutRefInput = {
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type SpaceUncheckedUpdateManyWithoutSpacesInput = {
    name?: StringFieldUpdateOperationsInput | string
    long?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    width?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    height?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    amount?: XOR<SpaceValueUpdateEnvelopeInput, SpaceValueCreateInput>
    values?: XOR<TValuesUpdateEnvelopeInput, TValuesCreateInput>
  }

  export type TemplateWorkUpdateWithoutDataInput = {
    work?: WorkUpdateOneRequiredWithoutTemplatesNestedInput
    items?: TemplateWorkItemUpdateManyWithoutParentNestedInput
    stages?: StageUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkUncheckedUpdateWithoutDataInput = {
    workId?: StringFieldUpdateOperationsInput | string
    items?: TemplateWorkItemUncheckedUpdateManyWithoutParentNestedInput
    stages?: StageUncheckedUpdateManyWithoutWorkNestedInput
  }

  export type TemplateWorkUncheckedUpdateManyWithoutWorksInput = {
    workId?: StringFieldUpdateOperationsInput | string
  }

  export type TemplateDEDUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDUncheckedUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateDEDUncheckedUpdateManyWithoutDedsInput = {
    name?: StringFieldUpdateOperationsInput | string
    lists?: XOR<TDeDListListUpdateEnvelopeInput, Enumerable<TDeDListCreateInput>>
  }

  export type TemplateFieldUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
    image?: FileUpdateOneWithoutFieldsNestedInput
  }

  export type TemplateFieldUncheckedUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lists?: XOR<TFieldListListUpdateEnvelopeInput, Enumerable<TFieldListCreateInput>>
  }

  export type TFieldListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumEFieldTypeFieldUpdateOperationsInput | EFieldType
  }

  export type TDeDListUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    top?: IntFieldUpdateOperationsInput | number
    left?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type CoordinateWhereInput = {
    AND?: Enumerable<CoordinateWhereInput>
    OR?: Enumerable<CoordinateWhereInput>
    NOT?: Enumerable<CoordinateWhereInput>
    longitude?: FloatFilter | number
    latitude?: FloatFilter | number
  }

  export type TPropertyIntroWhereInput = {
    AND?: Enumerable<TPropertyIntroWhereInput>
    OR?: Enumerable<TPropertyIntroWhereInput>
    NOT?: Enumerable<TPropertyIntroWhereInput>
    itemId?: StringFilter | string
    qty?: IntFilter | number
  }

  export type TPropertyPriceWhereInput = {
    AND?: Enumerable<TPropertyPriceWhereInput>
    OR?: Enumerable<TPropertyPriceWhereInput>
    NOT?: Enumerable<TPropertyPriceWhereInput>
    type?: EnumItemModelFilter | ItemModel
    itemId?: StringFilter | string
    workIds?: StringNullableListFilter
    coefficient?: FloatFilter | number
    rounding?: IntFilter | number
    price?: IntFilter | number
    pph?: BoolFilter | boolean
    ppn?: BoolFilter | boolean
  }

  export type NestedEnumEFieldTypeFilter = {
    equals?: EFieldType
    in?: Enumerable<EFieldType>
    notIn?: Enumerable<EFieldType>
    not?: NestedEnumEFieldTypeFilter | EFieldType
  }

  export type CoordinateUpsertInput = {
    set: CoordinateCreateInput | null
    update: CoordinateUpdateInput
  }

  export type TPropertyIntroUpdateManyInput = {
    where: TPropertyIntroWhereInput
    data: TPropertyIntroUpdateInput
  }

  export type TPropertyIntroDeleteManyInput = {
    where: TPropertyIntroWhereInput
  }

  export type TPropertyPriceUpdateManyInput = {
    where: TPropertyPriceWhereInput
    data: TPropertyPriceUpdateInput
  }

  export type TPropertyPriceDeleteManyInput = {
    where: TPropertyPriceWhereInput
  }

  export type EnumEFieldTypeFieldUpdateOperationsInput = {
    set?: EFieldType
  }

  export type CoordinateUpdateInput = {
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
  }

  export type TPropertyIntroUpdateInput = {
    itemId?: StringFieldUpdateOperationsInput | string
    qty?: IntFieldUpdateOperationsInput | number
  }

  export type TPropertyPriceUpdateInput = {
    type?: EnumItemModelFieldUpdateOperationsInput | ItemModel
    itemId?: StringFieldUpdateOperationsInput | string
    workIds?: TPropertyPriceUpdateworkIdsInput | Enumerable<string>
    coefficient?: FloatFieldUpdateOperationsInput | number
    rounding?: IntFieldUpdateOperationsInput | number
    price?: IntFieldUpdateOperationsInput | number
    pph?: BoolFieldUpdateOperationsInput | boolean
    ppn?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TPropertyPriceUpdateworkIdsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}